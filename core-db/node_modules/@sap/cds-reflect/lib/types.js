//
//  Type system root classes 
//

class any { 
	static get _cds(){return true}
	get isLinked(){return true} 
	own (key) {
		return this.hasOwnProperty(key) && this[key]
	}
	set (key, value) {
		Object.defineProperty (this, key, {value, writable:1, configurable:1 })
        return value
	}
	static mixin (methods) { 
		 for (let each of Reflect.ownKeys (methods)) {
			Object.defineProperty (this.prototype, each, 
				Object.getOwnPropertyDescriptor (methods, each)
			)
		}
		return this
	}
 }
class type extends any {}
class scalar extends type {}
class string extends scalar {}
class number extends scalar {}
class boolean extends scalar {}
class date extends scalar {}
class struct extends type {}
class entity extends struct {
	get keys(){ 
		if (this === entity.prototype)  return 
		let ee=this.elements, keys, dict={}
		for (let e in ee)  if (ee[e].key)  (keys=dict)[e] = ee[e]
        return this.set ('keys',keys)
	 }
 }
class view extends entity {}  // FIXME: only because cdsv still uses kind=view
class array extends type {}
class Association extends type {
    get foreignkeys(){ return this.set ('elements', (
        this.keys ? this.keys.reduce ((fks,x) => {
            let {ref,as} = x.ref  ? x  :  { ref:x, as:x.match(/[^.]+$/)[0] }
            try { var fk = ref.split('.') .reduce ((p,n) => p.elements[n], this._target) } catch(e){}
            fks[as] = fk ? Object.defineProperties ({__proto__:fk}, {name:{value:as}, '>':{value:ref}}) 
            :  new absent ({name:this.target+':'+ref})
            return fks
        },{}) 
        :  this.target.kind == 'any' ? Object.assign ({ $target }, this._target.elements) 
        :  !this.on && this.is2one  ?  this._target.keys 
        :  null
     ))}
    get is2one(){ return !this.cardinality || this.cardinality.targetMax === 1 }
    get is2many(){ return !this.is2one }
 }
class Composition extends Association {}
class context extends any {}
class service extends context {}

const classes = {
    any, type, scalar, boolean, number, string, date, array, struct, 
    entity, view, Association, Composition, context, service, 
}


//
//  Built-in types
//

const builtin = {
	UUID: { type:'string', length:36 },
	Boolean: {type:'boolean'},
	Integer: {type:'number'},
	Integer16: {type:'Integer'},
	Integer32: {type:'Integer'},
	Integer64: {type:'Integer'},
	Decimal: {type:'number'},
	DecFloat: { type:'number' },
	Float: {type:'number'},
	Double: {type:'number'},
	DateTime: {type:'date'},
	Date: {type:'date'},
	Time: {type:'date'},
	Timestamp: {type:'date'},
	String: {type:'string'},
	Binary: {type:'string'},
	LargeString: {type:'string'},
	LargeBinary: {type:'string'},
}

const types = {__proto__:builtin}
for (let n in types) {
	let t = types[n]
	;(types['cds.'+n] = t) .__proto__ = classes[t.type] ? classes[t.type].prototype : types[t.type]
}
for (let n in classes)  builtin[n] = classes[n].prototype
types['cds.Association'] = Association.prototype
types['cds.Composition'] = Composition.prototype

Object.defineProperty (classes, 'mixin', {value: (aspects) => {
	for (let each in aspects) {
		for (let kind of Reflect.ownKeys (aspects[each])) {
			Object.defineProperty (types[kind], each, 
				Object.getOwnPropertyDescriptor (aspects[each], kind)
			)
		}
	}
}})

module.exports = { types, classes }
/* eslint no-mixed-spaces-and-tabs:0 */