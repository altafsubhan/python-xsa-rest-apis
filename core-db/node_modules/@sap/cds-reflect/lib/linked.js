const { types, classes, classes: {any,array,struct} } = require ('./types')
const kinds = {}; for (let c in classes)  if (c !== 'type')  kinds[c] = classes[c].prototype
const reflect = require ('./reflect')
const _linked = Symbol('is linked')

module.exports = function linked (model) {

    if (typeof model === 'string')  model = this.parse (model)
    if (model[_linked])  return model

    const m = reflect(model), defs = m.definitions;  m[_linked] = true
    return m.foreach ((d,_) => { //eslint-disable-line no-unused-vars
        let proto = (
            d.type ? defs[d.type] || types[d.type] || unresolved(d.type)  :
            d.kind && kinds[d.kind]  ||
            d.elements && struct.prototype  ||
            d.items && array.prototype  ||
            any.prototype
        ) 
        try { Object.setPrototypeOf (d,proto) } 
        catch(e){ throw new cyclic (d,proto) }
        if (d.target)  d.set ('_target', defs [d.target])
        if (d.via)  d.set ('_via', defs [d.via])
    })

    function unresolved (name) {
        let missing = {name, isUnresolved:true, __proto__:any}
        Object.defineProperty (defs, name, {value:missing})
        return missing
    }
}

class cyclic extends Error {
    constructor (...chain) { super (
        'circular dependency: ' + chain.map(p => p.name).join(' -> '), chain[0]
    )}
}