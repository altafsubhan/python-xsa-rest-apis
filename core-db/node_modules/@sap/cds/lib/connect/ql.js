const cds = require ('../index')

/** Base class for all query builders */
class Statement {
	constructor (props) { Object.assign (this,props).new() }
	new(){/* cds.run plugs in here to queue nested stmts */}
	then (res,err) { return cds.run(this) .then (res,err) }
	foreach (cb) { return this.then (rows => { for (let r of rows) cb(r); return rows })}
}


//
//  Query builder classes
//

class SELECT extends Statement {

	from (entity, ...more) {
		let last = more [more.length-1]
		if (last && typeof last !== 'string') { this.columns(last);  more = more.slice(0,-1) }

		// if called with a single entity name or definition use optimized impl
		if (!more.length && (entity.ref || entity.name || !/[:[(]/.test(entity))) {
			this.from = entity.ref ? entity : {ref:[ entity.source || entity.name || entity ]}
			return this
		}

		// need parser for calls with complex from clause or additional parameters
		let cql = 'SELECT from '+ (entity.source || entity.name || entity) + more.map (x=>' '+x)
		let cqn = cds.parse.cql (cql)
		return Object.assign (this, cqn.SELECT)
	}
	columns(...x){ this.columns = columns4(Array.isArray(x[0]) ? x[0] : x); return this }
	excluding(...x){ this.excluding = x; return this }
	where(...x){ this.where = predicate4(x); return this }
	groupBy(...x){ this.groupBy = x.map (x => expr4(x)); return this }
	orderBy(...x){ this.orderBy = order4(x); return this }
	having(...x){ this.having = predicate4(x); return this }
	limit(rows, offset=0) { this.limit = {rows,offset}; return this }
	by (primaryKey) { return this.where({ID: primaryKey}) }

}

class INSERT extends Statement {
	static into(x) { return new INSERT ({ into: x.source || x.name || x }) }
	columns (...x) { this.columns = x[0] instanceof Array ? x[0] : x; return this }
	values (...x) { this.values = x[0] instanceof Array ? x[0] : x; return this }
	rows (...x) { this.rows = x; return this }
	entries (...x) { this.entries = x; return this }
	as (query) { this.as = query; return this  }
	valueOf() { return `INSERT into "${this.entity}" ` }
}

class UPDATE extends Statement {
	static entity(x) { return new UPDATE ({ entity: x.source || x.name || x }) }
	set (...x) { this.data = data4(x); return this }
	where (...x) { this.where = predicate4(x); return this }
	valueOf() { return `UPDATE "${this.entity}" ` }
}

class DELETE extends Statement {
	static from(x) { return new DELETE ({ from: x.source || x.name || x}) }
	where (...x) { this.where = predicate4(x); return this }
	valueOf() { return `DELETE from "${this.entity}" ` }
}

class CREATE extends Statement {
	static entity(e, elements) { return new CREATE ({ entity:e, elements }) }
	as (query) { this.as = query; return this  }
}

class DROP extends Statement {
	static entity(e) { return new DROP ({ entity:e }) }
	static table(e) { return new DROP ({ entity:e, table:e }) }
	static view(e) { return new DROP ({ entity:e, view:e }) }
}


//
//  Helpers...
//

function expr4(x, ...more) {
	let e = (/[^\w.]/.test(x))  ?  {ref:x.split(':')}  :  cds.parse.expr(x)
	for (let i=0; i<more.length; ++i)  e[more[i]] = more[++i]
	return e
}

function columns4 (cols) {

	if (typeof cols[0] === 'function') {
			// Turn an arrow function into a CQL projection
		let {SELECT} = cds.parse.cql ('SELECT from _ '+ cols[0].toString()
			// .replace (/^[()\w]+\s*=>\s*{\s*|\s*}$/g,'')		// strip outmost ()=>{ ... }
			.replace (/\s*.expand\s*\(\(\)\s*=>\s*/g,' ')	            // .expand (()=>{ becomes ' {'
			.replace (/\s*.expand\s*\((\w*)\s*=>\s*/g,' $1 ')	    // .expand ((x)=>{ becomes ' x {'
			.replace (/\s*.inline\s*\(\(\)\s*=>\s*/g,' .')	            // .inline (()=>{ becomes ' .{'
			.replace (/\s*.inline\s*\((\w*)\s*=>\s*/g,' $1.')	    // .inline ((x)=>{ becomes ' x.{'
			.replace (/\(\)\s*=>\s*/g,'')				// ()=> becomes ''
			.replace (/(\w*)\s*=>\s*/g,'$1 ')				// foo=> becomes 'foo '
			.replace (/\s*{\s*'\*'\s*}/g,'{*}') 			   // {'*'} becomes {*}
			.replace (/'\*'/g,'*')				// // '*' becomes *
			.replace (/}\)/g,'}')	    						    // }) becomes }
			.replace (/\s*.as\s*\((\w+)\)/g,' as $1') 		    // .as (alias) becomes ' as alias'
			.replace (/\s*.as\s*\(\/([^/]+)\/\)/g,' : $1') 		    // .as (/type/) becomes ' : type'
		)
		return SELECT.columns
	}

	let i=0, columns=[]
	cols.forEach (e=>{
		if (typeof e === 'string') {
			if (e === '*')  return columns[i++] = e === '*'
			if (/(.*) as (\w+)$/.test(e))  return columns[i++] = expr4 (RegExp.$1, 'as', RegExp.$2)
			return columns[i++] = expr4(e)
		}
		if (Array.isArray(e)) {
			return columns[i-1].inline = columns4(e)
		}
		if (typeof e === 'function') {
			return columns[i-1].expand = columns4(e())
		}
		if (typeof e === 'object') for (let x in e) {
			return columns[i++] = expr4(x, 'as', e[x])
		}
		else  return columns[i++] = {val:e}
	})
	return columns
}

function predicate4 (args) {

	// e.g.  .where ({ID:4711, stock: {'>=':1})
	if (typeof args[0] === 'object') {
		let all=[]; for (let k in args=args[0]) {
			let x = args[k]
			if (k === '$and') { all.push ('and', ...predicate4([x])); continue }
			if (k === '$or') { all.push ('or', ...predicate4([x])); continue }
			else  all.push ('and', {ref:k.split('.')})
			if (x === null || x === undefined)  all.push ('is null')
			else if (x.ref || x.val || x.xpr)  all.push ('=', x)
			else if (x.SELECT)  { all.push ('in', x);  x.isSubSelect = true; }
			else if (x instanceof Array)  all.push ('in', {val:x})
			else if (x instanceof RegExp)  all.push ('like', {val:x})
			else if (typeof x === 'object') for (let op in x)  all.push (op, {val:x[op]})
			else all.push ('=', {val:x})
		}
		return all.slice(1)

	// e.g.  .where ('ID=',4711, 'and stock >=',1)
	} else {
		// construct and parse the full expression string
		let s="", values=[];  for (let i=0; i<args.length; ) {
			s += " "+ args[i++];  if (i == args.length)  break
			s += "?";  values.push (args[i++])
		}
		let xpr = cds.parse.expr(s).xpr, k=0
		// fill in values
		for (let x of xpr) if (x.param) {
			let v = values[k++]
			if (v && v.SELECT)  x.SELECT = v.SELECT
			else { x.val = v; delete x.param; delete x.ref }
		}
		return xpr
	}
}

function data4 (args) {

	const data={}, _add = (col,op,val) => data[col] = (
		val === null || val === undefined  ?  {val:null}  :
		val['-='] || op === '-='  ?  {xpr:[ {ref:[col]}, '-', {val} ]}  :
		val['+='] || op === '+='  ?  {xpr:[ {ref:[col]}, '+', {val} ]}  :
		val['=']  ?  {ref:[val['=']]}  :  {val}
	)

	if (typeof args[0] === 'object') {
		// e.g.  .with ({ stock:{'-=':1}, lastOrder:{'=':'$now'} })
		for (let col in args=args[0]) {
			let val = args[col]
			if (typeof val === 'object') for (let op in val)  _add (col, op, val[op])
			else  _add (col, '=', val)
		}
	} else {
		// e.g.  .with ('stock -=',1, 'lastOrder =', '$now')
		for (let i=0; i<args.length; ++i) {
			let [lhs,op] = cds.parse.expr (args[i] +" 0").xpr
			_add (lhs.ref[0], op, args[++i])
		}
	}
	return data

}

function order4 (args) {
	if (typeof args[0] === 'object') {
		let all=[]; for (let x in args=args[0]) {
			let o = {ref:x.split('.')}
			if (args[x] > 0) o.asc = true; else o.desc = true
			all.push (o)
		}
		return all
	}
	else return args.map (x => (
		x.endsWith(' asc')  ?  expr4 (x.slice(0,-4), 'asc', true)  :
		x.endsWith(' desc')  ?  expr4 (x.slice(0,-4), 'desc', true)  :
		expr4(x)
	))
}


//
//  Module Exports
//

// We expose the base class with static properties for the individual classes
const ql = module.exports = {
	SELECT, INSERT, UPDATE, DELETE, CREATE, DROP
}
Object.defineProperty (ql, 'Statement', {value:Statement})

// Add CQN accessors to individual classes
for (let x in ql) Object.defineProperty (ql[x].prototype, x, { get(){
	return Object.defineProperty (this, x, {value:Object.assign({},this)}) [x]
}, configurable: true })

// SELECT and UPDATE are special
ql.SELECT = Object.assign ((...cols) => (new SELECT).columns(cols), {
	get distinct() { return new SELECT ({ distinct:true }) },
	from (...args) { return (new SELECT) .from (...args) },
	one (...args) { return new SELECT ({one:true}) .from (...args) },
})
ql.UPDATE = e => UPDATE.entity(e)

// for quick tests
if (!module.parent)  Object.assign (global,ql)
