const pragmas = /(?:=>)\s*{\s*"(serialized|sequential(?:ly)?)? ?(transaction(?:al)?)?"/
const cds = require('../index'), stmt = cds.ql.Statement.prototype


class Connection {

	constructor (_init) { Object.assign(this,_init) }

	run (x, args, callback) {
		const p = typeof x === 'function' ? _run_block (x,this)
			: this.dbc.execute (x, args, callback) .then (x.one && (res => res[0]))
		return promise (p,this)
	}

	foreach (q, args, callback) {
		if (typeof q === 'string' && /^select|with/i.test(q))  q = 'select * from '+ q
		if (typeof args === 'function')  [args,callback] = [undefined,args]
		return this.run (q, args, callback)
	}

}

Object.assign (Connection.prototype, cds.ql)
module.exports = { Connection, promise }


/**
 * Runs a block as in cds.run(db=>{ ... }) collecting and finally executing
 * all contained queries and calls to db.run
 */
function _run_block (fn, conn) {

	// hereby we collect queries and calls to .run contained in fn
	const queued=[],  queue = ([q,...etc]) => {
		queued.push (()=> q.isSubSelect || conn.run(q,...etc) .then (tail.resolve))
		const tail = promise();  return tail
	}

	// run the fn, collecting all contained queries and calls to .run
	const inner = { run:(...a) => queue(a), __proto__:conn }
	const _new = stmt.new
	try { stmt.new = function(){ this.then = queue ([this]).then.bind(this) }
		let res = fn (inner)
		if (!queued.length)  return Promise.resolve(res)  //> nothing else to do
	} finally { stmt.new = _new }

	// finally execute the collected queries...
	const [, serialized, transaction ] = pragmas.exec(fn) || []
	const _run = ()=> serialized
		?  queued.reduce ((p,each)=>p.then(each), Promise.resolve())
		:  Promise.all (queued.map (each=>each()))

	// ... enclosed in  a transaction or not
	return !transaction ? _run() :
	conn.dbc.begin() .then (_run) .then (res => conn.dbc.commit().then(()=>res))
}

/**
 * Decorates a promise with two additional operations:
 * - p.then.run(...)  -->  a shortcut to  p.then(()=>cds.run(...))
 * - p.finally(...)  -->  schedules handlers to run after all others chained subsequently
 */
function promise (head, conn) {
    const tail=[], last=[], p = { conn,
		resolve(x) {
            if (!tail.length && !last.length)  return x
            let p = tail.reduce ((p,n) => p.then(n), Promise.resolve(x))
            return last.reduce ((p,n) => p.then(n), p)
        },
        then(x) { tail.push(x); return p },
        finally(x) { last.push(x); return p },
        catch(x) { head.catch(x); return p },
    }
    p.then.run = (x) => p.then (()=> p.conn.run(x))
    head && head.then (p.resolve)
    return p
}