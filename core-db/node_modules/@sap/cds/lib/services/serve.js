const cds = require('../index.js')
const path = require('path')

module.exports = cds_serve
/*USAGE:*/;() => {
  const app = require('express')()
  cds.serve('all').in(app)  //> no subsequent .at() or .with() possible
  cds.serve('single').in(app).at('/mount-point').with(function ({Books}) {
    this.on('READ', Books, (cds) => cds.reply({}))
  })
}


/** Load given model(s) and construct providers for all defined services. */
function cds_serve (model, options={}) {

  const console = options.log || global.console
  if (model === 'all' || model[0] === 'all') {
    const _m = this.config.service.model
    model = _m ? cds.resolve(_m) : [ 'srv', 'services' ].find (m => cds.resolve(m))
    if (!model)  throw new Error (`[cds] - \n
      No service models found in current working directory.
      Make sure you call cds.serve in the root of your project.
    `)
  }
  let ready = this.load(model).then(_addProviders)
  const providers = []    //> filled by _addProviders when model is loaded

  return {
    // Fluent API to fill in options subsequently (= yet before model is loaded)
    at (path) {
      options.at = path
      return this
    },
    with (impl) {
      options.with = impl
      return this
    },

    /** Add all providers as routers to the given express app */
    in (app) {
      this.then(() => {
        for (let p of providers) {
          app.get(`${p.path}/\\$metadata`.replace(/[/]{2,}/g, '/'), (req, res) => {
            res.set('Content-Type', 'application/xml') .send(
              p.edmx || (p.edmx = cds.compile.to.edmx (p.definition, {service:p.options.service}))
            )
          })
          app.use(p.path, p.getMiddleWare())
        }
      })
      return this
    },

    to (/* odata */) {

    },

    /** Construct and launch an express app with the providers */
    listen (port = 4004, callback = undefined) {
      let app = require('./server')
      return this.in(app).then(() => app.listen(port, callback || (
        () => console.log(`\n  cds.server listens at http://localhost:${port} \n`)
      )))
    },

    // Allow consumers to act subsequently
    then (next) { return ready = ready.then(next) },
    catch (err) { return ready = ready.catch(err) },
  }

  /**
   * Construct providers for all services defined in the loaded model.
   */
  function _addProviders (csn, o = options, n = 0) {
    console.log(`[cds] - loaded service definitions from \n\n  ${csn._sources.map(_local).join('\n  ')} \n`)
    cds.reflect(csn).foreach(cds.service, def => {
      if (def['@cds.ignore']) return
      if ((o.at || o.with) && ++n > 1) throw new Error('You cannot specify `path` or `impl` for multiple services')
      const impl = _impl4(def, o.with)
      const service = cds.service(csn, {service: def.name, __proto__: o}, impl)
      const path = service.path = _path4(def, o.at)
      console.log('[cds] - serving', def.name, 'at', path, impl ? '- impl: ' + _local(impl._source) : '')
      _addTemporaryWorkaround(service)
      providers.push(service)
    })
  }

}

const _addTemporaryWorkaround = (service) => {
  const {Connection} = require ('../connect/run')
  const handler = (cds) => {
    if (cds.dbc) {
      cds.run = Connection.prototype.run
    }
  }
  service.before('CREATE', handler)
  service.before('UPDATE', handler)
  service.before('READ', handler)
  service.before('DELETE', handler)
}

/**
 * Resolve a service implementation function as follows...
 * 1. if _impl is a function --> got it
 * 2. if _impl is a string --> `require (it)`
 * 3. if def is annotated with @impl --> `require (def@impl)`
 * 4. if we got the model's source --> `require (<basename>.js)`
 */
function _impl4 (def, _impl = def['@impl']) {
  let impl = _impl
  if (typeof impl === 'function') {
    return Object.defineProperty (impl, '_source', {value: impl.name || '<inline>'})
  } else if (!impl) { // find a service implementation adjacent to the source model file
    if (!def._location || !def._location.filename) return
    impl = path.resolve (def._location.filename.replace(/\.(cds|json|yaml)$/, '.js'))
  } else {
    impl = path.resolve (impl)
  }
  try { return Object.defineProperty (require(impl), '_source', {value: impl}) }
  catch (e) { if (_impl || e.code !== 'MODULE_NOT_FOUND') throw e }
}

function _path4 (def, _path) {
  return _path || def['@path'] || '/' + (
    /[^.]+$/.exec(def.name)[0].replace(/Service$/, '').replace(/^(.)/, c => c.toLowerCase())
  )
}

function _local (filename) { return path.relative('', filename) }

/* eslint no-console:off */
