const cdsv = require('./cdsv')
const cds = require('../index')

const YAML = { stringify: (...args) => (YAML.stringify = require('./2yaml'))(...args) }
const SQL = { for: (...args) => (SQL.for = require('../connect/2sql'))(...args) }

// Our API (--> cds.compile, https://bit.ly/-cdxjs#cds-compile)
const compile = module.exports = Object.assign (
  (csn) => ({to:(x,o) => compile.to[x](csn,o) }), { to: {
    json: x => JSON.stringify(x,null,'    '),
    yaml: YAML.stringify,
    yml: YAML.stringify,
    // sql: (csn,o={}) => _2structuredOut(cdsv.toSql(csn,_sql_naming(o)).sql,'.sql'),
    sql: (csn,o={}) => { let x = SQL.for(csn,o); return o.as=='str' ? x.reduce((p,n)=> p+n+'; \n\n','\n') : x },
    cdl: (csn,o={}) => _2structuredOut(cdsv.toCdl(csn,o),'.cds'),
    hana: (csn,o={}) => _2hana (cdsv.toHana(csn,_sql_naming(o)).hdbcds,o),
    edm: (csn,o={}) => _2odata (csn,o, 'metadata_json'),
    edmx: (csn,o={}) => _2odata (csn,o, {off: 'metadata', only: 'annotations'}[o.annos] || 'combined'),
    annos: (csn,o={}) => _2odata (csn,o, 'annotations'),
    swgr: (csn,o={}) => { let x = cdsv.toSwagger(csn,o); return o.as ? compile.to[o.as=='str'?'yml':o.as](x) : x },
  }, suffixes: {
    cdl: '.cds',
    yaml: '.yml',
    annos: '.annotations.xml',
    edmx: '.edm.xml',
    edm: '.edm.json',
    swgr: '.swgr.yml',
    hana: '.hdbcds',
  }}
)

function _sql_naming (options) {
  return Object.assign({toHana:{
    names: { slugified: 'flat', plain: 'flat', quoted: 'deep', }[ cdsv.sqlMapping(options) ],
    associations: 'assocs'}
  }, options)
}

function _2hana(hdbcds, o={}) {
  const resultSize = Object.keys(hdbcds).length
  const generator = (function* () { //NOSONAR
    for (let name in hdbcds) {
      const filename = name.replace(/[.:/\\]/g, '_')
      yield [hdbcds[name], { name: filename, suffix: '.hdbcds' }]
    }
    // Add an .hdinamespace file that prevents the gen/ dir to be appended as a namespace segment.
    // This would happen if the src/ dir above adds an .hdinamespace with 'subfolder:append'.  See issue #64.
    if (o.extraArtifacts && resultSize > 0) {
      yield [{ name: '', subfolder: 'ignore' }, { name: '.hdinamespace', suffix: '' }]
    }
  })()
  return generator
}

function _2structuredOut(result, suffix) {
  const generator = (function* () { //NOSONAR
    for (let name in result) {
      const filename = name.replace(/[.:/\\]/g, '_')
      yield [result[name], { name: filename, suffix }]
    }
  })()
  return generator
}

/** Extracts requested outcomes from the all-in-one results obtained from cdsv.
 * E.g. for
 *
 * > _compile.to.edmx(csn,{service:'**A**','metadata'})_
 *
 * cdsv would return the like of
 * _{ **A**: { metadata:{...}, annotations:{...} }, **B**: {...}, ... }_
 *
 * Which we would return as
 * _{ **A**: {...} }_
 */
function _2odata (csn,o={}, requested) {
  o.json = (o.version !== 'v2');
  o.xml = o.combined = o.separate = true
  // REVISIT: Warum akzeptiert toOdataOutput kein zuvor erzeugtes Ergebnis von transform4OData?
  let allin1 = csn._odata; if (!allin1)  Object.defineProperty (csn, '_odata', {value:
    allin1 = cdsv.toOdata(csn, o),
    configurable:1, writable:1
  })
  if (!allin1 || !allin1.services)  throw new Error('No service definitions found')
  if (requested === 'csn')  return allin1.csn
  let services = allin1.services
  if (o.service === 'all')  return (function*(){ //NOSONAR
    for (let name in services)  yield [ _selectOutput (services[name][requested]), {name} ]
  })()
  if (!o.service) {
    let chosen = cds.reflect(csn).find (s => s['@cds.chosen.service'])
    if (chosen)  o.service = chosen.name
  }
  if (o.service) {
    for (let each in services) if (each.indexOf(o.service) >= 0)  return _selectOutput (services[each][requested])
    throw new Error (
      `[cds.compile.to.${requested}] - didn't find service definition matching ${o.service}`
    )
  }
  if (Object.keys(services).length > 1)  throw new Error (_choose_one())
  for (let each in services)   return _selectOutput(services[each][requested])

  function _selectOutput (out) {
    if (requested === 'metadata_json' && o.as === 'str')  return JSON.stringify(out)
    return out
  }

  function _choose_one(){
    return `[cds.compile.to.${requested}] - multiple service definitions in model:

    ${Object.keys(services).join('\n    ')}

  please choose one or all using --service all | <one of above> from the CLI
  or { service:'all' | <...> } from the API respectively.
  `
  }
}
