#!/usr/bin/env node

/* eslint no-console:off */

// File for the client tool = command which is installed in $PATH with
//   npm install -g

// Usage, see "cdsv -h" for details
//   cdsv [options] <file...>'
//
// For the exit code, we follow the "grep" example / exit status convention
// (http://stackoverflow.com/questions/1101957/are-there-any-standard-exit-status-codes-in-linux):
//  - 0: success
//  - 1: compiled with error
//  - 2: command line usage error
//
// The theoretic standard can be found with "man sysexits"
// (http://www.tldp.org/LDP/abs/html/exitcodes.html).

'use strict';
var util = require('util');
var fs = require('fs');
var path = require('path');
var reveal = require('./raw-output');

// commander has quite a few issues, but hdi also uses commander...,
// TODO: check subcommander instead, NPM uses nopt
// There is also node-getopt, posix-getopt, getopt-c, option-parser, ...
// Discussion: https://github.com/pegjs/pegjs/issues/429
var program = require('commander');
var compiler = require('../lib/main');
const tntSpecific = require('../lib/edm/tntSpecific');

if (require.main == module) {
  program
    .version(compiler.version())
    .usage('[options] <file...>')
    .option('-R, --raw-output', 'raw augmented CSN and error output')
    .option('-U, --re-augmented', 're-augmented CSN and error output')
    .option('-X, --extra-augment', 're-compile CSN via augmentation, for testing')
    .option('-l, --lint-mode', 'no success output, no error for USINGs pointing to nothing')
    .option('-b, --test-mode', 'normalize filename in errors to Posix, do not include version')
    .option('    --beta-mode', 'allow incomplete features')
    .option('    --new-csn', 'new-style CSN')
    .option('    --disable-propagate', 'disable propagation')
    .option('-t, --tnt-flavor', '(temporary): compile with backward-compatibility for TNT')
    .option('    --tnt-output <dir>', '(temporary): write TNT-specific output to <dir> (implies --tnt-flavor)')
    .option('    --oldstyle-self', 'allow "self" alternatively to "$self" (part of --tnt-flavor)')
    .option('    --hana-flavor', 'compile with backward compatibility for HANA (work in progress, still incomplete CSN generation)')
    .option('-T, --trace-parse', 'trace parser')
    .option('    --trace-fs', 'trace file system access' )
    .option('-E, --export-annotations', 'export localized annotations values from a given model')
    .option('    --export-annos-ui5-style <dir>', 'export localized annotations values from a given model in a UI5 style')
    .option('-S, --to-swagger', 'create swagger json')
    .option('-G, --generate-extensions', 'generate extensions CSN from properties file')
    .option('-o, --cdl-output', 'print compilation results as CDL source text to stdout (for tests only)')
    .option('-H, --to-hana', 'print compilation results as HANA CDL source text to stdout (for tests only)')
    .option('    --hana-preprocess', 'preprocess model for HANA and display resulting intermediate CSN (for tests only)')
    .option('-s, --to-sql', '(experimental): print HANA SQL DDL statements creating the model to stdout')
    .option('-C, --check-model', 'perform semantic checks on the model (beta version)')
    .option('    --odata-and-hana-output <dir>', '(temporary): write CSN and ODATA and HDBCDS output to <dir>')
    .option('    --odata-only', '(temporary) generate metadata.xml and annotation.xml only')
    .option('    --odatav4', '(temporary) generate metadata.xml for odata v4')
    .option('    --odata-omit-record-type', '(temporary) omit unnecessary type attribute for records')
    .option('    --odata-preprocess', 'preprocess model for ODATA and display resulting intermediate CSN (for tests only)')
    .option('-p, --parse-only', 'stop after parsing (for tests)')
    .option('-A, --ambig-detection', 'detect parser ambiguities (for manual tests)')
    .option('-w  --warning <level>', 'write not only errors but also warnings up to <level>', parseInt)
    .option('    --draft-extend', 'create draft entities (test only)')
  ;
  program.parse(process.argv);

  // program.rawOutput = true;
  // for longer stacktrace with error messages: uncomment previous line and run with
  //     node --stack_trace_limit=50 ~/bin/cdsv <files>

  // the following should have been done by commander:
  if (!program.args.length)
    program.help();               // well, also some kind of error

  // Translate old command line into options as they would be produced by new command line
  let options = {
    _oldCdsv : true,  // FIXME: Remove, only needed for some backward compatibility hacks
    warning : program.warning === undefined ? 2 : program.warning - 1,  // Old cdsv had warning levels 1..3, with default 3
   // These specify a directory - currently the first one specified wins
    out : program.exportAnnosUi5Style || program.odataAndHanaOutput || program.tntOutput
          || '-', // The rest currently prints to stdout
    toHana : (program.toHana || program.odataAndHanaOutput && !program.odataOnly || program.hanaPreprocess) && {
      src : program.toHana || program.odataAndHanaOutput && !program.odataOnly,
      csn : program.hanaPreprocess,
    },
    toOdata : (program.odataAndHanaOutput || program.odataPreprocess) && {
      version : program.odatav4 ? 'v4' : 'v2',
      xml : !!program.odataAndHanaOutput, // Old version always generates everything
      json : !!program.odataAndHanaOutput,
      separate : !!program.odataAndHanaOutput,
      combined : !!program.odataAndHanaOutput,
      csn : true,
    },
    toCdl : program.cdlOutput,
    toSwagger : program.toSwagger,
    toSql : program.toSql && {
      dialect: 'hana',
    },
    toI18n : (program.exportAnnotations || program.exportAnnosUi5Style) && {
      style: program.exportAnnotations ? 'prop' : 'ui5',
    },
    lintMode : program.lintMode,
    toCsn : !(program.lintMode || program.tntOutput || program.exportAnnotations || program.exportAnnosUi5Style || program.toSwagger
              || program.cdlOutput || program.toHana || program.toSql || program.odataAndHanaOutput || program.hanaPreprocess || program.odataPreprocess), // All of these produce non-CSN output
    checkModel : program.checkModel,
    oldstyleSelf : program.oldstyleSelf,
    tntFlavor : (program.tntFlavor || program.tntOutput != undefined) ? tntSpecific.getDefaultTntFlavorOptions() : false,
    tntCsn : !!program.tntOutput,
    traceParser : program.traceParse,
    traceParserAmb : program.ambigDetection,
    traceFs : program.traceFs,
    rawOutput : program.rawOutput,
    betaMode : program.betaMode,
    newCsn : program.newCsn,    // TEMP
    disablePropagate: program.disablePropagate, // TODO: how to handle this?
    hanaFlavor : program.hanaFlavor,
    parseOnly : program.parseOnly,
    toExtensions : program.generateExtensions,
    testMode : program.testMode,
    extraAugment : program.extraAugment,
    reAugmented : program.reAugmented,
    omitRecordType : program.odataOmitRecordType,
  }
  executeCommandLine(options, program.args)
}

// Executes a command line that has been translated to 'options' (what to do) and 'args' (which files)
// FIXME: This should probably migrate to main.js later
function executeCommandLine(options, args) {
  // FIXME: This option is still used in the API and in the implementation - should be adapted there and then removed here
  if (options.toOdata) {
    options.odataVersion = options.toOdata.version;
  }

  const normalizeFilename = options.testMode && process.platform === 'win32';

  const messageLevels = { Error: 0, Warning: 1, Info: 2 };

  // Create output directory if necessary
  if (options.out && options.out != '-' && !fs.existsSync(options.out)) {
    fs.mkdirSync(options.out);
  }

  var run;
  if (options.toExtensions) {
    // This option can disappear when each extension is tagged whether is has
    // been applied - the compactor could then list the non-applied extensions
    try {
      console.log(JSON.stringify(compiler.generateExtensions(args[0], options), null, 2));
    } catch (err) {
      console.error(err.message);
      process.exit(1);
    }
  }
  else {
    run = compiler.compile( args, undefined, options );
  }

  // The backends (should be changed to async where necessary): ----------------
  if (options.toExtensions) {
    run = null;                   // already done (option to be deleted)
  }
  else if (options.tntCsn) {
    // FIXME: This is the only one that is not actually combinable with others
    run = run.then( tntOutput );
  } else {
    // Backend options (in alphabetical order)
    if (options.toCdl) {
      run = run.then( toCdl );
    }
    if (options.toCsn) {                          // standard: output CSN
      run = run.then( toCsn );
    }
    if (options.toHana) {
      run = run.then( toHana );
    }
    if (options.toI18n) {
      run = run.then( toI18n )
    }
    if (options.toOdata) {
      run = run.then( toOdata );
    }
    if (options.toSql) {
      run = run.then( toSql );
    }
    if (options.toSwagger) {
      run = run.then( toSwagger );
    }
  }
  if(run) {
    run.then(displayMessages, displayErrors);
  }

  if (run) {
    run.catch( internalError );
  }

  // Execute the command line option '--to-cdl' and display the results.
  // Return the original model (for chaining)
  function toCdl( model ) {
    let cdlResult = compiler.toCdl(model);
    for (let name in cdlResult) {
      writeToFileOrDisplay(options.out, name + '.cds', cdlResult[name]);
    }
    return model;
  }

  // Execute the command line option '--to-csn' and display the results.
  // Return the original model (for chaining)
  function toCsn( model ) {
    // Result already provided by caller
    displayNamedCsn(model, 'csn', options);
    return model;
  }

  // Execute the command line option '--to-hana' and display the results.
  // Return the original model (for chaining)
  function toHana( model ) {
    let hanaResult = compiler.toHana(model);
    for (let name in hanaResult.hdbcds) {
      writeToFileOrDisplay(options.out, name + '.hdbcds', hanaResult.hdbcds[name]);
    }
    if (hanaResult.csn) {
      displayNamedCsn(hanaResult._augmentedCsn, 'hana_csn', options);
    }
    return model;
  }

  // Execute the command line option '--to-i18n' and display the results.
  // Return the original model (for chaining)
  function toI18n(model) {
    let i18nResult = compiler.toI18n(model);
    // Different results depending on 'style'
    if (options.toI18n.style == 'prop') {
      writeToFileOrDisplay(options.out, 'annotations.properties', Object.keys(i18nResult).map(prop => `${prop}=${i18nResult[prop]}`).join('\n'), true);
    } else if (options.toI18n.style == 'ui5') {
      let props = '';
      for (let key in i18nResult.properties) {
        props += `${key}=${i18nResult.properties[key]}\n`;
      }
      writeToFileOrDisplay(options.out, 'i18n.properties', props);
      displayNamedCsn(i18nResult, 'definitions', options);
    } else {
      throw new Error(`Invalid style ${options.toI18n.style} for toI18n`);
    }
    return model;
  }

  // Execute the command line option '--to-odata' and display the results.
  // Return the original model (for chaining)
  function toOdata( model ) {
    if (model.options._oldCdsv) {
      // Old command line produced a mixture of V2 and V4, with different filenames - this should be removed soon
      // If --odatav4 is set, only v4 edmx files are generated,
      //   otherwise both v2 and v4 files are created
      let resultV2 = null;
      if (model.options.toOdata.version == 'v2') {
        resultV2 = compiler.toOdataOutput(model, { odataVersion : 'v2' });
      }
      let resultV4 = compiler.toOdataOutput(model, { odataVersion : 'v4' });

      // For backward compatibility only: 'metadata.xml' and 'annotations.xml' (without service names)
      if (resultV4.annotations && resultV4.metadata) {
        // annotations.xml (always V4)
        writeToFileOrDisplay(options.out, 'annotations.xml', resultV4.annotations);
        // metadata.xml (written first for V4, possibly again for V2)
        writeToFileOrDisplay(options.out, 'metadata.xml', resultV2 ? resultV2.metadata : resultV4.metadata);
      }
      // Per-service output files for V2
      if (resultV2) {
        for (let serviceName in resultV2.services) {
          // <service>_metadata.xml (metadata)
          if (resultV2.services[serviceName].metadata) {
            // This was actually no longer written
            // writeToFileOrDisplay(options.out, serviceName + '_metadata.xml', resultV2.services[serviceName].metadata);
          }
          // <service>_annotations.xml (annotations)
          if (resultV2.services[serviceName].annotations) {
            // This was actually no longer written
            // writeToFileOrDisplay(options.out, serviceName + '_annotations.xml', resultV2.services[serviceName].annotations);
          }
          // <service>.xml (combined)
          if (resultV2.services[serviceName].combined) {
            writeToFileOrDisplay(options.out, serviceName + '.xml', resultV2.services[serviceName].combined);
          }
        }
      }
      // Per-service output files for V4
      for (let serviceName in resultV4.services) {
        // <service>_metadata_v4.xml (metadata)
        if (resultV4.services[serviceName].metadata) {
          // This was actually no longer written
          // writeToFileOrDisplay(options.out, serviceName + '_metadata_v4.xml', resultV4.services[serviceName].metadata);
        }
        // <service>_annotations_v4.xml (annotations)
        if (resultV4.services[serviceName].annotations) {
          // This was actually no longer written
          // writeToFileOrDisplay(options.out, serviceName + '_annotations_v4.xml', resultV4.services[serviceName].annotations);
        }
        // <service>_v4.xml (combined)
        if (resultV4.services[serviceName].combined) {
          writeToFileOrDisplay(options.out, serviceName + '_v4.xml', resultV4.services[serviceName].combined);
        }
        // <service>_v4.json (metadata_json)
        if (resultV4.services[serviceName].metadata_json) {
          writeToFileOrDisplay(options.out, serviceName + '_v4.json', resultV4.services[serviceName].metadata_json);
        }
      }
      // FIXME: The filename 'csn.json' clashes with the plain CSN output
      if (resultV4.csn) {
        displayNamedCsn(resultV4._augmentedCsn, 'csn', options);
      }
    } else {
      // This is what we should do in future - much simpler
      let odataResult = compiler.toOdata(model);
      for (let serviceName in odataResult.services) {
        // <service>_metadata.xml (metadata)
        if (odataResult.services[serviceName].metadata) {
          writeToFileOrDisplay(options.out, serviceName + '_metadata.xml', odataResult.services[serviceName].metadata);
        }
        // <service>_annotations.xml (annotations)
        if (odataResult.services[serviceName].annotations) {
          writeToFileOrDisplay(options.out, serviceName + '_annotations.xml', odataResult.services[serviceName].annotations);
        }
        // <service>.xml (combined)
        if (odataResult.services[serviceName].combined) {
          writeToFileOrDisplay(options.out, serviceName + '.xml', odataResult.services[serviceName].combined);
        }
        // <service>.json (metadata_json)
        if (odataResult.services[serviceName].metadata_json) {
          writeToFileOrDisplay(options.out, serviceName + '.json', odataResult.services[serviceName].metadata_json);
        }
      }
      // odata_csn.json resp. odata_csn_raw.txt
      if (odataResult._augmentedCsn) {
        displayNamedCsn(odataResult._augmentedCsn, 'odata_csn', options);
      }
    }
    return model;
  }

  // Execute the command line option '--to-sql' and display the results.
  // Return the original model (for chaining)
  function toSql( model ) {
    let sqlResult = compiler.toSql(model);
    for (let name in sqlResult.sql) {
      writeToFileOrDisplay(options.out, name + '.sql', sqlResult.sql[name] + '\n', true);
    }
    if (sqlResult.csn) {
      displayNamedCsn(sqlResult._augmentedCsn, 'sql_csn', options);
    }
    return model;
  }

  // Execute the command line option '--to-swagger' and display the results.
  // Return the original model (for chaining)
  function toSwagger( model ) {
    let swaggerResult = compiler.toSwagger(model);
    for (let serviceName in swaggerResult)
      writeToFileOrDisplay(options.out, `${serviceName}_swagger.json`, swaggerResult[serviceName], false);
    return model;
  }

  // Execute the (old) command line option '--tnt-output' and display the results.
  // FIXME: This is the only one that cannot yet be composed from others
  // Return the original model (for chaining)
  function tntOutput( model ) {
    // TODO: use async file-system API
    // Perform TNT-specific post-processing
    let result = compiler.toTntSpecificOutput(model, model.options);
    // Write result to files in target directory
    // FIXME: Check in options which parts actually need to be generated
    // Write annotations.xml and metadata.xml only if there is exactly one service
    // FIXME: For backward compatibility only, should be removed soon
    if (result.annotations && result.metadata) {
      writeToFileOrDisplay(model.options.out, 'annotations.xml', result.annotations);
      writeToFileOrDisplay(model.options.out, 'metadata.xml', result.metadata);
    }
    writeToFileOrDisplay(model.options.out, 'csn.json', result.csn);
    for (let serviceName in result.services) {
      writeToFileOrDisplay(model.options.out, serviceName + '_annotations.xml', result.services[serviceName].annotations);
      writeToFileOrDisplay(model.options.out, serviceName + '_metadata.xml', result.services[serviceName].metadata);
    }
    return model;
  }

  // Display error messages in `err` resulting from a compilation.  Also set
  // process.exitCode - process.exit() will force the process to exit as quickly
  // as possible = is problematic, since console.error() might be asynchronous
  function displayErrors (err) {
    if (options.rawOutput) {
      err.model = reveal( err.model );
      console.error( util.inspect( err, false, null ));
      process.exitCode = 1;
    }
    else if (err instanceof compiler.CompilationError) {
      displayMessages( err.model, err.errors );
      process.exitCode = 1;
    }
    else if (err instanceof compiler.InvocationError) {
      console.error( '' );
      for (let sub of err.errors)
        console.error( sub.message );
      console.error( '' );
      process.exitCode = 2;
    }
    else
      internalError(err);

    err.hasBeenReported = true;
  }

  function displayMessages( model, messages = model.messages ) {
    if (messages instanceof Array)
    {
      for (let msg of messages) {
        if (messageLevels[ msg.severity ] <= options.warning)
          console.error( compiler.messageString( msg, normalizeFilename ) );
      }
    }
    return model;
  }

  // Write the model 'model' to file '<name>.{json|raw.txt}' in directory 'options.out',
  // or display it to stdout if 'options.out' is '-'.
  // Depending on 'options.rawOutput', the model is either compacted to 'name.json' or
  // written in raw form to '<name>_raw.txt'.
  function displayNamedCsn(model, name, options) {
    if (options.rawOutput) {
      writeToFileOrDisplay(options.out, name + '_raw.txt', util.inspect(reveal(model), false, null), true);
    }
    else if (options.newCsn) {
      writeToFileOrDisplay(options.out, name + '.json', compiler.compactModel(model), true);
    }
    else {
      writeToFileOrDisplay(options.out, name + '.json', compiler.compactSortedJson(model), true);
    }
  }

  // Write the result 'content' to a file 'filename' in directory 'dir', except if 'dir' is '-'.
  // In that case, display 'content' to stdout.
  // If 'content' is not a string, JSON-stringify it
  // If displaying to stdout, prepend a headline containing 'filename', unless 'omitHeadline' is set.
  // For filenames, illegal characters (slash, backslash, colon) are replaced by '_'.
  function writeToFileOrDisplay(dir, filename, content, omitHeadline = false) {
    filename = filename.replace(/[:/\\]/g, '_');
    if (!(content instanceof String || typeof content == 'string')) {
      content = JSON.stringify(content, null, 2);
    }
    if (dir == '-') {
      if (!omitHeadline) {
        process.stdout.write(`// ------------------- ${filename} -------------------\n`);
      }
      process.stdout.write(`${content}\n`);
      if (!omitHeadline) {
        process.stdout.write(`\n`);
      }
    } else {
      // TODO: We might consider using async file-system API ...
      fs.writeFileSync(path.join(dir, filename), content);
    }
  }

  function internalError (err) {
    if (err instanceof Error && err.hasBeenReported)
      return;
    console.error( '' );
    console.error( 'INTERNAL ERROR: %s', err );
    console.error( util.inspect(err, false, null) );
    console.error( '' );
    process.exitCode = 70;
  }
}

module.exports = {
  executeCommandLine,
};
