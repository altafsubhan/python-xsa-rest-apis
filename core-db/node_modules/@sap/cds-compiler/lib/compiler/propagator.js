//

'use strict';

const { forEachDefinition, forEachMember, applyLinearly, setProp }
      = require( '../base/model');
var { setMemberParent } = require('./shared');

function propagateLinearly( ...args ) {
  return applyLinearly( 'propagated', ...args );
}

// the export function
function propagateAssignments( model, options = model.options || {} ) {
  const typeProperties = {
    type: null, // propagateType,
    length: null,
    precision: null,
    scale: null,
    items: propagateTypeProperties,
    target: 0,
    implicitForeignKeys: null,
    source: null,
    // default: null,    // see propagateSingle()
    // notNull: null,    // see propagateSingle()
    cardinality: null,
    foreignKeys: propagateDictionary,
    on: null, onCond: 0,     // combine, copy when resolve in ON
    elements: propagateDictionary,
    enum: propagateDictionary,
    localized: null,
    virtual: null,
  };

  forEachDefinition( model, function( def ) {
    // TODO: make exportAnnotations inspect the _finalType instead:
    if (options.toI18n && options.toI18n.style == 'prop') {
      propagateLinearly( def, o => o.type, propagateTypeProperties );
      return;
    }
    if (options.tntFlavor) {
      if (!options.tntFlavor.skipPropagatingFromInclude)
        propagateLinearly( def, includesSource, propagateSingle );
      if (!options.tntFlavor.skipPropagatingFromProjectionSrc)
        propagateLinearly( def, p => p.source, propagateSingle );
    }
    propagateInMembers( def );
  });
  return model;

  function propagateInMembers( def ) {
    forEachMember( def, function( elem ) {
      propagateLinearly( elem, o => o.origin, propagateSingle );
      propagateInMembers( elem );
    });
  }

  // Propagation function.  Used to inherit along properties `origin` (used for
  // members only), and with --tnt-flavor: `source` and `includes[0]`.  The
  // properties are the type properties and annotation assignments.
  function propagateSingle( target, source ) {
    if (target.kind === 'key')
      return;
    propagateTypeProperties( target, source );
    if (target.origin && source === target.origin._artifact) { // along `origin`
      // inherit `default` only along structure includes
      if ('default' in source && !('default' in target)) { //&&
        //  !target.value) {      // from structure includes
        target.default = source.default;
      }
      // inherit `notNull` along select items without association or structure includes
      if ('notNull' in source && !('notNull' in target) &&
          (!target.value || withoutAssociation( target.value.path )) ) {
        target.notNull = source.notNull;
      }
    }

    if (source.params) {
      target.params = propagateDictionary( target.params, source.params, target );
    }
    if (source.returns)
      target.returns = propagateTypeProperties( null, source.returns, target );

    if (options.tntFlavor) {
      if (!options.tntFlavor.skipPropagatingActions)
        propagateActions( target, source );
      // FIXME: very questionable if we really want that
      if (source.includes && !options.tntFlavor.skipPropagatingIncludes) {
        target.includes = source.includes;
      }
    }
    for (let prop in source) {
      if (prop.charAt(0) !== '@' ||
          prop in target ||
          options.tntFlavor && !options.tntFlavor.skipNotPropagatingIndexableAnno && prop === '@com.sap.gtt.core.CoreModel.Indexable')
        continue;
      // TODO: if we decide that annotations have a link to the attached
      // construct, we need to shallow-copy and set this link here, too
      target[prop] = source[prop];
    }
  }

  function withoutAssociation( path ) {
    for (let item of path || []) {
      if (item._artifact && item._artifact._finalType && item._artifact._finalType.target)
        return false;
    }
    return true;
  }

  //function propagateType( target, source )
  function propagateTypeProperties( target, source, parent ) {
    if (!target) {
      target = Object.assign( {}, source );
      // Object.defineProperty( target, '_finalType', { value: source._finalType } );
    }
    if (target.kind === 'key' && // TODO: this should move below !!!!!!!
        ( source.target || source.type && source.type._artifact && !source.type._artifact.builtin ))
      return target;            // do not propagate for foreign keys which are assocs - TODO
    let value = (target.redirected) ? target : (source._finalType || source);
    // Propagated `elements`, `foreignKeys` etc should have a _finalType:
    if (!target._finalType)
      setProp( target, '_finalType', value );

    // TODO: adapt foreign keys with redirect and on condition in general
    if (!parent && !target.redirected) {
      for (let prop in typeProperties) {
        if (prop in target && typeProperties[prop] !== 0) {
          setProp( target, '_finalType', target );
          return target;
        }
      }
    }
    for (let prop in typeProperties) {
      // if (prop === 'foreignKeys') console.log ('FK', source.kind, source.name)
      if (prop in source && !(prop in target)) {
        let transfer = typeProperties[prop];
        target[prop] = (transfer)
          ? transfer( null, source[prop], parent || target )
          : source[prop];
      }
    }
    return target;
  }

  function propagateDictionary( target, source, parent ) {
    if (!target)
      target = Object.create(null);
    for (let name in source) {
      if (name in target)
        continue;
      let src  = source[name];
      let elem = target[name] = Object.assign( {}, src );
      elem.name = Object.assign( {}, src.name );
      // console.log(elem.kind,elem.name)
      setMemberParent( elem, name, parent );
      if (src.returns)          // TODO: what about items?
        elem.returns = propagateTypeProperties( null, src.returns, elem );
      else
        propagateTypeProperties( elem, src, elem );
      if (src.params)          // for actions
        elem.params = propagateDictionary( null, src.params, elem );
    }
    return target;
  }

  function propagateActions( target, source ) {
    if (source.actions) {
      target.actions = propagateDictionary( target.actions, source.actions, target );
    }
  }

  // If we have more than one include later, we need something like applyInOrder
  function includesSource( def ) {
    return def.includes && def.includes.length >= 1 && def.includes[0];
  }
}

module.exports = {
  propagateAssignments
};
