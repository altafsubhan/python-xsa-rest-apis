// Compiler phase "resolve": resolve all references

// The resolve phase tries to find the artifacs (and elements) for all
// references in the augmented CSN.  If there are unresolved references, this
// compiler phase fails with an error containing a vector of corresponding
// messages (alternatively, we could just store this vector in the CSN).

// References are resolved according to the scoping rules of CDS specification.
// That means, the first name of a reference path is not only searched in the
// current environments, but also in the parent environments, with the source
// as second-last, and the environment for builtins as the last search
// environment.

// For all type references, we set the properties `type.absolute` and
// `type._artifact`, the latter is the actual type definition.

// If the referred type definition has a `parameters` property, we use it to
// transform the `typeArguments` property (sibling to the `type` property`) to
// named properties.  See function `resolveTypeArguments` below for details.

// Example 'file.cds' (see './definer.js' for the CSN before "resolve"):
//   type C { elem: String(4); }
//
// The corresponding definition of element "elem" looks as follows:
//   {
//     kind: 'element',
//     name: { id: 'elem', component: 'elem', location: ... }
//     type: { absolute: 'cds.String', _artifact: {...}, path: ...},
//     length: { val: 4, location: <of the number literal> },
//     location: ..., _parent: ...
//   }

// Future sequence (currently, 1 and 3 are mixed):
//  1. Resolve "element building" constructs: calculate main query elements
//  2. Add implicit foreign keys
//  3. Resolve the rest: ON, WHERE, ..., resolve non-FROM subqueries, rewrite
//     associations, ...

'use strict';

const { kindProperties, queryOps, setProp, forEachDefinition, forEachMember, forEachGeneric, forEachInOrder }
      = require('../base/model');
var { addToDict, addToDictWithIndexNo, clearDict, dictLocation }
    = require('../base/dictionaries');
// const { refString } = require('../base/messages');

var detectCycles = require('./cycle-detector');
const layers = require('./moduleLayers');

var { fns, linkToOrigin, setMemberParent, navigatesAlongAssoc, storeExtension }
    = require('./shared');

const undefinedArtifact = { kind: 'undefined', name: { absolute: ".<unknown>." } };

const annotationPriorities = { define: 1, extend: 2, annotate: 2, edmx: 3, i18n: 4 };


// Export function of this file.  Resolve type references in augmented CSN
// `model`.  If the model has a property argument `messages`, do not throw
// exception in case of an error, but push the corresponding error object to
// that property (should be a vector).
function resolve( model, options = model.options || {} ) {
  // Get shared "resolve" functionality and the message function:
  const { resolvePath, defineAnnotations, error, warning, message }
        = fns( model, environment );
  // --- sub phase 1: check paths in usings ---
  for (let name in model.sources) {
    let source = model.sources[name];
    resolveUsings( source.usings );
  }
  // --- sub phase 2: calculate/init view elements ---
  forEachDefinition( model, resolveView );
  // resolve all artifacts:
  var implicitForeignKeys = [];
  forEachDefinition( model, resolveRefs );
  // adding implicit keys must be delayed due to projections (elements are calculated later)
  implicitForeignKeys.forEach( addImplicitForeignKeys );

  detectCycles( model.definitions, function( art, location ) {
    if (location) {
      let name = art.name;
      let compact = '';
      if (name.action)
        compact = '.$action.' + name.action;
      if (name.param)
        compact += '.$param.' + name.param;
      if (name.element)
        compact += (compact ? '.' : '..') + name.element;
      message( `Illegal circular reference to "${name.absolute + compact}"`,
               location );
    }
  } );

  if (model.extensions)
    model.extensions.map( annotateUnknown );
  return model;

  // Resolve all references in artifact or element `art`.  Do so recursively in
  // all sub elements.
  function resolveRefs( art ) {
    // console.log( 'RESOLVE:', art.kind, refString(art.name) );
    if (!art._deps)
      setProp( art, '_deps', [] );
    if (art.$tableAliases && !art._$next) // TODO: in definer - yes, with param support
      setProp( art, '_$next', model.$magicVariables );
    if (art.key && !art.key.$inferred && art._parent &&
        !['entity', 'view', 'query'].includes( art._parent.kind ))
      message( `KEY is only supported for elements in an entity or view`,
               art.key.location, 'Warning' );

    let thing = art.returns || art;
    let obj = thing.items || thing; // the object which has type properties
    //console.log(art.name, art._block, obj)
    if (obj.type)
      resolveTypeArguments(
        resolveType( obj.type, art, art._block ), obj );
    if (obj.target) {
      resolvePath( obj.target, 'target', art, art._block );
      if (obj.onCond) {
        if (!art._parent || !art._parent.elements) {
          message( `No unmanaged association can be defined here`, obj.onCond.location );
        }
        else { // TODO: when used for mixin def: use query.$combined (currently extra)
          // TODO: provide "expected" special for on condition of association
          resolveExpr( obj.onCond, 'expr', art, art._main, environment( art._parent ), art._block );
        }
      }
      else if (!obj.foreignKeys && !obj.redirected && obj.target._artifact)
        implicitForeignKeys.push( art );
    }
    if (art.targetElement) {    // in foreign keys
      let target = art._parent && art._parent.target;
      if (target && target._artifact) {
        // we just look in target for the path
        // TODO: also check that we do not follow associations?
        resolvePath( art.targetElement, 'element', art, {}, environment( target._artifact ) );
      }
    }
    // Resolve projections/views
    if (art.$from)
      resolveView( art );
    if (obj.type || obj.origin || obj.value && obj.value.path || obj.elements) // typed artifacts
      finalType(obj);  // set _finalType if appropriate, (future?): copy elems if extended
    if (thing.items)
      setProp( thing, '_finalType', thing );

    if (obj.elements)           // silent dependencies
      forEachGeneric( obj, 'elements', elem => { art._deps.push( { art: elem } ) } );
    if (obj.foreignKeys)        // silent dependencies
      forEachGeneric( obj, 'foreignKeys', elem => { art._deps.push( { art: elem } ) } );

    annotateMembers( art );
    for (let prop in art) {
      if (prop.charAt(0) === '@')
        chooseAssignment( prop, art );
    }

    resolveTechnicalConfig( art );

    forEachMember( art, resolveRefs );
  }

  function annotateUnknown ( ext ) {
    if (ext.$extension)         // extension for known artifact -> already applied
      return;
    annotateMembers( ext );
    for (let prop in ext) {
      if (prop.charAt(0) === '@')
        chooseAssignment( prop, ext );
    }
  }

  // resolve all paths inside a technical configuration
  function resolveTechnicalConfig( art ) {
    // user required? works only with extDict = art.elements is that so?
    let tc = art.technicalConfig;
    if (!tc)
      return;

    // secondary and fulltext indexes
    forEachGeneric( tc, 'indexes', (index) => {
      index.columns.forEach( col => {
        resolvePath( col, 'element', undefined, {}, art.elements );
      });
      if (index.language)
        resolvePath( index.language.column, 'element', undefined, {}, art.elements );
      resolvePath( index.mimeTypeColumn, 'element', undefined, {}, art.elements );
    });
    // fuzzy indexes
    if (tc.fzindexes)
      tc.fzindexes.forEach( i => {
        i.columns.forEach(c => {
          resolvePath( c, 'element', undefined, {}, art.elements )
        });
      });
    // partition expressions
    if (tc.partition) {
      tc.partition.specs.forEach( s => {
        s.columns && s.columns.forEach( p => {
          resolvePath( p, 'element', undefined, {}, art.elements)
        })
      })
    }
  }

  // Return effective search environment provided by artifact `art`, i.e. the
  // `artifacts` or `elements` dictionary.  For the latter, follow the `type`
  // chain and resolve the association `target`.
  function environment( art ) {
    if (!art)
      return Object.create(null);
    if (art.artifacts)
      return art.artifacts;
    let type = finalType(art);
    if (type.target)
      type = resolvePath( type.target, 'target', type, type._block ) || {};
    if (type.$from)
      resolveView( type, true );
    return type.elements || Object.create(null);
  }

  function directType( art ) {
    // only used with !art.target && !art.enum ! (and !art.elements)
    if (art.origin)
      return art.origin._artifact;
    if (art.type)
      return resolveType( art.type, art, art._block );
    // console.log( 'EXPR-IN', art.kind, refString(art.name) )
    let query = art._parent && art._parent._leadingQuery || art._parent;
    // console.log( 'EXPR-QUERY', query.kind, refString(query.name) )
    if (query && query.kind === 'query') {
      resolveExpr( art.value, 'expr', art, query, query.$combined, art._block );
      // console.log( 'EXPR-OUT', art.value._artifact.kind, refString(art.value._artifact.name) );
      return art.value._artifact;
    }
    // TODO: calculated fields in general, inline select item def (expand)
    return undefined;
  }

  // Follow the `type` chain, i.e. derived types and TYPE OF, stop just before
  // built-in types (otherwise, we would loose type parameters).  Return that
  // type and set it as property `_finalType` on all artifacts on the chain.
  function finalType( art ) {
    // TODO: resolvePath( origin ) should be part of this
    if (art._finalType)
      return art._finalType;

    var chain = [];
    while (art && !art._finalType && (art.type || art.origin || art.value && art.value.path) && !art.target && !art.enum) {
      chain.push( art );
      setProp( art, '_finalType', undefinedArtifact ); // initial setting in case of cycles
      art = directType( art );
    }
    if (!art || art._finalType === undefinedArtifact)
      return undefinedArtifact; // undefined or in cycle

    if (art.builtin && chain.length) {
      let builtin = art;
      art = chain.pop();
      if (art.length || art.precision || art.scale || art.typeArguments) // TODO: move to above like art.target
        setProp( art, '_finalType', art );
      else {
        setProp( art, '_finalType', builtin );
        art = builtin;
      }
    }
    else if (art._finalType) {
      art = art._finalType;
    }
    else {
      setProp( art, '_finalType', art );
    }
    for (let a of chain) {
      // TODO: we had (git tag 'nr-hana') an auto expansion of referred
      // structure types if there existed an annotation assignment for elements
      // of that referred type.  This is not such a good idea since later
      // annotation would not have this effect.  It is better to provide an
      // compiler option --expand-structures which would always expand referred
      // structure types.
      setProp( a, '_finalType', art );
    }
    return art;
  }

  function extensionFor( art ) {
    if (art.kind === 'annotate')
      return art;
    if (art._extension)
      return art._extension;

    // $extension means: already applied
    let ext = { kind: art.kind, name: {}, $extension: 'exists' }; // set kind for setMemberParent()
    if (!art._main) {
      ext.name.absolute = art.name.absolute;
      model.extensions ? model.extensions.push(ext) : model.extensions = [ext];
    }
    else {
      ext.name.id = art.name.id;
      let parent = extensionFor( art._parent );
      let kind = kindProperties[ art.kind ].normalized || art.kind;
      if ( parent[ kindProperties[ kind ].dict ] &&
           parent[ kindProperties[ kind ].dict ][art.name.id] )
        throw new Error(art.name.id);
      setMemberParent( ext, art.name.id, parent, kindProperties[ kind ].dict );
    }
    ext.kind = 'annotate';    // after setMemberParent()!
    setProp( art, '_extension', ext );
    return ext;
  }

  function annotateMembers( art, extensions = [], prop, name, parent, kind ) {
    let severity = !art && parent && parent.kind !== 'annotate' &&
        (art === null ? 'Error' : 'Info');
    if (!art && extensions.length && severity !== 'Error') {
      let parentExt = extensionFor(parent);
      art = parentExt[prop] && parentExt[prop][name];
      if (!art) {
        art = { kind, name: { id: name } }; // set kind for setMemberParent()
        setMemberParent( art, name, extensionFor(parent), prop );
        art.kind = 'annotate';  // after setMemberParent()!
      }
    }

    for (let ext of extensions) {
      if ('_artifact' in ext.name) // already applied
        continue;
      setProp( ext.name, '_artifact', art );

      if (art) {
        defineAnnotations( ext, art, ext._block, ext.kind );
        forEachMember( ext, function init( elem, name, prop ) {
          storeExtension ( elem, name, prop, art, ext._block );
        });
      }
      if (severity) {
        // TODO: use some more generic resolveMember() function
        // TODO: message more like `"${parent.name.absolute}" cannot have elements`
        if (prop === 'elements' || prop === 'enum')
          message( art === null
                   ? `No elements or enums have been found in "${parent.name.absolute}"`
                   : (parent.elements)
                   ? `Element "${name}" has not been found in "${parent.name.absolute}"`
                   : `Enum symbol "${name}" has not been found in "${parent.name.absolute}"`,
                   ext.name.location, severity );
        else if (prop === 'actions')
          message( art === null
                   ? `No action has been found in "${parent.name.absolute}"`
                   : `Action "${name}" has not been found in "${parent.name.absolute}"`,
                   ext.name.location, severity );
        else
          message( art === null
                   ? `No parameter has been found in "${parent.name.absolute}"`
                   : `Parameter "${name}" has not been found in "${parent.name.absolute}"`,
                   ext.name.location, severity );
      }
    }
    if (art) {
      let obj = art.returns || art; // why the extra `returns` for actions?
      obj = obj.items || obj;
      annotate( obj, 'element', 'elements', 'enum', art );
      annotate( art, 'action', 'actions' );
      //annotate( art, 'enum' );  // TODO: still necessary?
      annotate( art, 'param', 'params' );
    }
    return;

    function annotate( obj, kind, prop, altProp, parent = obj ) {
      let dict = art._annotate && art._annotate[prop];
      let env = obj[prop] || altProp && obj[altProp] || null;
      for (let name in dict) {
        annotateMembers( env && env[name], dict[name], prop, name, parent, kind );
      }
    }
  }

  function chooseAssignment( annoName, art ) {
    // TODO: getPath an all names
    let anno = art[annoName];
    if (!(anno instanceof Array)) // just one assignment -> use it
      return;
    // sort assignment according to layer
    let layerAnnos = Object.create(null);
    for (let a of anno) {
      let layer = layers.layer( a._block );
      let name = (layer) ? layer.realname : '';
      let done = layerAnnos[name];
      if (done)
        done.annos.push( a );
      else
        layerAnnos[name] = { layer, annos: [a] };
    }
    // collect assignments of upper layers (are in no _layerExtends)
    let exts = Object.keys( layerAnnos ).map( layerExtends );
    let allExtends = Object.assign( Object.create(null), ...exts );
    let collected = [];
    for (let name in layerAnnos) {
      if (!(name in allExtends))
        collected.push( prioritizedAnnos( layerAnnos[name].annos ) );
    }
    // inspect collected assignments - choose the one or signal error
    let justOnePerLayer = collected.every( annos => annos.length === 1);
    if (justOnePerLayer && collected.length === 1) {
      art[annoName] = collected[0][0];
    }
    else {
      for (let annos of collected) {
        for (let a of annos ) {
          let loc = a.name.location;
          if (justOnePerLayer)  // we could add USING...FROM between these layers
            message( `Duplicate assignment with "${annoName} in unrelated layers"`, loc );
          else
            message( `Duplicate assignment with "${annoName}"`, loc );
        }
      }
    }
    return;

    function layerExtends( name ) {
      let layer = layerAnnos[name].layer;
      return layer && layer._layerExtends;
    }
  }

  function prioritizedAnnos( annos ) {
    let prio = 0;
    let r = [];
    for (let a of annos) {
      let p = annotationPriorities[ a.priority ] || annotationPriorities[ 'define' ] ;
      if (p === prio)
        r.push(a);
      else if (p > prio)
        r = [a], prio = p;
    }
    return r;
  }

  // Resolve the type arguments provided with a type referenced for artifact or
  // element `art`.  This function does nothing if the referred type `typeArt`
  // does not have a `parameters` property (currently, only builtin-types have
  // it, see ./builtins.js).
  //
  // For each property name `<prop>` in `typeArt.parameters`, we move a number
  // in art.typeArguments (a vector of numbers with locations) to `art.<prop>`.
  function resolveTypeArguments( typeArt, art ) {
    if (!typeArt || !typeArt.parameters)
      return;
    var args = art.typeArguments || [];
    var parLength = typeArt.parameters.length;

    for (let i = 0; i < parLength; ++i) {
      let par = typeArt.parameters[i];
      if (!(par instanceof Object))
        par = { name: par };
      art[ par.name ] = art[ par.name ] // from augmented CSN
        || args[i]
        || par.literal && { literal: par.literal, val: par.val };
    }
    if (args.length > parLength)
      art.typeArguments = art.typeArguments.slice(parLength);
    else if (art.typeArguments)
      delete art.typeArguments;
  }

  function addImplicitForeignKeys( art ) {
    let obj = art;
    // TODO: currently assumes obj === art (array of association to ... does not exist)
    let target = obj.target._artifact;
    if (!target)                // no valid target
      return;
    forEachInOrder( target, 'elements', function( elem, name ) {
      if (elem.key) {
        let location = obj.target.location;
        let key = {
          name: { location, id: elem.name.id }, // more by setMemberParent()
          kind: 'key',
          targetElement: { path: [{ id: elem.name.id, location }], location },
          location,
          calculated: true,
          $inferred: true
        };
        setMemberParent( key, name, art, 'foreignKeys' );
        setProp( key.targetElement, '_artifact', elem );
        setProp( key.targetElement.path[0], '_artifact', elem );
        setProp( key, '_finalType', finalType(elem) );
        setProp( key, '_deps', [{ art: elem, location }] );
        art._deps.push( { art: key } );
      }
    });
    art.implicitForeignKeys = true;
  }

  function resolveView( art, onlyInit ) {
    if (!art.$from)
      return;
    var resolveChain = [];
    var fromChain = [art];
    while (fromChain.length) {
      let view = fromChain.pop();
      if (view._status === '_query') // already fully resolved (status at def)
        continue;
      resolveChain.push( view );
      for (let from of view.$from) {
        if (from._status)       // status at the ref -> illegal recursion -> stop
          continue;
        setProp( from, '_status', '_query' );
        let source = resolvePath( from, 'from', view, view._block );
        if (source && source.$from && source._status !== '_query')
          fromChain.push( source );
      }
    }
    for (let view of resolveChain.reverse()) {
      if (view._status === '_query' ) // already resolved
        continue;
      setProp( view, '_status', '_query' );
      // TODO $parameters: params (before $magicVariables)
      resolveQueryExpr( view.query, onlyInit || view !== art );
    }
    if (!resolveChain.length && !onlyInit)
      resolveQueryExpr( art.query );
  }

  function resolveQueryExpr( query, onlyInit ) {
    while (query instanceof Array) // query in parentheses
      query = query[0];
    if (!query)
      return;
    if (query.join) {
      for (let tab of query.args)
        resolveQueryExpr( tab, onlyInit );
      if (!onlyInit && query.on)
        resolveQuery( query, onlyInit );
    }
    else if (query.op && query.op.val === 'query') { // select
      for (let tab of query.from)
        resolveQueryExpr( tab, onlyInit );
      resolveQuery( query, onlyInit );
    }
    else if (query.args) {      // UNION, INTERSECT, ..., sub query
      for (let tab of query.args)
        resolveQueryExpr( tab, onlyInit );
    }
    // else: with parse error (`select from <EOF>`)
  }

  function resolveQuery( query, onlyInit ) {
    if (!query._$next)
      setProp( query, '_$next', model.$magicVariables );
    if (!query.$combined) {     // not already called with onlyInit
      query.$combined = Object.create(null);
      forEachGeneric( query, '$tableAliases', resolveTabRef);
      if (query.all)
        expandWildcard();
      forEachGeneric( { elements: query.elements }, 'elements', initElem );
    }
    if (onlyInit)
      return;

    forEachGeneric( query, '$tableAliases', resolveMixin);
    // A special order-by dictionary is only necessary if SELECT … ORDER BY, not … UNION … ORDER BY
    var dictOB = query.orderBy && Object.create(null);
    // TODO: name resolution for types etc in MIXIN definitions of subqueries?
    forEachGeneric( { elements: query.elements }, 'elements', resolveElem );
    if (dictOB)
      query.$dictOrderBy = Object.assign( Object.create(null), query.$combined, dictOB );
    if (query.on)
      resolveExpr( query.on, 'expr', null, query, query.$combined, query._block );
    if (query.where)
      resolveExpr( query.where, 'expr', null, query, query.$combined, query._block );
    if (query.groupBy) {
      for (let gb of query.groupBy)
        resolveExpr( gb, 'expr', null, query, query.$combined, query._block );
    }
    resolveExpr( query.having, 'expr', null, query, query.$combined, query._block );
    resolveOrderBy();
    return;

    function initElem( elem ) {
      // TODO: make sure that EXTEND ENTITY cannot be used on view (only ad-hoc mixin)
      if (elem.viaAll || elem.type && !elem.type.$inferred || !elem.value || !elem.value.path)
        return;
      let origin = resolvePath( elem.value, 'expr', undefined,
                                query, query.$combined, elem._block );
      if (!origin)
        return;
      elem.origin = elem.value; // TODO: remove origin, make it a _origin = origin._artifact
      // now set things which are necessary for later sub phases:
      let pathnav = pathNavigation( elem.value ).element; // undefined for CURRENT_DATE
      if (!elem.key && pathnav && pathnav.key && !navigatesAlongAssoc( elem.value ))
        elem.key = Object.assign( { $inferred: 'query' }, origin.key );
      addProjection( elem, pathNavigation( elem.value ).element );
    }

    function resolveElem( elem, name ) {
      rewriteAssociation( elem );
      if (elem.viaAll)
        return;
      if (dictOB)               // TODO: do NOT use "competing" aliases from extension (or complain about them)
        addToDict( dictOB, name, elem );
      elem.$inferred = 'query';
      // ony direct paths have been resolved so far (w/o explicit type), no expression:
      resolveExpr( elem.value, 'expr', elem, query, query.$combined, elem._block );
      let origin = elem.value && elem.value._artifact;
      if (origin) // TODO: remove this test - currently for edm/transformModel.js
        finalType( elem );
    }

    function rewriteAssociation( elem ) {
      if (!options.betaMode && !options.newCsn)
        return;
      let assoc = elem.origin && elem.origin._artifact;
      if (!assoc || !finalType(assoc))
        return;                 // no direct path
      if (!assoc._finalType.target || !assoc._finalType.onCond)
        // no unmanaged association (later we need to check wheter it is a
        // struct containing an assoc = reject those, and also check managed
        // associations with redirected target)
        return;
      let pathnav = pathNavigation( elem.value );
      // console.log( 'ASSOC:', elem.value, pathnav )
      let nav = pathnav.element;
      if (!nav)                 // $projection, $magic, or future ref to const
        return;
      // Currently, having an unmanaged association inside a struct is not
      // supported by this function:
      if (nav !== assoc && nav.origin._artifact !== assoc) {
        // Currently no warning, as this is also true for "assoc1.assoc2",
        // warning only for "otherelem1.assoc2"
        // message( warning`Rewriting associations in a structure is not supported`, elem.value.location );
        return;
      }
      let target = elem.target && !elem.target.$inferred &&
          resolvePath( elem.target, 'target', elem, elem._block );
      if (target) {
        let from = target.query && target.query.from; // query entity (no assoc)
        // simple (no UNION), no JOINs, no subquery in FROM:
        target = from && from.length === 1 && from[0].path && from[0]._tableAlias;
        if (!target) {
          message( error`Redirected target is no simple projection`,
                   elem.target.location );
          return;
        }
        else if (assoc._finalType.target._artifact !== from[0]._artifact) {
          message( warning`The source of the redirected target is not the original target`,
                   elem.target.location );
          return;
        }
        // TODO: we might allow the following in the future
        //  - original target is just the indirect source of the new target
        //  
      }
      let cond = copyExpr( assoc._finalType.onCond );
      if (!pathnav.tableAlias)  // mixin
        resolveExpr( cond, rewriteExpr );
      else if (pathnav.tableAlias.type)
        resolveExpr( cond, rewriteExpr, elem, pathnav.tableAlias );
      else {
        // If we want to support that: make sure that ON condition of sub query
        // already had been rewritten
        message( error`Selecting unmanaged associations from a sub query is not supported`,
                 elem.value.location );
      }
      cond.$inferred = 'rewrite';
      elem.onCond = cond;
      if (!elem.target)
        elem.target = Object.assign( { $inferred: 'rewrite' }, assoc._finalType.target );
      setProp( elem, '_finalType', elem );
      // TODO: info message with more than one possibility
    }

    function addProjection( proj, nav ) {
      // TODO: do not conside origin if KEY property has changed
      if (nav) {
        if (nav._projections)
          nav._projections.push( proj )
        else
          setProp( nav, '_projections', [proj] );
      }
    }

    function expandWildcard() {
      let elements = Object.assign( Object.create(null), query.elements );
      clearDict( query, 'elements', true );
      let exclude = query.exclude || Object.create(null);
      // TODO: paths in exclude? - Did I mention it? EXCLUDING is ill-defined...
      let location = query.all.location;
      for (let name in query.$combined) {
        let navElem = query.$combined[name];
        if (exclude[name] || navElem.masked)
          continue;
        let selElem = elements[name];
        if (selElem && selElem.name) { // no name with parse error or repeated def
          if (!selElem.redirected &&
              (!model.options.tntFlavor || model.options.tntFlavor.skipDuplicatesInProjections)) {
            message( (navElem instanceof Array)
                     ? `This select item replaces "${name}" from two or more sources`
                     : `This select item replaces the source element "${navElem._parent.name.id}.${name}"`,
                     selElem.name.location, 'Info' );
          }
          selElem.$replacement = true;
          addToDictWithIndexNo( query, 'elements', name, selElem );
        }
        else if (navElem instanceof Array) {
          message( `Ambiguous, select "${ name }" explicitly with table alias`, location );
        }
        else {
          let origin = navElem.origin._artifact;
          let elem = linkToOrigin( origin, name, query, 'elements', location );
          elem.$inferred = '*';
          elem.name.calculated = true;
          let aliasObj = navElem._parent;
          let aliasStep = { id: aliasObj.name.id, location };
          let step = { id: name, location };
          elem.value = elem.origin;
          // always expand * to path with table alias (reason: columns current_date etc)
          elem.value.path = [ aliasStep, step ];
          let real = aliasObj.origin || aliasObj.type; // is undefined for sub query
          setProp( aliasStep, '_artifact', real && real._artifact || aliasObj );
          setProp( aliasStep, '_navigation', aliasObj );
          setProp( step, '_artifact', origin );
          setProp( step, '_navigation', navElem ); // TODO: really set this?
          addProjection( elem, navElem );
          elem.viaAll = true;
          if (origin.key && aliasObj === aliasObj._parent._firstAliasInFrom)
            elem.key = origin.key;
          // TODO: _finalType?
        }
      }
      forEachInOrder( { elements }, 'elements', function (elem, name) {
        if (!elem.$replacement)
          addToDictWithIndexNo( query, 'elements', name, elem );
      });
    }

    // Note the strange name resolution (dynamic part) for ORDER BY: the same
    // as for select items if it is an expression, but first look at select
    // item alias (i.e. like `$projection.NAME` if it is a path.  If it is an
    // ORDER BY of an UNION, do not allow any dynamic path in an expression,
    // and only allow the eements of the leading query if it is a path.
    //
    // This seem to be similar, but different in SQLite 3.22.0: ORDER BY seems
    // to bind stronger than UNION (see <SQLite>/src/parse.y), and the name
    // resolution seems to use select item aliases from all SELECTs of the
    // UNION (see <SQLite>/test/tkt2822.test).
    function resolveOrderBy() {
      if (query.$orderBy || query.orderBy) {
        let leading = query._leadingQuery || query; // TODO: query is always the leading here
        let emptyDict = Object.create(null);
        // TOOD: handle query.orderBy and query.$orderBy extra - then we have no need for _$queryNode
        for (let ob of [...query.$orderBy||[], ...query.orderBy||[] ]) {
          resolveExpr( ob.value, 'expr', null, leading,
                       (ob.value && ob.value.path)
                       ? (ob._$queryNode ? leading.elements : leading.$dictOrderBy)
                       : (ob._$queryNode ? emptyDict : leading.$combined ),
                       leading._block );
        }
      }
    }

    function resolveMixin( alias ) {
      if (alias.kind === 'element') { // TODO: use resolveRefs( alias ), but beware $self
        let main = query._main;
        if (alias.type)
          resolveTypeArguments(
            resolvePath( alias.type, 'type', main, main._block ), alias );
        if (alias.target) {
          resolvePath( alias.target, 'target', main, main._block );
          // TODO: disallow foreign keys, resolve ON, but but beware $self
          if (alias.onCond)
            resolveExpr( alias.onCond, 'expr', alias, query, query.$combined, main._block );
          else
            message( `Managed associations are not allowed here`, alias.target.location );
        }
      }
      // TODO: handle MIXIN defs which look like name = value
    }

    function resolveTabRef( alias ) {
      if (alias.kind === 'element' || alias.self) // mixin element or $projection
        return;
      if (!alias.$navigation) {
        let tab = resolvePath( alias.type, 'from', query._main._block, query._main );
        for (let step of tab && alias.type.path || []) {
          if (!step._artifact)
            break;
          if (step.namedArgs)
            resolveParams( step.namedArgs, step._artifact, query._main._block ); // block for future :const
          if (step.filter)    // TODO: support for $projection, $parameters, ...?
            resolveExpr( step.filter, 'expr', null, {}, environment( step._artifact ), query._main._block );
        }
        let isPrimaryAlias = alias === alias._parent._firstAliasInFrom;
        let elements = alias.elements || environment(tab); // sub query or table ref
        forEachGeneric( { elements }, 'elements', function( origin, name ) {
          let elem = linkToOrigin( origin, name, alias, '$navigation',
                                   (tab||origin).name.location );
          elem.kind = '$navElement';
          // setProp( elem, '_fromAlias', alias );  same as _parent
          setProp( elem, '_finalType', finalType(origin) );
          // elem.name.query = query.name.query; 
          if (origin.key && isPrimaryAlias)
            elem.key = origin.key;
          if (origin.masked)
            elem.masked = origin.masked;
        });
      }
      forEachGeneric( { elements: alias.$navigation }, 'elements', function( elem, name ) {
        addToDict( query.$combined, name, elem );
      });
    }
  }

  // Resolve the using declarations in `using`.  If not compiled with lint-mode
  // or if it is a reference for a builtin (path starts with `cds`), issue
  // error message if the referenced artifact does not exist.
  function resolveUsings( usings ) {
    if (!usings)
      return;
    for (let def of usings) {
      let art = model.definitions[ def.name.absolute ];
      if (art instanceof Array)
        continue;
      let location = def.extern.location;
      setProp( def, '_deps', (art) ? [{ art, location }] : [] );
      if (!art &&
          (!model.options || !model.options.lintMode ||
           def.extern.path && def.extern.path[0] && def.extern.path[0].id == 'cds')) {
          // even with lint-mode, we complain about undefined "cds.*"
        message( error`Artifact '${def.name.absolute}' has not been found`, location );
      }
    }
  }

  function rewriteExpr( expr, user, tableAlias ) {
    let pathnav = (tableAlias)
                ? sourceNavigation( expr, tableAlias ) // in ON of query source element
                : pathNavigation( expr );              // in ON of mixin element
    let nav = pathnav.element;
    if (!nav) {
      if (!pathnav.item)        // $projection (only from mixin)
        return;
      if (expr.path.length > 1 && expr.path[1].id.charAt(0) !== '$') {
        // some backends have problems with $self -> delete it if unnecessary
        expr.path.shift();
      }
      else {
        pathnav.item.id = '$self';
        delete pathnav.item._navigation;
      }
      return;
    }
    // console.log( 'REWRITE: ', expr.path )
    if (!nav._projections) {
      message( error`Projected association uses non-projected element "${nav.name.id}"`,
               user && user.value && user.value.location || pathnav.item.location );
      return;
    }
    let elem = nav._projections[0]; // TODO: info with more than one
    let step = pathnav.item;
    step.id = elem.name.id;
    setProp( step, '_artifact', elem );
    let root = expr.path[0];
    if (root !== step) {        // we have used tabAlias.elem, $self/$projection.elem
      if (step.id.charAt(0) !== '$') {
        // some backends have problems with $self -> delete it if unnecessary
        expr.path.shift();
      }
      else {
        root.id = '$self';
        setProp( root, '_artifact', pathnav.tableAlias._parent ); // set to query
        delete pathnav.item._navigation;
      }
    }
  }

  function pathNavigation( ref ) {
     // currently, indirectly projectable elements are not included - we might
    // keep it this way!  If we want them to be included - be aware: cycles
    let item = ref.path && ref.path[0];
    let root = item && item._navigation;
    if (!root)
      return {};
    if (root.kind === '$navElement')
      return { element: root, item, tableAlias: root._parent };
    if (root.name.$mixin)
      return { element: root, item };
    if (root.self)
      return { item };
    if (root.kind !== '$tableAlias' || ref.path.length < 2)
      return {};
    item = ref.path[1];
    return { element: root.$navigation[ item.id ], item, tableAlias: root };
  }

  function sourceNavigation( ref, tableAlias ) {
    let item = ref.path && ref.path[0];
    let root = item && item._artifact;
    if (!root)
      return {};
    let source = tableAlias.type && tableAlias.type._artifact;
    if (root._parent === source) // element of query
      return { element: tableAlias.$navigation[ item.id ], item, tableAlias };
    if (root !== source)        // not $projection
      return {};
    item = ref.path[1];
    return { element: tableAlias.$navigation[ item.id ], item, tableAlias };
  }

  function resolveExpr( expr, expected, user, env, extDict, block ) {
    if (!expr || typeof expr === 'string') // parse error or keywords in {xpr:...}
      return;
    if (expr instanceof Array)
      expr.forEach( e => resolveExpr( e, expected, user, env, extDict, block ) );
    else if (expr.path) {
      if (expected instanceof Function) {
        expected( expr, user, env, extDict, block );
        return;
      }
      // TODO: user!!!, TODO: block for constant and parameter access!
      resolvePath( expr, 'expr', undefined, env, extDict ); // TODO: user!!!
      // TODO: put the following in resolvePath (extra arg if allowed)?
      for (let step of expr.path) {
        if (!step._artifact)
          break;
        if (step.namedArgs)
          resolveParams( step.namedArgs, step._artifact, block ); // block for future :const
        if (step.filter)    // TODO: support for $projection, $parameters, ...?
          resolveExpr( step.filter, 'expr', null, {}, environment( step._artifact ), block );
      }
    }
    else if (expr.op && queryOps[ expr.op.val ]) {
      // TODO: is that enough or should we make sure to resolve them in reverse order?
      if (expr.kind || expr._leadingQuery) // UNION has _leadingQuery
        resolveQueryExpr( expr );
      else
        message( `Subqueries are not supported here`, expr.location );
    }
    else if (expr.op && expr.args) {
      let func = expr.func && expr.func.path && expr.func.path[0].id;
      if (func && func.toUpperCase() === 'ROUND') // TODO: temp?
        resolveExpr( expr.args[0], expected, user, env, extDict, block )
      else
        expr.args.forEach( e => resolveExpr( e, expected, user, env, extDict, block ) );
    }
  }

  // eslint-disable-next-line no-unused-vars
  function resolveParams( dict, art, block ) { // TODO: block for :param or :const
    let type = finalType( art );
    if (type.target) {
      art = type.target._artifact;
      if (!art)                 // association with undefined target
        return;
    }
    if (!art.params) {
      let first = dict[ Object.keys(dict)[0] ];
      if (first instanceof Array)
        first = first[0];
      message( error`Artifact '${art.name.absolute}' has no parameters`,
               dictLocation( dict, first && first.name && first.name.location ) );
      return;
    }
    for (let name in dict) {
      let param = art.params[name];
      let arg = dict[name];
      for (let a of (arg instanceof Array) ? arg : [arg]) {
        setProp( a.name, '_artifact', param );
        if (!param)
          message( error`Artifact '${art.name.absolute}' has no parameter '${name}'`,
                   a.name.location );
        resolveExpr( a, 'expr', null, {} ); // only param and const, TODO: block
      }
    }
  }

  function resolveType( ref, user, block ) {
    if (!ref.resolveSemantics)
      return resolvePath( ref, 'type', user, block );
    // currently just `typeOf`
    if (options.hanaFlavor && ref.path.length > 1)
      return resolvePath( ref, 'type', user, block );
    else if (user._parent && user._parent.elements)
      return resolvePath( ref, 'typeOf', user, user._main, user._parent.elements );
    message( `No elements can be accessed from here`, ref.location );
    return undefined;
  }
}

function copyExpr( expr ) {
  if (!expr || typeof expr !== 'object')
    return expr;
  else if (expr instanceof Array)
    return expr.map( copyExpr );

  let proto = Object.getPrototypeOf( expr );
  if (proto && proto !== Object.prototype) // do not copy object from special classes
    return expr;
  let r = Object.create( proto );
  if (proto && expr.op && queryOps[ expr.op.val ])
    return [];                  // copy/rewrite with sub query is not supported

  // let exprPds = Object.getOwnPropertyDescriptors( expr ); // just Node-8, not Node-6
  // for (let prop in exprPds) {
  //   let pd = exprPds[ prop ];
  for (let prop of Object.getOwnPropertyNames( expr )) {
    let pd = Object.getOwnPropertyDescriptor( expr, prop );
    if (!pd.enumerable || !pd.value) // should include all properties starting with _
      Object.defineProperty( r, prop, pd );
    else if (!proto || prop.charAt() !== '$' && prop !== 'location')
      r[prop] = copyExpr( pd.value );
    else
      Object.defineProperty( r, prop, pd );
  }
  return r;
}

module.exports = resolve;
