// Functions and classes for syntax messages

'use strict';

function hasErrors( messages ) {
  return messages && messages.some( m => m.severity === 'Error' );
}

// Return gnu-style error string for location `loc`:
//  - 'File:Line:Col' without `loc.end`
//  - 'File:Line:StartCol-EndCol' if Line = start.line = end.line
//  - 'File:StartLine.StartCol-EndLine.EndCol' otherwise
function locationString( loc, normalizeFilename ) {
  if (!loc)
    return '<???>';
  let filename = (loc.filename && (normalizeFilename || normalizeFilename === 0))
      ? loc.filename.replace( /\\/g, '/' )
      : loc.filename;
  if (!(loc instanceof Object) || !loc.start)
    return loc;
  return (!loc.end)
    ? `${filename}:${loc.start.line}:${loc.start.column}`
    : (loc.start.line == loc.end.line)
    ? `${filename}:${loc.start.line}:${loc.start.column}-${loc.end.column}`
    : `${filename}:${loc.start.line}.${loc.start.column}-${loc.end.line}.${loc.end.column}`;
}

// Class for combined compiler errors.  Additional members:
//  `errors`: vector of errors (CompileMessage and errors from peg.js)
//  `model`: the CSN model
class CompilationError extends Error {
  constructor(errs, model, ...args) {
    super(...args);
    this.errors = errs;
    this.model = model;
  }
}

// Class for individual compile errors.
// TODO: an error code would be good in future (configuration, translation, â€¦)
class CompileMessage extends Error {
  constructor(location, msg, severity = 'Error') {
    super(msg);
    this.location = location;
    this.severity = severity;
  }
  toString() {                  // should have no argument...
    return messageString(this);
  }
}

// Return message string with location if present
function messageString( err, normalizeFilename) {
  return (err.location ? locationString( err.location, normalizeFilename ) + ': ' : '') +
         (err.severity ? err.severity + ': ' : '') +
         err.message;
}

// Compare two messages `a` and `b`. Return 0 if they are equal, 1 if `a` is
// greater than `b`, and -1 if `a` is less than `b`. Messages without a location
// are considered equal, unless compared to a message with location, in which
// case they are considered larger, so they are put at the end of a sorted list
function compareMessage( a, b ) {
  if (a.location && b.location) {
    let aend = a.location.end || a.location.start;
    let bend = b.location.end || b.location.start;
    return ( c( a.location.filename, b.location.filename ) ||
             c( a.location.start.line, b.location.start.line ) ||
             c( a.location.start.column, b.location.start.column ) ||
             c( aend.line, bend.line ) ||
             c( aend.column, bend.column ) ||
             c( a.message, b.message ) );
  }
  else
    return (!a.location ? (!b.location ? 0 : 1) : -1);

  function c( x, y ) {
    return (x == y) ? 0 : (x > y) ? 1 : -1;
  }
}

// Return string for complete reference
function refString( ref ) {
  // prepare that resolvePath does not set ref.absolute etc:
  let name = (ref._artifact && ref._artifact.name) || ref;
  let compact = '';
  if (name.alias)
    compact = '.$alias.' + name.alias;
  if (name.action)
    compact = '.$action.' + name.action;
  if (name.param)
    compact += '.$param.' + name.param;
  if (name.element)
    compact += (compact ? '.' : '..') + name.element;
  // Yes, omit $query.0 -> test is (name.query), not (name.query != null)
  return name.absolute + (name.query ? '.$query.' + name.query : '') + compact;
}

module.exports = {
  hasErrors,
  locationString,
  messageString,
  refString,
  sortMessages: (m => m.sort(compareMessage)),
  CompileMessage,
  CompilationError
}

