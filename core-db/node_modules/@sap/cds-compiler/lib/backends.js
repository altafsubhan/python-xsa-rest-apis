'use strict';

// New-style API functions for backends (i.e. functions that take a compiled
// augmented CSN and generate something from it)

// FIXME: Adapt and unify all API docus.

const exportAnnos = require('./i18n/export-annotations'); //export localized annotations values from a given CSN model
const exportUi5Style = require('./i18n/export-annotations-ui5-style');
const csnToSwagger = require('./swagger/toSwagger');
const forHana = require('../lib/output/forHana');
const { compact, compactSorted } = require('./json/compactor')
const { toCdsSource } = require('../lib/output/toCdl');
const { toCdsSourceNew } = require('../lib/output/toCdlNew');
const { toSqlDdl } = require('../lib/output/toSql');
const transformModel = require('./edm/transformModel');
const csn2edm = require('./edm/csn2edm');
const { mergeOptions }  = require('../lib/model/modelUtils');
const tntSpecific = require('./edm/tntSpecific');
const alerts = require('./base/alerts');
const propagator = require('./compiler/propagator');

// Transform an augmented CSN 'model' into HANA-compatible CDS source.
// The following options control what is actually generated:
//   options : {
//     toHana.names        : either 'flat' (generate uppercased flattened entity names with
//                           underscores) or 'deep' (default, generate entity names with nested
//                           contexts as in CDL)
//     toHana.associations : either 'assocs' (default, keep associations as they are if possible)
//                           or 'joins' (replace associations by joins)
//     toHana.src          : if true, generate HANA CDS source files (default)
//     toHana.csn          : if true, generate the transformed CSN model
//   }
// Options provided here are merged with (and take precedence over) options from 'model'.
// If 'toHana.names' is not provided, 'deep' is used.
// If 'toHana.associations' is not provided, 'assocs' is used.
// If neither 'toHana.src' nor 'toHana.csn' are provided, the default is to generate only HANA CDS
// source files.
// If all provided options are part of 'toHana', the 'toHana' wrapper can be omitted.
// The result object contains the generation results as follows (as enabled in 'options'):
//   result : {
//     csn               : the (compact) transformed CSN model
//     _augmentedCsn     : (subject to change): the augmented CSN model
//     hdbcds            : a dictionary of top-level artifact names, containing for each name 'X':
//       <X>             : the HANA CDS source string of the artifact 'X'. Please note that the
//                         name of 'X' may contain characters that are not legal for filenames on
//                         all operating systems (e.g. ':', '\' or '/').
//                         X reflects the naming policy set by toHana.names
//     messages          : an array of strings with warnings (if any)
//   }
// Throws a CompilationError on errors.
function toHana(model, options) {
  // Must perform propagation now if it was disabled for the original CSN output
  if (model.options.disablePropagate) {
    model = propagator.propagateAssignments(model);
  }
  // Optional wrapper?
  if (options && !options.toHana) {
    options = { toHana : options };
  }
  // Provide defaults and merge options with those from model
  options = mergeOptions({ toHana : getDefaultBackendOptions().toHana }, model.options, options);

  // Provide something to generate if nothing else was given (conditional default)
  if (!options.toHana.src && !options.toHana.csn) {
    options.toHana.src = true;
  }

  // Prepare model for HANA
  let forHanaAugmented = forHana.transformForHana(model, options);

  // Assemble result
  let result = {};
  if (options.toHana.src) {
    result.hdbcds = toCdsSource(forHanaAugmented);
  }
  if (options.toHana.csn) {
    result._augmentedCsn = forHanaAugmented;
    result.csn = compactSorted(forHanaAugmented);
  }

  // Transfer warnings (errors would have resulted in an exception before we come here)
  if (forHanaAugmented.messages && forHanaAugmented.messages.length > 0) {
    result.messages = forHanaAugmented.messages;
  }
  return result;
}

// Generate ODATA for augmented CSN `model` using `options`.
// Before anything is generated, the following transformations are applied to 'model':
// FIXME: Verify that this is still correct
// - Flatten structured elements (and foreign keys of managed associations pointing to
//   keys that are themselves managed associations).
// - Generate foreign key fields for entities with managed associations (annotated with
//   '@odata.foreignKey4'). Propagate along projections accordingly. Names are built using
//   <assoc>_<key>, conflicts are checked.
// - Complete the 'foreignKeys' property for all managed associations, so that there
//   is always a 'generatedFieldName' for the corresponding generated foreign key field.
// - Implicitly redirect associations based on exposure
// - Check that exposed associations do not point to non-exposed targets
// - Unravel derived type chains, propagating annotations upwards.
// - Rename annotations according to a fixed list of short-hands
// The following options control what is actually generated:
//   options : {
//     toOdata.version     : either 'v2' or 'v4' (default)
//     toOdata.xml         : if true, generate XML output (default)
//     toOdata.json        : if true, generate JSON output (not available for ODATA V2)
//     toOdata.separate    : if true, generate XML 'metadata' and XML 'annotations' separately
//     toOdata.combined    : if true, generate XML metadata and XML annotations together as
//                           'combined' (default)
//     toOdata.csn         : if true, generate the transformed CSN model
//   }
// Options provided here are merged with (and take precedence over) options from 'model'.
// If 'toOdata.version' is not provided, 'v4' is used.
// If neither 'toOdata.xml' nor 'toOdata.json' nor 'toOdata.csn' are provided, the default is
// to generate only XML output. If neither 'toOdata.separate' nor 'toOdata.combined' are provided,
// the default is to generate only combined XML output.
// If all provided options are part of 'toOdata', the 'toOdata' wrapper can be omitted.
//
// The result object contains the generation results as follows (as enabled in 'options'):
//   result : {
//     csn               : the (compact) transformed CSN model including all services
//     _augmentedCsn     : (subject to change): the augmented CSN model including all services
//     services          : a dictionary of service names, containing for each name:
//       <servicename> : {
//         annotations   : an XML string with EDMX annotations for service 'svc'
//         metadata      : an XML string with EDMX metadata for service 'svc'
//         combined      : an XML string with both EDMX metadata and annotations for service 'svc'
//         metadata_json : a JSON object (not a string!) with EDM metadata for service 'svc'
//       }
//     messages          : an array of strings with warnings (if any)
//   }
// If 'model' does not contain any services, 'csn' will still contain the transformed model, but
// 'services' will be an empty dictionary.
//
// Throws a CompilationError on errors.
function toOdata(model, options) {
  // Must perform propagation now if it was disabled for the original CSN output
  if (model.options.disablePropagate) {
    model = propagator.propagateAssignments(model);
  }
  const { error, signal } = alerts(model);
  // Optional wrapper?
  if (options && !options.toOdata) {
    options = { toOdata : options };
  }
  // Provide defaults and merge options with those from model
  options = mergeOptions({ toOdata : getDefaultBackendOptions().toOdata }, model.options, options);

  // Provide something to generate if nothing else was given (conditional default)
  if (!options.toOdata.xml && !options.toOdata.json && !options.toOdata.csn) {
    options.toOdata.xml = true;
  }
  if (!options.toOdata.separate && !options.toOdata.combined) {
    options.toOdata.combined = true;
  }

  // Translate version back to old-style option
  // FIXME: Remove this once the backend uses the new-style option
  options.odataVersion = options.toOdata.version

  // Perform extra-magic for TNT if requested
  if (model.options.tntFlavor) {
    model = tntSpecific.transformTntExtensions(model);
  }

  // Prepare model for ODATA processing
  let forOdataAugmented = transformModel.transform4odata(model, options);

  // Assemble result object
  let result = {
    services: Object.create(null),
    messages: model.messages,
  }
  if (options.toOdata.csn) {
    // TODO: make compactSortedJson the default
    result.csn = options.testMode ? compactSorted(forOdataAugmented) : compact(forOdataAugmented);
    result._augmentedCsn = forOdataAugmented;
  }

  // Create annotations and metadata once per service
  if (options.toOdata.xml || options.toOdata.json) {
    for (let serviceName of transformModel.getServiceNames(model))
    {
      let forOdata = transformModel.postProcessForBackwardCompatibility(forOdataAugmented, serviceName);
      // FIXME: Unify handling of version, omitRecordType and tntFlavor (use original options)
      let l_edm = csn2edm(forOdata, { version: options.odataVersion, omitRecordType: options.odataOmitRecordType, tntFlavor : options.tntFlavor });

      result.services[serviceName] = {};
      if (options.toOdata.xml) {
        if (options.toOdata.separate) {
          result.services[serviceName].annotations = l_edm.toXML('annotations');
          result.services[serviceName].metadata = l_edm.toXML('metadata');
        }
        if (options.toOdata.combined) {
          result.services[serviceName].combined = l_edm.toXML('all');
        }
      }
      if (options.toOdata.json) {
        // JSON output is not available for ODATA V2
        if (options.toOdata.version == 'v2') {
          signal(error`ODATA JSON output is not available for ODATA V2`);
        }
        // FIXME: Why only metadata_json - isn't this rather a 'combined_json' ? If so, rename it!
        result.services[serviceName].metadata_json = l_edm.toJSON();
      }
    }
  }

  // Transfer warnings (errors would have resulted in an exception before we come here)
  if (forOdataAugmented.messages && forOdataAugmented.messages.length > 0) {
    result.messages = forOdataAugmented.messages;
  }
  return result;
}

// Generate CDS source text for augmented CSN model 'model'.
// The following options control what is actually generated:
//   options : {
//     FIXME: This option should be removed and something like 'toCdl.dialect: 'hana' be
//            used instead.
//     toHana : if true, HANA-specific source dialect is generated (affects e.g. the
//              translation of '$self.foo' in paths and ::-ish namespace declarations)
//   }
// One source is created per top-level artifact.
// Return a dictionary of top-level artifacts
// by their names, like this:
// { "foo" : "using XY; context foo {...};",
//   "bar::wiz" : "namespace bar::; entity wiz {...};"
// }
// Throws a CompilationError on errors.
function toCdl(model, options) {
  // Must perform propagation now if it was disabled for the original CSN output
  // FIXME: Hmm, or maybe we don't - this might even benefit from not propagating anything ...
  if (model.options.disablePropagate) {
    model = propagator.propagateAssignments(model);
  }
  // Merge options with those from model
  options = mergeOptions({ toCdl : true }, model.options, options);
  return options.newCsn ? toCdsSourceNew(model, options) : toCdsSource(model, options);
}

// Generate OpenAPI JSON version 3 for the augmented CSN 'model'.
// Return an object representing the Swagger JSONs for all services in the model in the following form:
// {
//  <servicename>:
//    {
//      openapi: '3.0.0',
//      info: { ... },
//      paths: { ...},
//      components: {
//        schemas: { ... }
//      }
//    }
// }
//
// Throws a CompilationError on errors.
function toSwagger(model) {
  // Must perform propagation now if it was disabled for the original CSN output
  if (model.options.disablePropagate) {
    model = propagator.propagateAssignments(model);
  }
  // Merge options with those from model
  // return csnToSwagger(model, options);
  return csnToSwagger(model);
}

// Generate SQL DDL statements for augmented CSN 'model'.
// The following options control what is actually generated:
//   options : {
//     toSql.names         : either 'flat' (generate uppercased flattened table/view names with
//                           underscores) or 'deep' (default, generate quoted table/view names
//                           with dots as in CDL)
//     toSql.associations  : either 'assocs' (default, keep associations as they are if possible)
//                           or 'joins' (replace associations by joins)
//     toSql.src           : if true, generate SQL DDL source files (default)
//     toSql.csn           : if true, generate the transformed CSN model
//   }
// Options provided here are merged with (and take precedence over) options from 'model'.
// If 'toSql.names' is not provided, 'deep' is used.
// If 'toSql.associations' is not provided, 'assocs' is used.
// If neither 'toSql.src' nor 'toSql.csn' are provided, the default is to generate only SQL DDL
// source files.
// If all provided options are part of 'toSql', the 'toSql' wrapper can be omitted.
// The result object contains the generation results as follows (as enabled in 'options'):
//   result : {
//     csn               : the (compact) transformed CSN model
//     _augmentedCsn     : (subject to change): the augmented CSN model
//     sql               : a dictionary of top-level artifact names, containing for each name 'X':
//       <X>             : a string with SQL DDL statements for artifact 'X', terminated with ';'.
//                         Please note that the name of 'X' may contain characters that are not
//                         legal for filenames on all operating systems (e.g. ':', '\' or '/').
//     messages          : an array of strings with warnings (if any)
//   }
// Throws a CompilationError on errors.
function toSql(model, options) {
  // Must perform propagation now if it was disabled for the original CSN output
  if (model.options.disablePropagate) {
    model = propagator.propagateAssignments(model);
  }
  // Optional wrapper?
  if (options && !options.toSql) {
    options = { toSql : options };
  }
  // Provide defaults and merge options with those from model
  options = mergeOptions({ toSql : getDefaultBackendOptions().toSql }, model.options, options);

  // Provide something to generate if nothing else was given (conditional default)
  if (!options.toSql.src && !options.toSql.csn) {
    options.toSql.src = true;
  }

  // FIXME: Currently, '--to-sql' implies transformation for HANA (transferring the options because toHana uses the same)
  let forSqlAugmented = forHana.transformForHana(model, mergeOptions(options, { toHana : options.toSql } ));

  // Assemble result
  let result = {};
  if (options.toSql.src) {
    result.sql = toSqlDdl(forSqlAugmented);
  }
  if (options.toSql.csn) {
    result._augmentedCsn = forSqlAugmented;
    result.csn = compactSorted(forSqlAugmented);
  }

  // Transfer warnings (errors would have resulted in an exception before we come here)
  if (forSqlAugmented.messages && forSqlAugmented.messages.length > 0) {
    result.messages = forSqlAugmented.messages;
  }
  return result;
}

// Generate files for translation of localized annotations for augmented CSN 'model'.
// The following options control what is actually generated:
//   options : {
//     FIXME: Should not be a choice between the two styles but rather a collection of flags
//     toI18n.style : can be 'prop' for property files (default) or 'ui5' for a CSN model
//   }
// Options provided here are merged with (and take precedence over) options from 'model'.
// If all provided options are part of 'toI18n', the 'toI18n' wrapper can be omitted.
// Returns Object with having as property names the representation of the location of the annotation
// and respective values - the annotation string value
function toI18n(model, options) {
  // No propagation required (actually, we are better off better without it)

  // Optional wrapper?
  if (options && !options.toI18n) {
    options = { toI18n : options };
  }
  // Provide defaults and merge options with those from model
  options = mergeOptions({ toI18n : getDefaultBackendOptions().toI18n }, model.options, options);

  // Generate what was requested
  if (options.toI18n.style == 'prop') {
    return exportAnnos(model, options);
  } else if (options.toI18n.style == 'ui5') {
    return exportUi5Style(model, options);
  } else {
    throw new Error(`Invalid style ${options.toI18n.style} for toI18n`);
  }
}

// Generate compact CSN for augmented CSN 'model'
// The following options control what is actually generated:
//   options : {
//     testMode : if true, the result is extra-stable for automated tests (sorted, no 'version')
//   }
// Options provided here are merged with (and take precedence over) options from 'model'.
function toCsn(model, options) {
  // Propagation has been performed (or not) by the compiler - leave that as it was.
  
  // Merge options with those from model
  options = mergeOptions({ toCsn : true }, model.options, options);
  return options.testMode ? compactSorted(model) : compact(model);
}

// Return a set of options containing the defaults that would be applied by the backends.
// Note that this only contains simple mergeable default values, not conditional defaults
// that depend in any way on other options (e.g. toSql provides 'src' if neither 'src' nor
// 'csn' is given: this is a conditional default).   
function getDefaultBackendOptions() {
  return {
    toHana: {
      names : 'flat',
      associations: 'assocs',
    },
    toOdata: {
      version : 'v4',
    },
    toSql: {
      names : 'flat',
      associations: 'assocs',
    },
    toI18n: {
      style: 'prop',
    },
  };
} 

module.exports = {
  toHana,
  toOdata,
  toCdl,
  toSwagger,
  toSql,
  toI18n,
  toCsn,
  getDefaultBackendOptions,
}
