'use strict';

const baseModel = require('../base/model');
const compactor = require('../json/compactor');
const deepCopy = require('../base/deepCopy');
const baseMessages = require('../base/messages');
const { mergeOptions } = require('../model/modelUtils');
const alerts = require('../base/alerts');

// Returns the default 'skip' options for operating with TNT flavor
function getDefaultTntFlavorOptions() {
  // Please keep this in sync with what TNT actually uses
  return {
    skipEntitySetAnnotation: false,   // if true: Do not generate '@odata.entitySet' annotations
    skipForeignKeyAnnotation: false,  // if true: Do not generate '@odata.foreignKey' annotations
    skipGeneratedFKsWithout_: false,  // if true: Generate foreign key names with a '_' as separator
    skipOldStyleSelf: false,          // if true: don't allow 'self' as backlink indicator, use '$self' instead
    skipValueListMagic: false,        // if true: Do not listen for @Common.ValueList.entity and generate NavProp
                                      //          and sap:value-list="fixed-values" @ Property/Parameter
    skipUsingFromIgnoring: false,                    // if true: Do not ignore the FROM of USING declarations, error for IDs after USING
    skipSloppyAnnoAssignments: false,                // if true: Do not allow sloppy annotation assignments syntax for context definitions - use @(...)
    skipServiceIncludes: false,                      // if true: Do not include contexts into services via "@extends" annotation
    skipPropagatingFromProjectionSrc: false,         // if true: Do not propagate properties from source to projection
    skipPropagatingFromInclude: false,               // if true: Do not propagate properties from (first) included artifact
    skipPropagatingActions: false,                   // if true: Do not propagate bound actions (and functions)
    skipPropagatingIncludes: false,                  // if true: Do not propagate the list of included artifacts
    skipNotPropagatingIndexableAnno: false,          // if true: Do not make an exception for the propagation of the '@Indexable' annotation
    skipDuplicatesInProjections: false,              // If true: Do not allow duplicates in projections without putting them in 'exclude'
    skipExtendingProjections: false,                 // If true: Do not allow projections to be extended by elements
    skipSuppressCheckForCdsNamespace: false,         // If true: Do not suppress the compiler check that disallows defining anything in namespace 'cds'

    // ----- annotation preprocessing -----
    skipAnnosFieldGroupValueExpansion: false,        // if true: Do not replace path by "Value" property for @UI.FieldGroup
    skipAnnosTextArrangementReordering: false,       // if true: Do not automatically produce correct form for TextArrangementAnnotation
    skipAnnosHeaderInfoTitleExpansion: false,        // if true: Do not replace path by "Value" property for @UI.HeaderInfo.Title
    skipAnnosUIIdentificationExpansion: false,       // if true: Do not replace path by "Value" property for @UI.Identification
    skipAnnosVisualizationsSimplification: false,    // if true: Do not remove unnecessary nesting of path in @UI.PresentationVariant.Visualizations
    skipAnnosSortOrderSimplification: false,         // if true: Do not remove unnecessary nesting of path in @UI.PresentationVariant.SortOrder
    skipAnnosRequestAtLeastSimplification: false,    // if true: Do not remove unnecessary nesting of path in @UI.PresentationVariant.RequestAtLeast
    skipAnnosUIImportanceDefaulting: false,          // if true: Do not by default set "Importance" to "High" in @UI.LineItem
    skipAnnosUILineItemExpansion: false,             // if true: Do not replace path by "Value" property for @UI.LineItem
    skipAnnosDataFieldAbstract: false,               // if true: Do not replace 'UIDataFieldAbstract' by 'UIDataField'
    skipAnnosEnforceRecordType: false,               // if true: Let `--odata-omit-record-type` decide about unnecessary record type attributes
    skipAnnosTextAndValueListForAssocs: false,       // if true: Do not artificially generate '@Common.Text' and '@Common.ValueList' for associations
    skipAnnosRemoveManagedAssociationAnnos: false,   // if true: Do not remove annotations from managed associations
    skipAnnosFixedValueListShortcut: false,          // if true: Do not artificially expand '@Common.ValueList' properties for 'type : #fixed'
    skipAnnosSubstitutingFKeysForAssocs: false,      // if true: Do not replace paths to assocations by paths to their (single) foreign key in
                                                     //          selected annotations (currently '@UI.LineItem', '@UI.Identification',
                                                     //          '@UI.FieldGroup', '@UI.SelectionFields')
  };
}

// Post-process an augmented CSN model 'model' that has been produced by 'transform4odata' so that it
// looks like the original (compacted) output of '4allEntity' for TNT, using compiler options 'options'.
// Currently this involves the following steps:
// - Produce a '@odata.entitySet' annotation for each entity with its last name
//   => Should not be done (last name should be sufficient)
// - Remove contexts
//   => Should not be done, actually
// - Propagate annotations from the association to the foreign key element
//   => Questionable: Should either not be done (preferred) or always, and then in transform4odata
// - Add @odata.foreignKey annotation to managed associations
//   => Should not be done (can only work for single foreign keys, which happens to be true for TNT)
// - Add default cardinality to associations that have none
//   => Should not be done, actually
// - Remove those parts of foreignKeys info that was added implicitly
//   => Should not be done, actually
// - Reconstruct parsed query for projection views
//   => Should not be done (all of the contained info is available elsewhere) 
// In addition to this, the following steps are also performed (none of them makes
// sense, they are strictly only for backward-compatibility and should be removed asap)
// - Remove contexts and services 
// - Remove 'source'
// - Remove 'abstract'
// - Remove 'origin' from actions
// - Reduce 'origin' of action parameters to an empty object
// - Undo annotation renamings for foreign key fields
// - Rename assocation and composition types (no 'cds.' prefix)
// - Remove 'onCond'
// - Undo the shorthand annotation renaming for inline enum types
// - Remove 'includes' for projections
// Return a (compacted) copy of 'model' with the transformation applied. Do not change the original model.
function postProcessForTnt4allEntity(model) {
  let options = model.options;
  // Sanity check: Should only be called for TNT-flavor
  if (!options.tntFlavor) {
    throw new Error('postProcessForTnt4allEntity should not be called without tntFlavor options')
  }

  // Compact the model
  let compactedModel = compactor.compact(model, options);
  baseModel.setProp(compactedModel, 'messages', model.messages);

  // Iterate artifact definitions on the augmented model, but modify the compacted one in parallel
  baseModel.forEachDefinition(model, (artifact, artifactName) => {
    // Get corresponding compacted artifact
    let compactedArtifact = compactedModel.definitions[artifactName];

    // Produce a '@odata.entitySet' annotation for each entity with its last name
    if (!options.tntFlavor.skipEntitySetAnnotation) {
      if (artifact.kind == 'entity') {
        compactedArtifact['@odata.entitySet'] = artifactName.split('.').reverse()[0];
      }
    }
    // Iterate elements in the augmented artifact, but modify the compacted one in parallel
    // (only direct elements, not nested ones, because none of the transformations
    // below would affect them - associations are not yet allowed within nested elements)
    baseModel.forEachMember(artifact, (element, elementName) => {
      // Only elements of the artifact
      if (element.kind != 'element' || (compactedArtifact.elements && compactedArtifact.elements[elementName]) == undefined) {
        return;
      }
      // Get corresponding compacted element
      let compactedElement = compactedArtifact.elements[elementName];
      // If this is a generated foreign key element
      if (compactedElement['@odata.foreignKey4']) {
        let assocName = compactedElement['@odata.foreignKey4'];
        let compactedAssoc = compactedArtifact.elements[assocName];
        // Add @odata.foreignKey annotation to the corresponding
        // managed association
        if (!options.tntFlavor.skipForeignKeyAnnotation) {
          compactedAssoc['@odata.foreignKey'] = elementName;
        }
      }
    });
  });
  return compactedModel;
}

// Perform TNT-specific extensions for augmented 'inputModel'. Each service S that has an '@extends: XXX'
// annotation gets a copy of all artifacts from context/service 'com.sap.gtt.core.CoreServices.XXX'.
// All associations and compositions in service S (whether copied into S or originally part of S) that
// pointed into 'XXX' are then re-targeted to S.
// Return an (augmented) copy of 'inputModel' with the transformation applied. Do not change the original inputModel.
// Throws a CompilationError on errors. Warnings are stored in the result model.
function transformTntExtensions(inputModel, options) {
  const { error, signal, getErrors } = alerts(inputModel);
  // Deep-copy the original model
  let model = deepCopy(inputModel);
  model.messages = inputModel.messages;
  model.options = mergeOptions(model.options, options);
  // Do nothing except deep-copy if no TNT-flavor or if skipped
  if (!model.options.tntFlavor || model.options.tntFlavor.skipServiceIncludes) {
    return model;
  }
  // Find services that have an '@extends' annotation
  for (let name in model.definitions) {
    let artifact = model.definitions[name];
    if (artifact.kind == 'service' && artifact['@extends']) {
      let serviceName = name;
      let annotationValue = artifact['@extends'].path.map(step => step.id).join('.');
      // FIXME: The '@extends' annotation should at least contain the fully qualified name
      // of the context to be included - we assume here that it starts with 'com.sap.gtt.core.CoreServices.'
      let includedContextName = 'com.sap.gtt.core.CoreServices.' + annotationValue;
      // console.log('Extending service ' + name + ' with ' + includedContextName);
      // Find the context to be included
      let includedContext = model.definitions[includedContextName];
      if (includedContext == undefined) {
        signal(error`Cannot extend service "${serviceName}" with "${includedContextName}": not found`, artifact['@extends'].location);
        continue;
      }
      // Must be a context or a service
      if (includedContext.kind != 'context' && includedContext.kind != 'service') {
        signal(error`Cannot extend service "${serviceName}" with "${includedContextName}": "${includedContext.kind}" is neither context nor service`, artifact['@extends'].location);
        continue;
      }
      // Copy all artifacts contained within the included context/service (by means of their name prefix only!)
      for (let name in model.definitions) {
        if (name.startsWith(includedContextName + '.')) {
          let sourceName = name;
          let targetName = sourceName.replace(includedContextName, serviceName);
          // console.log('Copying artifact ' + sourceName + ' to ' + targetName);
          if (model.definitions[targetName]) {
            signal(error`Cannot extend service "${serviceName}" with "${includedContextName}": "${targetName}" already exists`, artifact['@extends'].location);
          }
          // We can only import one level of artifacts here (i.e. no containers)
          let localName = sourceName.substring(includedContextName.length + 1);
          if (localName.indexOf('.') != -1) {
            signal(error`Cannot extend service "${serviceName}" with artifact "${sourceName}": only entities/types are allowed, not contexts/services`, artifact['@extends'].location);
          }
          // Deep-copy the source artifact
          let sourceArtifact = model.definitions[sourceName];
          let targetArtifact = baseModel.cloneWithTransformations(sourceArtifact, {});
          // FIXME: In order not to have to manually adapt all internal links for actions and their parameters,
          // we refrain from deep-copying them here and simply take them as they are - niemand hat die Absicht, sie zu veraendern anyway ...
          if (sourceArtifact.actions) {
            targetArtifact.actions = sourceArtifact.actions;
          }
          if (targetArtifact.elements != undefined) {
            for (let elementName in targetArtifact.elements) {
              let sourceElement = sourceArtifact.elements[elementName];
              let targetElement = targetArtifact.elements[elementName];
              // Restore _artifact in element type
              if (targetElement.type) {
                baseModel.setProp(targetElement.type, '_artifact', sourceElement.type._artifact);
              }
              // Restore _artifact and _status in element origins
              // FIXME: Remove once the compactor no longer renders 'origin'
              if (targetElement.origin) {
                baseModel.setProp(targetElement.origin, '_artifact', sourceElement.origin._artifact);
                baseModel.setProp(targetElement.origin, '_status', sourceElement.origin._status);
              }
              if (targetElement.value) {
                baseModel.setProp(targetElement.value, '_artifact', sourceElement.value._artifact);
              }
              baseModel.setProp(targetElement, '_main', targetArtifact);
              // FIXME: Not entirely complete for nested stuff, but good enough for now...
              baseModel.setProp(targetElement, '_parent', targetArtifact);
              if (sourceElement._finalType) {
                baseModel.setProp(targetElement, '_finalType', sourceElement._finalType);
              }
            }
          }
          // Restore _artifact in artifact type
          if (targetArtifact.type) {
            baseModel.setProp(targetArtifact.type, '_artifact', sourceArtifact.type._artifact);
          }
          // Adapt the target artifact's name (artificial, i.e. no path)
          targetArtifact.name = {
            absolute: targetName
          }
          model.definitions[targetName] = targetArtifact;
          // Adapt target artifact's parent/child relation
          artifact.artifacts[localName] = targetArtifact;
          baseModel.setProp(targetArtifact, '_parent', artifact);
          if (sourceArtifact.source != targetArtifact.source) {
            targetArtifact.source = sourceArtifact.source;
          }
        }
      }
      // Adapt all association targets within the service that has included the context (by means of their name prefix only!)
      for (let name in model.definitions) {
        if (name.startsWith(serviceName + '.')) {
          let artifact = model.definitions[name];
          // If the artifact has association elements, adapt their targets and foreign keys
          for (let elementName in artifact.elements || {}) {
            let element = artifact.elements[elementName];
            if (element.target != undefined) {
              element.target.absolute = element.target.absolute.replace(includedContextName, serviceName);
              baseModel.setProp(element.target, '_artifact', model.definitions[element.target.absolute]);
              if (element.foreignKeys != undefined) {
                for (let foreignKeyName in element.foreignKeys) {
                  let foreignKey = element.foreignKeys[foreignKeyName];
                  foreignKey.name.absolute = element.name.absolute;
                  baseModel.setProp(foreignKey.targetElement, '_artifact', element.target._artifact.elements[foreignKey.name.id]);
                }
              }
            }
          }
        }
      }
    }
  }
  // Throw up if we have errors
  let errors = getErrors();
  if (errors.length > 0) {
    throw new baseMessages.CompilationError(baseMessages.sortMessages(errors), model);
  }
  return model;
}

module.exports = {
  getDefaultTntFlavorOptions,
  postProcessForTnt4allEntity,
  transformTntExtensions,
}
