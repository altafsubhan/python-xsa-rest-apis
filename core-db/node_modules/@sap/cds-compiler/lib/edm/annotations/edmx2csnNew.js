const parseXml = require('./xmlParserWithLocations');
const validator = require('./edmx2csnNewValidation');

/*

  The generator takes an xml file as an input and generates augmented csn extenstions as per the content.
  The logic assumes that the xml content is a valid edmx one, e.g. has 'Annotations' tags with 'Target' attributes
  and those 'Annotations' tags have 'Annotation' tags for children.

*/
function edmx2csn(src, filename) {
  let source = parseXml(src, filename);
  // create the skeleton for the augmented result
  let csn = augmentedCsn.extensions();

  forEachAnnotationsTag(source, annotations => {
    // loop through all the 'Annotations' tags in the source
    annotations.forEach(obj => {
      let elements = obj._attributes.Target.split('/');
      let topLevelArt = elements.shift(); // get the top level targeted artifact

      // loop through all the 'Annotation' tags under an 'Annotations' tag
      obj.Annotation.forEach(anno => {
        // look if there is an extension for this top level artifact already
        let found = csn.extensions.find(ext => ext.name.absolute === topLevelArt);
        if (found)
          augmentedExtensionForAnnotation(anno, found, elements, csn.messages, topLevelArt);
        else { // if not -> create one
          let extension = augmentedCsn.extension(topLevelArt, obj._location);
          augmentedExtensionForAnnotation(anno, extension, elements, csn.messages, topLevelArt);
          csn.extensions.push(extension);
        }
      });
    });
  });
  csn.$frontend = 'xml';
  return csn;

  function forEachAnnotationsTag(obj, callback) {
    if (obj === null)
      return;
    for (let prop in obj) {
      if (prop === 'Annotations') {
        callback(obj[prop]);
      }
      obj[prop].forEach(elem => forEachAnnotationsTag(elem, callback));
    }
  }

  // takes an 'Annotation' tag object of a parsed xml and creates annotation assignment in the extension from it
  // last two arguments(messages, topLevelArt) are used for logging during valdiation of an edmx annotation definition
  function augmentedExtensionForAnnotation(annotation, extension, elements, messages, topLevelArt) {
    // 1. Get the extension to be annotated. Can be a top level artifact or an element of a top level artifact
    elements.forEach(elem => {
      if (!extension.elements)
        extension.elements = Object.create(null);
      if (extension.elements[elem])
        extension = extension.elements[elem];
      else
        extension = extension.elements[elem] = augmentedCsn.extension(elem, annotation._location);
    })

    // 2. Add respective annotations
    Object.assign(extension, createAnnosForArtifact(annotation, messages, topLevelArt));

    function createAnnosForArtifact(anno, messages, targetName) {
      validator.validateTerm(anno._attributes.Term, targetName, anno._location, messages);
      validator.validateType(anno, { term: anno._attributes.Term, target: targetName, messages: messages });

      let parsedAnnos = handleGeneric({ 'Annotation': [anno] });
      let result = Object.create(null);
      let annoName = `@${anno._attributes.Term}${anno._attributes.Qualifier ? `#${anno._attributes.Qualifier}` : ``}`;
      if (parsedAnnos.struct) { //from struct create all the annotations
        Object.keys(parsedAnnos.struct).forEach(a => {
          result[`${annoName}.${a}`] = parsedAnnos.struct[a];
          result[`${annoName}.${a}`].name = {
            path: `@${anno._attributes.Term}.${a}`.split('.').map(p => {
              return { id: p, location: anno._location }
            }), location: anno._location
          }
          result[`${annoName}.${a}`].priority = 'annotate';
        })
      } else {
        result[annoName] = parsedAnnos;
        result[annoName].name = {
          path: anno._attributes.Term.split('.').map(p => {
            return { id: p, location: anno._location }
          }), location: anno._location
        }
        result[annoName].priority = 'annotate';
      }
      return result;

      // actual parsing of an edmx annotation definition
      function handleGeneric(obj, isCollection = false) {
        if (obj.Annotation)
          return handleAnnotation(obj.Annotation, isCollection);
        if (obj.Record)
          return handleRecord(isCollection ? obj.Record : obj.Record[0], isCollection);
        if (obj.Collection)
          return handleCollection(obj.Collection[0]);
        if (obj.PropertyPath || obj.NavigationPropertyPath || obj.AnnotationPath)
          return handlePath(obj.PropertyPath || obj.NavigationPropertyPath || obj.AnnotationPath, isCollection);
        if (obj.PropertyValue)
          return handlePropValue(obj.PropertyValue, isCollection);
        else
          return handleValue(obj, isCollection);

        // edmx annotation cannot have Collection of Collection (checked in Dictionary.json),
        // so will have always one Collection tag as a child tag
        function handleAnnotation(obj, isCollection) {
          if (isCollection)
            return obj.map(e => handleAnnotation(e, false));
          // handle a nested annotation in an annotation
          // TODO: really ugly written, redo it
          if (obj[0].Annotation) {
            // assign the value
            let result = { literal: 'struct', location: obj[0]._location, struct: {} };
            result.struct['$value'] = handleValue(obj[0], false);
            result.struct['$value'].name = { id: '$value', location: obj[0]._location };
            // assign the nested annotation
            let term = obj[0].Annotation[0]._attributes.Term;
            result.struct[`@${term}`] = { name: { id: term, location: obj[0].Annotation[0]._location } };
            Object.assign(result.struct[`@${term}`], handleValue(obj[0].Annotation[0], false));
            return result;
          } else
            return handleGeneric(obj[0], isCollection);
        }

        function handleRecord(obj, isCollection) {
          if (isCollection)
            return obj.map(e => handleRecord(e, false))
          let result = {
            literal: 'struct',
            location: obj._location,
            struct: Object.create(null)
          }
          // a record can have as children either PropertyValue or Annotation
          if (obj.PropertyValue)
            obj.PropertyValue.forEach(prop => {
              Object.assign(result.struct, handlePropValue(prop, false));
            })
          if (obj.Annotation)
            obj.Annotation.forEach(anno => {
              result.struct[`@${anno._attributes.Term}`] = { name: { id: `@${anno._attributes.Term}`, location: anno._location } };
              Object.assign(result.struct[`@${anno._attributes.Term}`], handleGeneric(anno, false));
            })
          return result;
        }

        function handleCollection(collection) {
          return {
            literal: 'array',
            location: collection._location,
            val: handleGeneric(collection, true)
          };
        }

        function handlePath(obj, isCollection) {
          return isCollection ?
            obj.map(e => handlePath(e, false))
            // TODO: more cases to be handle here
            : { path: obj._text.split('/').map(p => { return { id: p, location: obj._location } }), location: obj._location };
        }

        function handlePropValue(obj, isCollection) {
          if (isCollection)
            return obj.map(e => handlePropValue(e, false))
          let result = { [obj._attributes.Property]: handleGeneric(obj) };
          result[obj._attributes.Property].name = { id: obj._attributes.Property, location: obj._location };
          return result;
        }

        function handleValue(obj, isCollection) {
          if (obj.String)
            return isCollection ?
              obj.String.map(e => handleValue(e, false))
              : { val: obj.String._text, literal: 'string', location: obj._location };
          if (obj._text)
            return { val: obj._text, literal: 'string', location: obj._location };
          if (isCollection)
            return obj.map(e => handleValue(e, false));
          if (obj._attributes.Bool)
            return { val: obj._attributes.Bool === 'true', literal: 'boolean', location: obj._location };
          if (obj._attributes.String)
            return { val: obj._attributes.String, literal: 'string', location: obj._location };
          if (obj._attributes.Decimal)
            return { val: Number(obj._attributes.Decimal), literal: 'decimal', location: obj._location };
          if (obj._attributes.Int)
            return { val: Number(obj._attributes.Int), literal: 'integer', location: obj._location };
          // TODO: should be moved to renderPath
          if (obj._attributes.Path)
            return { path: obj._attributes.Path.split('/').map(p => { return { id: p, location: obj._location } }), location: obj._location };
          if (obj._attributes.NavigationPropertyPath)
            return { path: obj._attributes.NavigationPropertyPath.split('/').map(p => { return { id: p, location: obj._location } }), location: obj._location };
          if (obj._attributes.PropertyPath)
            return { path: obj._attributes.PropertyPath.split('/').map(p => { return { id: p, location: obj._location } }), location: obj._location };
          if (obj._attributes.EnumMember)
            return handleEnum(obj._attributes.EnumMember, obj._location)
          return {};
        }

        function handleEnum(enummember, location) {
          // the value contains whitespaces => array
          if (/\s/.test(enummember))
            return enummember.match(/\S+/g).map(e => handleEnum(e, location));
          let enumSymbol = enummember.split('/').pop();
          return {
            literal: 'enum',
            symbol: { id: enumSymbol, location },
            location
          }
        }
      }
    }
  }
}

const augmentedCsn = {
  extensions: function () {
    return {
      kind: "source",
      extensions: [],
      messages: []
    }
  },
  extension: function (key, location) {
    return {
      location,
      name: { path: [{ id: key, location }], location },
      annotationAssignments: [],
      kind: 'annotate'
    }
  },
}

module.exports = edmx2csn;
