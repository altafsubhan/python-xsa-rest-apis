'use strict';

const Edm = require('../edm.js');
const glue = require('../glue.js');
const preprocessAnnotations = require('./preprocessAnnotations.js');
const g_dict = require('./vocabularies/Dictionary.json');
const alerts = require('../../base/alerts');

/**************************************************************************************************
 * csn2annotationEdm
 *
 * options:
 *   v
 *   tntFlavor
 *   embeddedV2
 *   suppressMessages --- currently not used
 *   omitRecordType
 */
function csn2annotationEdm(csn, options=undefined) {

  // annotation preprocessing, partially tnt specific
  //   the only option used in preprocessAnnotations is tntFlavor
  preprocessAnnotations.preprocessAnnotations(csn, options);

  if(options === undefined)
    throw "Please debug me: csn2annotationsEdm must be invoked with options"

  let  g_enforceRecordType = options.omitRecordType != true;
  let  g_annosArray = [];

  let v = options.v;

  const { error, signal } = alerts(csn);

  // TODO only works for single service
  let serviceName = null;
  for (let objName in csn.definitions) {
    let object = csn.definitions[objName];
    if (object.kind == "service") {
      serviceName = objName;
    }

    // handle the annotations directly tied to the object
    handleAnnotations(objName, object);
    // handle the annotations of the object's elements
    handleElements(objName, object);
    // handle the annotations of the object's actions
    handleActions(objName, object);
  }

  let schema = Edm.Schema.create(v, serviceName, serviceName, g_annosArray, false);
  let service = Edm.DataServices.create(v, schema);
  let edm = Edm.create(v, service);
  return edm;

//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------



  //
  // this function is called in the translation code to issue an error message
  //    messages are reported via the alerts attribute of csn
  //
  function errorMessage(context, message) {
    let fullMessage = "in annotation translation: " + message;
    if (context) {
      let loc = "target: " + context.target + ", annotation: " + context.term;
      if (context.stack.length > 0) {
        loc += context.stack.join('');
      }
      fullMessage += ", " + loc;
    }
    signal(error`${fullMessage}`);
  }


  // there are 4 possible kinds of targets for annotations
  // csn: annotation at entity
  //      depending on the term, the target in edm is the corresponding
  //      -  entity type 
  //       - or entity set
  // csn: annotation at element of entity
  //      target in edm is the corresponding element of the entity type
  // csn: annotation at parameter of action of entity
  //      target in edm is the action parameter in the EntityContainer



  // handle the annotations of the elements of an object
  // in: objname : name of the object
  //     object : the object itself
  function handleElements(objname, object) {
    if (!object.elements) return;
    for (let elemName in object.elements) {
      let element = object.elements[elemName];

      // determine the name of the target in the resulting edm
      //   for non-assoc element, this simply is "<objectName>/<elementName>"
      let edmTargetName = objname + "/" + elemName;
      handleAnnotations(edmTargetName, element);

      // handle sub elements
      if (element.elements) {
        handleNestedElements(objname, elemName, element.elements);
      }
    }
  }

  // handling annotations at nested elements is not yet supported
  // => issue an error, but only if there actually are annotations
  function handleNestedElements(objname, baseElemName, elementsObj) {
    for (let elemName in elementsObj) {
      let element = elementsObj[elemName];

      if (Object.keys(element).filter( x => x.substr(0,1) == "@" ).filter(filterKnownVocabularies).length > 0) {
        errorMessage(null, "annotations at nested elements are not yet supported, object " + objname + ", element " + baseElemName + "." + elemName);
      }

      if (element.elements) {
        handleNestedElements(objname, baseElemName + "." + elemName, element.elements);
      }
    }
  }


  // handle the annotations of actions and action parameters
  // in: cObjectname : name of the object that holds the actions
  //     cObject  : the object itself
  function handleActions(cObjectname, cObject) {
    // edm target name is "<serviceName>.EntityContainer/<actionName>" or
    //   "<serviceName>.EntityContainer/<actionName>/<parameterName>"
    // TODO the respective entity names do not appear in the target name
    //      => in edm all actions are in the same namespace
    //      => what if two or more entities have actions with same names?

    // service name -> remove last part of the name
    // TODO this only works if all objects ly flat in the service
    let nameParts = cObjectname.split(".")
    nameParts.pop();
    let serviceName = nameParts.join(".");

    for (let actionName in cObject.actions) {
      let action = cObject.actions[actionName];
      let edmTargetName = serviceName + ".EntityContainer/" + actionName;
      handleAnnotations(edmTargetName, action);
      for (let paramName in cObject.actions[actionName].params) {
        let param = cObject.actions[actionName].params[paramName];
        edmTargetName = serviceName + ".EntityContainer/" + actionName + "/" + paramName;
        handleAnnotations(edmTargetName, param);
      }
    }
  }


  // note: in csn, all annotations are flattened out
  // => values can be
  //    - primitive values (string, number)
  //    - pseudo-records with "#" or "="
  //    - arrays


  // handle the annotations for a specific object or element or action parameter,
  //   here called carrier
  //   carrierName : string, name of the annotated object, element path is separated from
  //                         object name by "/"
  //                 TODO: handling of nested elements?
  //   carrier: object, the annotated object, contains all the annotations
  //                    as properties with names starting with @
  function handleAnnotations(carrierName, carrier) {
    // collect the names of the carrier's annotation properties
    // keep only those annotations that start with a known vocabulary name
    let annoNames = Object.keys(carrier).filter( x => x.substr(0,1) == "@" );
    let knownAnnos = annoNames.filter(filterKnownVocabularies);
    if (knownAnnos.length == 0) return

    // result object that holds all the annotation objects to be created
    let newAnnos = Edm.Annotations.create(v, carrierName);

    // for annotations at entities: some need to be attached to the entity set rather than to the entity type
    // => different edmTargetName
    // find last . in name and insert "EntityContainer/"
    let edmTargetName2 = carrierName.replace(/\.(?=[^.]*$)/, '.EntityContainer/')
    let newAnnosForEntitySet = Edm.Annotations.create(v, edmTargetName2);

    // build prefix tree for the annotations attached to the carrier
    let prefixTree = {};
    for (let a of knownAnnos) {
      // remove leading @ and split at "."
      //   stop splitting at ".@" (used for nested annotations)
      let sa = a.split(".@");
      let steps = sa[0].slice(1).split(".");
      if (sa[1]) {
        steps.push('@' + sa[1]);
      }
      mergePathStepsIntoPrefixTree(prefixTree, steps, 0, carrier);
    }

    // now create annotation objects for all the annotations of carrier
    //   and put them into the elements property of the result object
    function addAnnotation(annotation, forEntitySet) {
      (forEntitySet ? newAnnosForEntitySet : newAnnos).append(annotation);
    }
    handleAnno2(addAnnotation, carrierName, prefixTree);

    g_annosArray.push(newAnnos);
    if (newAnnosForEntitySet._children.length > 0) {
      g_annosArray.push(newAnnosForEntitySet);
    }
  }


  // tree: object where to put the next level of names
  // path: the parts of the annotation name
  // index: index into that array pointing to the next name to be processed
  //   0  : vocabulary
  //   1  : term
  //   2+ : record properties
  //
  // example:
  //   @v.t1
  //   @v.t2.p1
  //   @v.t2.p2
  //   @v.t3#x.q1
  //   @v.t3#x.q2
  //   @v.t3#y.q1
  //   @v.t3#y.q2
  // 
  //   { v : { t1 : ...,
  //           t2 : { p1 : ...,
  //                  p2 : ...   },
  //           t3#x : { q1 : ..., 
  //                    q2 : ... }
  //           t3#y : { q1 : ...,
  //                    q2 : ... } } }
  function mergePathStepsIntoPrefixTree(tree, pathSteps, index, carrier) {
    // TODO check nesting level > 3
    let name = pathSteps[index];
    if (index+1 < pathSteps.length ) {
      if (!tree[name]) {
        tree[name] = {};
      }
      mergePathStepsIntoPrefixTree(tree[name], pathSteps, index+1, carrier);
    }
    else {
      tree[name] = carrier["@" + pathSteps.join('.')];
    }
  }


  function handleAnno2(addAnnotationFunc, carrierName, prefixTree) {
    // first level names of prefix tree are the vocabulary names
    // second level names are the term names
    // create an annotation object for each term
    for (let voc of Object.keys(prefixTree)) {
      for (let term of Object.keys(prefixTree[voc])) {
        let fullTermName = voc + "." + term;

        // anno is the full <Annotation Term=...>
        let context = { target: carrierName,  term: fullTermName, stack: [] };
        let anno = handleTerm(fullTermName, prefixTree[voc][term], context);

        // now we need to decide where to put it
        fullTermName = fullTermName.replace(/#(\w+)$/g, "");
        let dictTerm = g_dict.terms[fullTermName]; // message for unknown term issued in handleTerm
        let forEntitySet = dictTerm != undefined &&
                           dictTerm.AppliesTo != undefined &&
                           dictTerm.AppliesTo.match(/EntitySet/) &&
                           !dictTerm.AppliesTo.match(/EntityType/);

        addAnnotationFunc(anno, forEntitySet);
      }
    }
  }


  // annoValue : the annotation value from the csn
  //             if the csn contains flattened out elements of a structured annotation,
  //             they are regrouped here
  // context :   for error messages
  // return :    object that represents the annotation in the result edmx
  function handleTerm(termName, annoValue, context) {
    let newAnno = Edm.Annotation.create(v, termName);

    // termName may contain a qualifier: @UI.FieldGroup#shippingStatus
    // -> remove qualifier from termName and set Qualifier attribute in newAnno
    let p = termName.split('#');
    let termNameWithoutQualifiers = p[0];
    if (p.length>1) {
      newAnno.Term = termNameWithoutQualifiers;
      newAnno.Qualifier = p[1];
    }
    if (p.length>2) {
      errorMessage(context, "multiple qualifiers (" + p[1] + "," + p[2] +  (p.length>3?',...':'') + ")")
    }

    // get the type of the term from the dictionary
    let termTypeName = null;
    let dictTerm = g_dict.terms[termNameWithoutQualifiers];
    if (dictTerm) {
      termTypeName = dictTerm.Type;
    }
    else {
      errorMessage(context, "unknown term " + termNameWithoutQualifiers);
    }

    handleValue(annoValue, newAnno, termNameWithoutQualifiers, termTypeName, 0, context);
    return newAnno;
  }

  // found an enum value ("#"), check whether this fits
  //  the expected type "expectedTypeName"
  function checkEnumValue(enumValue, expectedTypeName, context) {
    let expectedType = g_dict.types[expectedTypeName];
    if (expectedType == undefined && !isPrimitiveType(expectedTypeName)) {
      // TODO: test for this error?
      errorMessage(context, "internal error: dictionary inconsistency: type '" + expectedTypeName + "' not found");
    }
    else if (isComplexType(expectedTypeName)) {
      errorMessage(context, "found enum value, but expected complex type " + expectedTypeName);
    }
    else if (isPrimitiveType(expectedTypeName) || expectedType["$kind"] != "EnumType") {
      errorMessage(context, "found enum value, but expected non-enum type " + expectedTypeName);
    }
    else if (!expectedType["Members"].includes(enumValue)) {
      errorMessage(context, "enumeration type " + expectedTypeName + " has no value " + enumValue);
    }
    return;
  }

  // found an expression value ("=") "expr"
  //   expected type is dTypeName
  // note: expr can also be provided if an enum or a complex type is expected
  function handleExpression(expr, dTypeName, context) {
    let typeName = "Path";
    if (dTypeName == "Edm.PropertyPath" ||
        dTypeName == "Edm.AnnotationPath" ||
        dTypeName == "Edm.NavigationPropertyPath") {
      typeName = dTypeName.split('.')[1];
    }

    let val = expr;
    if (!expr) {
      errorMessage(context, "empty expression value");
    }
    else if (expr.charAt(0) == '@') {
      val = expr;
    }
    else {
      // cds path -> edmx path: replace '.' by '/'
      val = expr.replace(/\./g, "/");
    }

    return {
      name : typeName,
      value : val
    }
  }


  // found a simple value "val"
  //  expected type is dTypeName
  function handleSimpleValue(val, dTypeName, context) {
    // caller already made sure that val is neither object nor array
    dTypeName = resolveType(dTypeName);

    let typeName = "String";

    if (typeof val === 'string') {
      if (dTypeName == "Edm.AnnotationPath") {
        typeName = "AnnotationPath";
      }
      else if (dTypeName == "Edm.PropertyPath") {
        typeName = "PropertyPath";
      }
      else if (dTypeName == "Edm.String") {
        typeName = "String";
      }
      else if (dTypeName == "Edm.Boolean") {
        if (val == "true" || val == "false") {
          typeName = "Bool";
        }
        else {
          errorMessage(context, "found String, but expected type " + dTypeName);
        }
      }
      else if (dTypeName == "Edm.Double") {
        if (isNaN(val) || isNaN(parseFloat(val))) {
          errorMessage(context, "found non-numeric string, but expected type " + dTypeName);
        }
        else {
          typeName = "Decimal";
        }
      }
      else if (isComplexType(dTypeName)) {
        errorMessage(context, "found String, but expected complex type " + dTypeName);
      }
      else if (isEnumType(dTypeName)) {
        errorMessage(context, "found String, but expected enum type " + dTypeName);
        typeName = "EnumMember";
      }
      else {
        // TODO
      }
    }
    else if (typeof val === 'boolean') {
      typeName = "Bool";
      if (dTypeName == "Edm.Boolean") {
        val = val ? "true" : "false";
      }
      else if (dTypeName == "Edm.String") {
        typeName = "String";
      }
      else {
        errorMessage(context, "found Boolean, but expected type " + dTypeName);
      }
    }
    else if (typeof val === 'number') {
      if (isComplexType(dTypeName)) {
        errorMessage(context, "found number, but expected complex type " + dTypeName);
      }
      else if (dTypeName === 'Edm.String') {
        typeName = "String";
      }
      else if (dTypeName == "Edm.PropertyPath") {
        errorMessage(context, "found number, but expected " + dTypeName);
      }
      else if (dTypeName == "Edm.Double") {
        typeName = "Decimal";
      }
      else if (dTypeName == "Edm.Boolean") {
        errorMessage(context, "found number, but expected type " + dTypeName);
      }
      else {
        typeName = Number.isInteger(val) ? 'Int' : 'Decimal';
      }
    }
    else {
      errorMessage(context, "expected simple value, but found value '" + val + "' with type '" + typeof val + "'");
    }

    return {
      name : typeName,
      value : val
    };
  }



  // handle the actual value cAnnoValue
  //   oTarget: the result object
  //   oTermName: current term
  //   dTypeName: expected type of cAnnoValue according to dictionary, may be null
  function handleValue(cAnnoValue, oTarget, oTermName, dTypeName, depth, context) {
    // value can be: array, expression, enum, pseudo-record, record, simple value

    if (Array.isArray(cAnnoValue))
    {
      if (isEnumType(dTypeName))
      {
        // if we find an array although we expect an enum, this may be a "flag enum"
        // oTarget.EnumMember = generateMultiEnumValue(cAnnoValue, dTypeName, context);
        checkMultiEnumValue(cAnnoValue, dTypeName, context);
        oTarget.setJSON({ "EnumMember@odata.type" : '#'+dTypeName, EnumMember: generateMultiEnumValue(cAnnoValue, dTypeName, false) });
        oTarget.setXml({ "EnumMember": generateMultiEnumValue(cAnnoValue, dTypeName, true) });

      }
      else
      {
        oTarget.append(generateCollection(cAnnoValue, oTermName, dTypeName, depth+1, context));
      }
    }
    else if (cAnnoValue && typeof cAnnoValue === 'object') {
      if (Object.keys(cAnnoValue).length == 0) {
        errorMessage(context, "empty record");
      }
      else if ("=" in cAnnoValue) {
        let res = handleExpression(cAnnoValue["="], dTypeName, context);
        oTarget[res.name] = res.value;
      }
      else if (cAnnoValue["#"] != undefined)
      {
        if (dTypeName)
        {
          checkEnumValue(cAnnoValue["#"], dTypeName, context);
          oTarget.setJSON({ "EnumMember@odata.type" : '#'+dTypeName, EnumMember: cAnnoValue["#"] });
          oTarget.setXml({ "EnumMember": dTypeName + "/" + cAnnoValue["#"] });
        }
        else
        {
          oTarget.setJSON({ "EnumMember@odata.type" : '#'+oTermName + "Type/", EnumMember: cAnnoValue["#"] });
          oTarget.setXml({ "EnumMember": oTermName + "Type/" + "/" + cAnnoValue["#"] });
        }
      }
      else if (cAnnoValue["$value"]) {
        // "pseudo-structure" used for annotating scalar annotations
        handleValue(cAnnoValue["$value"], oTarget, oTermName, dTypeName, depth, context);

        let k = Object.keys(cAnnoValue).filter( x => x.charAt(0) == "@");
        if (!k || k.length == 0) {
          errorMessage(context, "pseudo-struct without nested annotation");
        }
        for (let nestedAnnoName of k) {
          let nestedAnno = handleTerm(nestedAnnoName.slice(1), cAnnoValue[nestedAnnoName], context);
          oTarget.append(nestedAnno);
        }
      }
      else if (cAnnoValue["$edmJson"]) {
        // "pseudo-structure" used for embedding a piece of JSON that represents "OData CSDL, JSON Representation"
        oTarget.append(handleEdmJson(cAnnoValue["$edmJson"], context));
      }
      else {
        // regular record
        oTarget.append(generateRecord(cAnnoValue, oTermName, false, dTypeName, depth+1, context));
      }
    }
    else {
      let res = handleSimpleValue(cAnnoValue, dTypeName, context);
      oTarget[res.name] = res.value;
    }
  }


  // cAnnoValue: array
  // dTypeName: expected type, already identified as enum type
  //   array is expected to contain enum values
  function checkMultiEnumValue(cAnnoValue, dTypeName, context) {
    // we know that dTypeName is not null
    let type = g_dict.types[dTypeName];
    if (!type || type["IsFlags"] != "true") {
      errorMessage(context, "enum type '" + dTypeName + "' doesn't allow multiple values");
    }

    let index = 0;
    for (let e of cAnnoValue) {
      context.stack.push("[" + index++ + "]");
      if (e["#"]) {
        checkEnumValue(e["#"], dTypeName, context);
      }
      else {
        // TODO improve message: but found ...
        errorMessage(context, "expected an enum value");
      }
      context.stack.pop();
    }
  }

  function generateMultiEnumValue(cAnnoValue, dTypeName, forXml=true)
  {
    // remove all invalid entries (error message has already been issued)
    // replace short enum name by the full name
    // concatenate all the enums to a string, separated by spaces
    return cAnnoValue.filter( x => x["#"] != undefined ).map( x => (forXml ? dTypeName + "/" : "") + x["#"] ).join(forXml ? ' ' : ',');
  }


  // obj:       object representing the record
  // dictRecordTypeName : name of the expected record type according to vocabulary, may be null
  // 
  // can be called for a record directly below a term, or at a deeper level
  //   if the corresponding complex type is unique, it needs not to be written into the
  //   record; if it is abstract or part of a type hierarchy, it must be written
  //   into the record as attribute "Type"
  function generateRecord(obj, termName, inCollection, dictRecordTypeName, depth, context) {
    let newRecord = Edm.Record.create(v);
    let actualTypeName = null;

    if (dictRecordTypeName && !isComplexType(dictRecordTypeName)) {
      errorMessage(context, "found complex type, but expected type '" + dictRecordTypeName + "'");
      return newRecord;
    }

    if (obj["$Type"]) {
      // type is explicitly specified
      actualTypeName = obj["$Type"];
      if (g_dict.types[actualTypeName] == undefined) {
        // this type doesn't exist
        errorMessage(context, "explicitly specified type '" + actualTypeName + "' not found in vocabulary");
        newRecord.Type = actualTypeName;
      }
      else if (dictRecordTypeName && !isDerivedFrom(actualTypeName, dictRecordTypeName)) {
        // this type doesn't fit the expected one
        errorMessage(context, "explicitly specified type '" + actualTypeName
                            + "' is not derived from expected type '" + dictRecordTypeName + "'");
        actualTypeName = dictRecordTypeName;
        newRecord.Type = actualTypeName;
      }
      else if (isAbstractType(actualTypeName)) {
        // this type is abstract
        errorMessage(context, "explicitly specified type '" + actualTypeName + "' is abstract, specify a concrete type");
        actualTypeName = dictRecordTypeName;
        newRecord.Type = actualTypeName;
      }
      else {
        // ok
        if (actualTypeName != dictRecordTypeName || g_enforceRecordType) {
          newRecord.Type = actualTypeName;
        }
      }
    }
    else if (dictRecordTypeName) {
      // FIXME: Originally, we tried to find a best match, but this is no longer necessary (was disabled
      // by 'skipAnnosFindType'). This just leaves us with replacing UI.DataFieldAbstract with UI.DataField. We may
      // want to check if there are more candidates for that
      if (options.tntFlavor && !options.tntFlavor.skipAnnosDataFieldAbstract && dictRecordTypeName == "UI.DataFieldAbstract") {
        actualTypeName = "UI.DataField";
      }
      else {
        actualTypeName = dictRecordTypeName;
      }

      if (isAbstractType(dictRecordTypeName)) {
        errorMessage(context, "type '" + dictRecordTypeName + "' is abstract, use '$Type' to specify a concrete type");
        newRecord.Type = actualTypeName;
      }

      if (g_dict.types[actualTypeName] == undefined) {
        // TODO: test?
        errorMessage(context, "internal error: dictionary inconsistency, type '" + actualTypeName + "' not found");
      }

      // do not set Type attribute unless explicitly requested
      if (g_enforceRecordType || (options.tntFlavor && !options.tntFlavor.skipAnnosEnforceRecordType)) {
        newRecord.Type = actualTypeName;
      }
    }
    else if (depth == 1) {
      newRecord.Type = termName + "Type";
    }

    let dictProperties = getAllProperties(actualTypeName);

    // loop over elements
    for (let i in obj) {
      context.stack.push("." + i);

      if (i == "$Type") {
        // nop
      }
      else if (i.charAt(0) == "@") {
        let newAnno = handleTerm(i.substring(1, i.length), obj[i], context);
        newRecord.append(newAnno);
      }
      else {
        let dictPropertyTypeName = null;
        if (dictProperties) {
          dictPropertyTypeName = dictProperties[i];
          if (!dictPropertyTypeName){
            errorMessage(context, "record type '" + actualTypeName + "' doesn't have a property '" + i + "'");
          }
        }

        let newPropertyValue = Edm.PropertyValue.create(v, i);
        handleValue(obj[i], newPropertyValue, termName, dictPropertyTypeName, depth, context);
        newRecord.append(newPropertyValue);
      }

      context.stack.pop();
    }

    return newRecord;
  }


  // annoValue is an array
  // dTypeName : Collection(...) according to dictionary
  //
  function generateCollection(annoValue, termName, dTypeName, depth, context) {
    let newCollection = Edm.Collection.create(v);

    let innerTypeName = null;
    if (dTypeName) {
      var match = dTypeName.match(/^Collection\((.+)\)/);
      if (match) {
        innerTypeName = match[1];
      }
      else {
        errorMessage(context, "found collection value, but expected non-collection type " + dTypeName);
      }
    }

    let index = 0;
    for (let value of annoValue) {
      context.stack.push("[" + index++ + "]");

      if (Array.isArray(value)) {
        errorMessage(context, "nested collections are not supported");
      }
      else if (value && typeof value === 'object') {
        if (value["="]) {
          let res = handleExpression(value["="], innerTypeName, context);
          let newPropertyPath = Edm.ValueThing.create(v, res.name, res.value );
          newCollection.append(newPropertyPath);
        }
        else if (value["#"]) {
          // TODO test
          errorMessage(context, "collections of enums are not yet supported");
        }
        else {
          let rec = generateRecord(value, termName, true, innerTypeName, depth+1, context);
          newCollection.append(rec);
        }
      }
      else {
        let res = handleSimpleValue(value, innerTypeName, context);
        let newThing = Edm.ValueThing.create(v, res.name, value );
        newCollection.append(newThing);
      }

      context.stack.pop();
    }

    return newCollection;
  }

  function handleEdmJson(obj, context) 
  {
    let specialProperties = [ '$Apply', '$LabeledElement' ];
    let subset = glue.intersect(specialProperties, Object.keys(obj));
    
    if(subset.length > 1) { // doesn't work for three or more...
      errorMessage(context, "edmJson code contains more than one special property: " + subset);
      return null;
    }
    if(subset.length == 0) {
      // only one property (that is not a special property)
      if (Object.keys(obj) != undefined && Object.keys(obj).length==1) {
        let k = Object.keys(obj)[0];
        return Edm.ValueThing.create(v, k.slice(1), obj[k] );
      }
      errorMessage(context, "edmJson code contains no special property  out of: " + specialProperties);
      return null;
    }

    // name of special property determines element kind
    let newElem = Edm.Thing.create(v, subset[0].slice(1));
    let mainAttribute = null;

    for (let p in obj) {
      // copy all '$' attributes that are not $Apply or $LabeledElement to Thing
      if(specialProperties.every(v => 
        { return p != v })) 
      {
        if (p.charAt(0) == "$") {
          // simple attribute
          newElem[p.slice(1)] = obj[p];
        }
      } 
      else { // we are either $Apply or $LabeledElement
        // handle value of special property
        let val = obj[p];
        if (Array.isArray(val)) {
          for (let a of val) {
            if (a && typeof a === 'object') {
              newElem.append(handleEdmJson(a, context));
            }
            else if (Array.isArray(a)) {
              errorMessage(context, "verbatim code contains nested array");
            }
            else {
              if (typeof a === 'string') {
                a = a.replace(/&/g, '&amp;')
              }
              newElem.append(Edm.ValueThing.create(v, getTypeName(a),  a));
            }
          }
        }
        else if (val && typeof val === 'object') {
          if (Object.keys(val) != undefined && Object.keys(val).length==1) {
            let k = Object.keys(val)[0];
            mainAttribute = { name: k.slice(1), val: val[k] };
          }
          else {
            let el = handleEdmJson(val, context);
            if (el) {
              newElem.append(el);
            }
          }
        }
        else {
          mainAttribute = { name: getTypeName(val), val: val };
        }
      }
    }

    // special property has a simple value:
    //   value is added as attribute to the element; we add it
    //   only after the other attributes in order to reproduce order
    //   (which is semantically insignificant, but it's nicer this way)
    if (mainAttribute) {
      newElem[mainAttribute.name] = mainAttribute.val;
    }

    return newElem;

    function getTypeName(val) {
      let typeName = "String";
      if (typeof val === 'boolean') {
        typeName = "Bool";
      }
      else if (typeof val === 'number') {
        typeName = Number.isInteger(val) ? 'Int' : 'Decimal';
      }
      return typeName;
    }
  }

  // filter function, assumed to be used for array of string
  //   accepts those strings that start with a knwon vocabulary name
  function filterKnownVocabularies(name) {
    let knownVocabularies = ['Analytics', 'Core', 'Common', 'UI', 'Communication', 'Capabilities', 'Measures'];
    var match = name.match(/^(@)(\w+)/);
    if (match == null) return false;
    return knownVocabularies.includes(match[2]);  // second match group
  }



  //-------------------------------------------------------------------------------------------------
  //-------------------------------------------------------------------------------------------------
  //-------------------------------------------------------------------------------------------------

  // resolve "derived types"
  // -> if dTypeName is a TypeDefinition, replace by
  //    underlying type
  function resolveType(dTypeName) {
    let type = g_dict.types[dTypeName];
    if (type && type.UnderlyingType && type["$kind"] == "TypeDefinition") {
      return type.UnderlyingType;
    }
    return dTypeName;
  }

  function isPrimitiveType(typeName) {
    return typeName.split('.')[0] == "Edm";
  }

  function isEnumType(dTypeName) {
    let type = g_dict.types[dTypeName];
    return type && type["$kind"] == "EnumType";
  }

  function isComplexType(dTypeName) {
    let type = g_dict.types[dTypeName];
    return type && type["$kind"] == "ComplexType";
  }

  function isAbstractType(dTypeName) {
    let type = g_dict.types[dTypeName];
    return type && type["Abstract"] === "true";
  }

  // return true if derived has baseCandidate as direct or indirect base type
  function isDerivedFrom(derived, baseCandidate) {
    while (derived) {
      if (derived == baseCandidate) return true;
      derived = g_dict.types[derived].BaseType;
    }
    return false;
  }


  // return dictionary of all properties of typeName, including those of base types
  function getAllProperties(typeName) {
    if (!typeName || !g_dict.types[typeName]) return null;
    return g_dict.types[typeName].Properties;
  }
}

//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------
//-------------------------------------------------------------------------------------------------

module.exports = { csn2annotationEdm };
