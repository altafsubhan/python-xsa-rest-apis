'use strict';

const baseModel = require('../base/model');
const compactor = require('../json/compactor');
const deepCopy = require('../base/deepCopy');
const baseMessages = require('../base/messages');
const { isManagedAssociationElement, isStructuredElement, isAssociation,
        renameAnnotation, copyAnnotations, foreachPath } = require('../model/modelUtils');
const modelTransform = require('../model/transform');
const { mergeOptions } = require('../model/modelUtils');
const alerts = require('../base/alerts');

// New version of transform4odata. Expects an augmented 'inputModel', processes it for ODATA.
// The result should be suitable for consumption by EDMX processors (annotations and metadata)
// and also as a final CSN output for the ODATA runtime (when compacted).
// Performs the following transformations:
// - Flatten structured elements (and foreign keys of managed associations pointing to
//   keys that are themselves managed associations).
// - Generate foreign key fields for entities with managed associations (annotated with
//   '@odata.foreignKey4'). Propagate along projections accordingly. Names are built using
//   <assoc>_<key>, conflicts are checked. 
// - Complete the 'foreignKeys' property for all managed associations, so that there
//   is always a 'generatedFieldName' for the corresponding generated foreign key field.
// - Implicitly redirect associations based on exposure
// - Check that exposed associations do not point to non-exposed targets
// - Add an attribute '_service' to all artifacts that are exposed in a service (pointing to
//   the service artifact). This should be used by EDMX processors to detect exposed artifacts.
// - Unravel derived type chains, propagating annotations upwards.
// - Rename annotations according to a fixed list of short-hands
// Returns an (augmented) copy of 'inputModel' with the transformation applied. Does not change the original inputModel.
// Throws a CompilationError on errors. Warnings are stored in the result model.
function transform4odata(inputModel, options) {
  const { error, signal, getErrors } = alerts(inputModel);
  let model = deepCopy(inputModel);
  model.messages = inputModel.messages;
  options = mergeOptions(inputModel.options, options);
  model.options = options;
  const { flattenForeignKeys, createForeignKeyElement, checkForeignKeys,
          flattenStructuredElement, flattenStructStepsInPath, preprocessAction,
          setServiceProperty, checkExposedAssoc, toFinalBaseType, addImplicitRedirections } = modelTransform.getTransformers(model);
  // First walk through the model: perform preparations only
  // Set '_service' property for all artifacts and sub-artifacts, for each service in the model
  setServiceProperty(model);

  // Second walk through the model: Do the main part of the work
  baseModel.forEachDefinition(model, (artifact) => {
    // For entities and views only: Flatten structs (might result in new elements)
    if (artifact.kind == 'entity' || artifact.kind == 'view') {
      for (let elemName in artifact.elements) {
        let elem = artifact.elements[elemName];
        if (isStructuredElement(elem)) {
          // Remove the structured element, replace it by its flattened form
          delete artifact.elements[elemName];
          let flatElems = flattenStructuredElement(elem);
          for (let flatElemName in flatElems) {
            if (artifact.elements[flatElemName]) {
              signal(error`"${artifact.name.absolute}.${elemName}": Flattened struct element name conflicts with existing element: "${flatElemName}"`, elem.location);
            }
            artifact.elements[flatElemName] = flatElems[flatElemName];
             // FIXME: Should also adapt indexNo of the newly added elements and all subsequent ones
          }
        }
      }
    }
    // Types must not have anonymous structured elements
    else if (artifact.kind == 'type') {
      for (let elemName in artifact.elements) {
        let elem = artifact.elements[elemName];
        if (elem.elements) {
          signal(error`Element "${artifact.name.absolute}.${elemName}" has an anonymous structured type: this is not (yet) supported for ODATA`, artifact.location);
        }
      }
    }
    baseModel.forEachMemberRecursively(artifact, (member) => {
      // Unravel derived type chains for elements, actions, action parameters (propagating annotations)
      toFinalBaseTypeOData(member);
      toFinalBaseTypeOData(member.items);
      toFinalBaseTypeOData(member.returns);
      // Resolve annotation shorthands for elements, actions, action parameters
      renameShorthandAnnotations(member);
      // Generate foreign key elements for managed associations
      if (isManagedAssociationElement(member)) {
        // Flatten foreign keys (replacing foreign keys that are managed associations be their respective foreign keys)
        member.foreignKeys = flattenForeignKeys(member.foreignKeys);
        // Generate foreign key elements
        for (let name in member.foreignKeys) {
          let foreignKeyElement = createForeignKeyElement(member, member.foreignKeys[name]);
          toFinalBaseTypeOData(foreignKeyElement);
          // Propagate the association's annotations to the foreign key element
          // (Overwriting because they should win over the derived type unraveling)
          copyAnnotations(member, foreignKeyElement, true);
        }
      }
      // Entities only: Flatten structs used in paths
      if (artifact.kind == 'entity') {
        foreachPath(member, (path, pathOwner) => {
          pathOwner.path = flattenStructStepsInPath(path);
        });
      }
    });
    // Unravel derived type chains for types and annotations (propagating annotations)
    if (artifact.kind != 'entity') {
      toFinalBaseTypeOData(artifact);
      toFinalBaseTypeOData(artifact.items);
    }
    // If the artifact is a derived structured type, unravel that as well
    if (artifact.kind == 'type' && artifact.type && artifact.type._artifact.elements) {
      // Take the final type's elements
      // FIXME: Actually, we should deep-copy here and adapt _parent, _main, name , ...
      artifact.elements = artifact.type._artifact.elements;
      // The artifact's type is now 'cds.struct', which is not shown
      delete artifact.type;
    }
    // Resolve annotation shorthands for entities, types, annotations, ...
    renameShorthandAnnotations(artifact);

    // Replace the type of 'node' with its final base type, collecting all annotations on the way
    // (from least to most derived, i.e. giving precedence to those higher in the type chain).
    // Complain if 'node' does not have a type (e.g. expressions as select items)
    function toFinalBaseTypeOData(node) {
      if (node && node.kind == 'element' && !node._finalType) { // not a good test...
        signal(error`Element "${node.name.absolute}.${node.name.element}" does not have a type: Elements of ODATA entities must have a type`, node.location);
      }
      toFinalBaseType(node);
    }
  });

  // Perform implicit redirection of non-exposed association targets
  addImplicitRedirections(model);

  // Third walk through the model: Now all artificially generated things are in place
  var illV2Prefix = RegExp('^(_|[0-9])');
  baseModel.forEachDefinition(model, artifact => {
    if (artifact.kind == 'entity') {
      for (let elemName in artifact.elements) {
        let elem = artifact.elements[elemName];
        // Check for valid foreign keys
        if (isAssociation(elem.type)) {
          checkForeignKeys(elem);
        }
      }
    }
    baseModel.forEachMemberRecursively(artifact, member => {
      // Check that exposed associations do not point to non-exposed targets
      if (artifact._service && isAssociation(member.type))
        checkExposedAssoc(artifact, member);
    });

    // preprocess bound action/function
    if (artifact.kind === 'entity' && artifact.actions && artifact._service)
      Object.keys(artifact.actions).forEach(actName => preprocessAction(artifact.actions[actName]));

      // preprocess unbound action/function
    if ((artifact.kind === 'action' || artifact.kind === 'function') && artifact._service)
      preprocessAction(artifact);

    // Perform checks for exposed non-abstract entities and views
    if (artifact._service && !artifact.abstract && (artifact.kind == 'entity' || artifact.kind == 'view')) {
      let keyCount = 0;
      let mediaTypes = [];
      // Walk the elements
      for (let elemName in artifact.elements) {
        let elem = artifact.elements[elemName];

        // For ODATA V2, element names must not start with digit or '_'
        if (options.odataVersion == 'v2') {
          if (illV2Prefix.test(elemName)) {
            signal(error`"${artifact.name.absolute}.${elemName}: Element name must not begin with '${elemName[0]}' for OData V2`, elem.location);
          }
        }

        // Count keys and elements annotated with @Core.MediaType
        if (elem.key != undefined) {
          keyCount++;
        }
        if (elem['@Core.MediaType']) {
          mediaTypes.push([elemName, elem]);
        }
      }

      // Exposed non-abstract entities must have a key
      if (keyCount == 0) {
        signal(error`Entity "${artifact.name.absolute}" does not have a key: ODATA entities must have a key`, artifact.location);
      }

      // Additional checks for ODATA V2 regarding remaining keys
      if (options.odataVersion == 'v2') {
        // Elements that are annotated with @Core.HasStream are removed from the entity type.
        // If these are all keys then this would end up with a key-less EntityType wich is illegal in V2
        let mtkeys = mediaTypes.filter(e=>e[1].key);
        if (mtkeys.length > 0 && keyCount == mtkeys.length) {
          signal(error`"${artifact.name.absolute}: Key elements [${mtkeys.map(e=>e[0]).join(', ')}] annotated with '@Core.MediaType' are removed from Odata V2 resulting in keyless EntityType`, artifact.location);
        }
        // Today only one MediaType is allowed in V2
        if (mediaTypes.length > 1) {
          signal(error`"${artifact.name.absolute}: Elements [${mediaTypes.map(e=>e[0]).join(', ')}] annotated with '@Core.MediaType', OData V2 allows only one`, artifact.location);
        }
      }

      // Check media type compatibility for all OData versions
      let allowedTypes = ['cds.String', 'cds.Binary', 'cds.LargeBinary'];
      mediaTypes.forEach(e => {
        if (!allowedTypes.includes(e[1]._finalType.type._artifact.name.absolute)) {
          signal(error`"${artifact.name.absolute}.${e[0]}": Element annoted with '@Core.MediaType' must be of either type "${allowedTypes.join(', ')}"`, e[1].location);
        }
      });
    }
  });

  // Throw up if we have errors
  let errors = getErrors();
  if (errors.length > 0) {
    throw new baseMessages.CompilationError(baseMessages.sortMessages(errors), model);
  }
  return model;
}

// Rename shorthand annotations within artifact or element 'node' according to a builtin
// list.
function renameShorthandAnnotations(node) {
  // FIXME: Verify this list - are they all still required? Do we need any more?
  const mappings = {
    '@label': '@Common.Label',
    '@title': '@Common.Label',
    '@ValueList.entity': '@Common.ValueList.entity',
    '@ValueList.type': '@Common.ValueList.type',
    '@Capabilities.Deletable': '@Capabilities.DeleteRestrictions.Deletable',
    '@Capabilities.Insertable': '@Capabilities.InsertRestrictions.Insertable',
    '@Capabilities.Updatable': '@Capabilities.UpdateRestrictions.Updatable',
    '@readonly': '@Core.Immutable',
  }

  for (let name in node) {
    // Rename according to map above
    if (mappings[name] != undefined) {
      renameAnnotation(node, name, mappings[name]);
    }

    // Special case: '@important: [true|false]' becomes '@UI.Importance: [#High|#Low]'
    if (name == '@important') {
      renameAnnotation(node, name, '@UI.Importance');
      let annotation = node['@UI.Importance'];
      annotation.literal = 'enum';
      annotation.symbol = {
        // Note that an original '@important' without ': true' shows up as undefined value here!!
        id: (annotation.val == undefined || annotation.val == true) ? 'High' : 'Low',
      };
      // FIXME: Strangely, enum-valued annotations have no value
      delete annotation.val;
    }
  }
}

// Return an array of service names contained in (augmented or compacted) 'model''
function getServiceNames(model) {
  let resultDict = Object.create(null);
  baseModel.forEachDefinition(model, (artifact, artifactName) => {
    if (artifact.kind == 'service') {
      resultDict[artifactName] = artifact;
    }
  });
  return Object.keys(resultDict);
}

// Post-process an augmented CSN model 'model' that has been produced by 'transform4odata' so that it
// looks like the original (compacted) output of the '4odata' transformation'.
// If 'serviceName' is provided, only artifacts from this service are considered for the output.
// Most of this should not be necessary once we adapt the EDMX generation to use augmented CSN.
// Currently this involves the following steps:
// - Convert to compact CSN
//   => EDMX processors should actually use augmented CSN
// - Keep only exposed artifacts
//   => EDMX processors should instead look only at those artifacts in augmented CSN that have '_service'
// - Filter out everything but the one service selected
//   => EDMX processors should handle this based on '_service', too
// Return a (compacted) copy of 'model' with the transformation applied. Do not change the original model.
function postProcessForBackwardCompatibility(model, serviceName=undefined) {
  // Compact the model
  let compactedModel = (model.options.testMode) ? compactor.compactSorted(model) : compactor.compact(model);
  baseModel.setProp(compactedModel, 'messages', model.messages);

  // Iterate artifact definitions on the augmented model, but modify the compacted one in parallel
  baseModel.forEachDefinition(model, (artifact, artifactName) => {
    // Remove artifacts that are not exposed
    if (!artifact._service) {
      delete compactedModel.definitions[artifactName];
      return;
    }
    // Ignore if not part of specified service (if any)
    if (serviceName != undefined && serviceName != artifact._service.name.absolute) {
      delete compactedModel.definitions[artifactName];
      return;
    }
  });
  return compactedModel;
}

module.exports = {
  transform4odata,
  getServiceNames,
  postProcessForBackwardCompatibility,
}
