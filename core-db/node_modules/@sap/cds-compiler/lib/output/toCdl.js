"use strict";

const { CompilationError, sortMessages } = require('../base/messages');
const outputUtils = require('./outputUtils');
const { mergeOptions, getTopLevelArtifactNameOf } = require('../model/modelUtils');
const alerts = require('../base/alerts');

// Render the CSN model 'model' to CDS source text. One source is created per
// top-level artifact. Return a dictionary of top-level artifacts
// by their names, like this:
// { "foo" : "using XY; context foo {...};",
//   "bar::wiz" : "namespace bar::; entity wiz {...};"
// }
// If 'options.toHana' is set, render HANA-ish source dialect (currently
// only affects translation of '$self.foo' in paths and ::-ish namespace declarations)
function toCdsSource(model, options) {
  const { getErrors } = alerts(model);
  // Merge options (arguments first, then model options)
  options = mergeOptions(model.options, options);
  let flatNames = options.toHana && options.toHana.names == 'flat';
  let result = Object.create(null);

  const { renderExpressionOrCondition, renderJoinOp } = outputUtils.getOutputUtils(model, options, {
    renderPathOrValue,
    renderQuery,
    increaseIndent,
    decreaseIndent,
  });

  // Render each top-level artifact on its own
  for (let artifactName in getTopLevelArtifacts(model.definitions)) {
    // This environment is passed down the call hierarchy, for dealing with
    // indentation and name resolution issues 
    let env = {
      // Current indentation string
      indent: '',
      // Dictionary of aliases for used artifact names, each entry like 'name' : { quotedName, quotedAlias }
      topLevelAliases: Object.create(null),
      // Current name prefix (including trailing dot if not empty)
      namePrefix: ''
    }
    let sourceStr = renderArtifact(model.definitions[artifactName], env); // Must come first because it populates 'env.topLevelAliases'
    if (sourceStr != '') {
      result[flatNames ? uppercaseAndUnderscore(artifactName) : artifactName]
        = renderNamespaceDeclaration(artifactName, env) + renderUsings(env) + sourceStr;
    }
  }
  // Throw up if we have errors
  let errors = getErrors();
  if (errors.length > 0) {
    throw new CompilationError(sortMessages(errors), model);
  }
  return result;

  // Render an artifact. Return the resulting source string.
  function renderArtifact(art, env) {
    // Ignore whole artifacts if toHana says so
    if (art._ignore) {
      return '';
    }
    switch (art.kind) {
      case 'entity':
        if (art.source) {
          return renderProjection(art, env);
        } else {
          return renderEntity(art, env);
        }
      case 'view':
        return renderView(art, env);
      case 'context':
      case 'service':
        return renderContext(art, env);
      case 'namespace':
        return renderNamespace(art, env);
      case 'type':
      case 'annotation':
        return renderTypeOrAnnotation(art, env);
      case 'action':
      case 'function':
        return renderActionOrFunction(art, env);
      default:
        throw new Error('Unknown artifact kind: ' + art.kind);
    }
  }

  // Render a context or service. Return the resulting source string.
  function renderContext(art, env) {
    let result = renderAnnotationAssignments(art, env);
    let childEnv = increaseIndent(env);
    result += env.indent + art.kind + ' ' + env.namePrefix + quoteId(art.name.id) + ' {\n';
    for (let name in art.artifacts) {
      result += renderArtifact(art.artifacts[name], childEnv);
    }
    return result + env.indent + '};\n';
  }

  // Render a namespace. Return the resulting source string.
  function renderNamespace(art, env) {
    // We currently do not render anything for a namespace, we just append its id to
    // the environment's current name prefix and descend into its children
    let result = '';
    let childEnv = addNamePrefix(env, art.name.id);
    for (let name in art.artifacts) {
      result += renderArtifact(art.artifacts[name], childEnv);
    }
    return result;
  }

  // Render a (non-projection, non-view) entity. Return the resulting source string.
  function renderEntity(art, env) {
    let result = renderAnnotationAssignments(art, env);
    let childEnv = increaseIndent(env);
    result += env.indent + (art.abstract ? 'abstract ' : '') + 'entity ' + renderArtifactName(env, art);
    result += (art.impl ? ' implemented in ' + quoteId(art.impl.id) : '');
    let parameters = Object.keys(art.params || []).map(name => renderParameter(art.params[name], childEnv)).join(',\n');
    result += (parameters == '') ? '' : '(\n' + parameters + '\n' + env.indent + ')';
    if (art.includes) {
      result += ' : ' + art.includes.map(name => renderAbsoluteNameWithQuotes(name.absolute, art, env)).join(', ');
    }
    result += ' {\n';
    for (let name in art.elements) {
      result += renderElement(art.elements[name], childEnv);
    }
    result += env.indent + '}';
    result += renderActionsAndFunctions(art, env) + renderTechnicalConfiguration(art, env) + ';\n';

    // Render additional annotation assignments that were produced via 'annotate' on inherited elements
    // FIXME: Actually, this attempts to undo propagation ... not ideal
    let allElementAnnotationAssignments = '';
    for (let name in art.elements) {
      let elm = art.elements[name];
      // Ignore if toHana says so, or if not inherited
      if (elm._ignore || !elm.origin) {
        continue;
      }
      let elementAnnotationAssignments = '';
      for (let annoName in elm) {
        if (annoName.startsWith('@')) {
          let elementAnnotationAssignment = renderAnnotationAssignment(elm[annoName], annoName, childEnv);
          let originAnnotation = elm._origin && elm._origin._artifact[annoName];
          // If this annotation was not present or different in the origin (i.e. "superclass") element,
          // it must be the result of an 'annotate' on the inheriting entity
          if (!originAnnotation || elementAnnotationAssignment != renderAnnotationAssignment(originAnnotation, annoName, childEnv)) {
            elementAnnotationAssignments += elementAnnotationAssignment;
          }
        }
      }
      if (elementAnnotationAssignments != '') {
        allElementAnnotationAssignments += elementAnnotationAssignments + childEnv.indent + quoteId(name) + ';\n'
      }
    }
    if (allElementAnnotationAssignments != '') {
      result += env.indent + 'annotate ' + env.namePrefix + quoteId(art.name.id) + ' {\n'
             + allElementAnnotationAssignments + env.indent + '}\n';
    }

    return result;
  }

  // Render an element (of an entity, type or annotation, not a projection or view).
  // Return the resulting source string.
  function renderElement(elm, env, ignoreInherited=true) {
    // Ignore if toHana says so, or if inherited
    if (elm._ignore || (ignoreInherited && elm.origin)) {
      return '';
    }
    // Special handling for HANA CDS: Must omit the ':' before anonymous structured types (for historical reasons)
    let omitColon = (options.toHana && !elm.type && elm.elements);
    let result = renderAnnotationAssignments(elm, env);
    result += env.indent + (elm.virtual ? 'virtual ' : '') 
                         + (elm.key ? 'key ' : '')
                         + ((elm.masked && !elm._ignoreMasked)? 'masked ' : '')
                         + renderId(elm.name.id) + (omitColon ? ' ' : ' : ')
                         + renderTypeReference(elm, env)
                         + renderNullability(elm);
    if (elm.default) {
      result += ' default ' + renderPathOrValue(elm.default, env);
    }
    return result + ';\n';
  }

  // Render the 'technical configuration { ... }' section of an entity.
  // Return the resulting source string.
  function renderTechnicalConfiguration( art, env ) {
    let result = '';
    let childEnv = increaseIndent(env);

    let tc = art.technicalConfig;
    if (!tc) {
      return result;
    }

    result += '\n' + env.indent + 'technical ' + (!tc.backend.calculated ? renderPathOrValue(tc.backend, env) + ' ': '') + 'configuration {\n';

    if (tc.migration) {
      result += childEnv.indent + 'migration ' + renderPathOrValue(tc.migration, childEnv) + ';\n';
    }
    if (tc.storeType) {
      result += childEnv.indent + renderPathOrValue(tc.storeType, childEnv) + ' store;\n';
    }
    if (tc.extendedStorage) {
      result += childEnv.indent + 'using extended storage;\n';
    }
    if (tc.unloadPrio) {
      result += childEnv.indent + 'unload priority ' + renderPathOrValue(tc.unloadPrio, childEnv) + ';\n';
    }
    if (tc.autoMerge) {
      result += childEnv.indent + (tc.autoMerge.val == false ? 'no ' : '') + 'auto merge;\n';
    }

    if (tc.group) {
      result += childEnv.indent;
      if (tc.group.name) {
        result += 'group name ' + renderId(tc.group.name.id);
      }
      if (tc.group.name && tc.group.type) {
        result += ' ';
      }
      if (tc.group.type) {
        result += 'group type ' + renderId(tc.group.type.id);
      }
      if ((tc.group.name || tc.group.type) && tc.group.subType) {
        result += ' ';
      }
      if (tc.group.subType) {
        result += 'group subtype ' + renderId(tc.group.subType.id);
      }
      result += ';\n';
    }

    if (tc.indexes) {
      for (let idxName in tc.indexes) {
        let idx = tc.indexes[idxName];
        if (Array.isArray(idx)) {
          idx.forEach(i => result += renderIndex(i, childEnv));
        }
        else {
          result += renderIndex(idx, childEnv);
        }
      }
    }

    if (tc.fzindexes) {
      tc.fzindexes.forEach(fzi => {
        fzi.columns.filter(col => !col._ignore).forEach(col => {
          result += childEnv.indent + 'fuzzy search index on (' + renderPathOrValue(col) + ')';
          if (fzi.fuzzy) {
            result += ' fuzzy search mode';
            if (fzi.fuzzy.mode) {
              result += ' ' + renderPathOrValue(fzi.fuzzy.mode, childEnv);
            }
          }
          result += ';\n';
        });
      });
    }

    if (tc.partition) {
      result += childEnv.indent + 'partition by ';
      let i = 0;
      tc.partition.specs.forEach(p => {
        if (i > 0) {
          result += ', ';
        }
        result += renderPartition(p, childEnv);
        i++;
      });
      if (tc.partition.wpoac) {
        result += ' with partitioning on any columns ' + renderPathOrValue(tc.partition.wpoac, childEnv);
      }
      result += ';\n';
    }

    result += env.indent + '}';
    return result;

    // Render a partition spec of a technical configuration.
    function renderPartition(partition, env) {
      let result = renderPathOrValue(partition.scheme, env);
      if (partition.columns) {
        result += ' (';
        let i = 0;
        for (let column of partition.columns) {
          if (!column._ignore) {
            if (i > 0) {
              result += ', ';
            }
            if (column.unit) {
              result += renderPathOrValue(column.unit, env) + '(';
            }
            result += renderPathOrValue(column, env);
            if (column.unit) {
              result += ')';
            }
            i++;
          }
        }
        result += ') ';
      }
      if (partition.partitions) {
        result += ' partitions ' + renderPathOrValue(partition.partitions, env);
      }
      if (partition.ranges) {
        result += '(';
        let oppStore = (partition.ranges[0].store == 'default' ? 'extended' : 'default');
        let delimiter = false;

        partition.ranges.forEach((range, env) => {
          if (range.store != oppStore) {
            if (partition.withStorageSpec) {
              if (delimiter) {
                result += ') ';
              }
              result += 'using ' + range.store + ' storage (';
            }
            delimiter = false;
            oppStore = range.store;
          }
          if (delimiter) {
            result += ', ';
          }
          result += renderPartitionRange(range, env);
          delimiter = true;
        });
        if (partition.withStorageSpec) {
          result += ')';
        }
        result += ')';
      }
      return result;

      function renderPartitionRange(range, env) {
        let result = 'partition ';
        if (range.others) {
          return result + renderPathOrValue(range.others, env);
        }
        if (!range.max) {
          result += 'value = '
        }
        result += renderPathOrValue(range.min, env);
        if (range.isCurrent) {
          result += ' is current';
        }
        if (range.max) {
          result += ' <= values < ' + renderPathOrValue(range.max, env);
        }
        return result;
      }
    }

    function renderIndex(idx, env) {
      let childEnv = increaseIndent(env);
      let result = env.indent;
      if (idx.kind === 'index') {
        if (idx.unique) {
          result += 'unique ';
        }
        result += 'index ' + renderId(idx.name.id) + ' on (' + renderArray(idx.columns) + ')';
        if (idx.sort) {
          result += ' ' + renderPathOrValue(idx.sort, childEnv);
        }
      }
      else if (idx.kind === 'fulltextindex') {
        result += 'fulltext index ' + renderId(idx.name.id) + ' on (' + renderArray(idx.columns) + ')';
        if (idx.language) {
          if (idx.language.column) {
            result += '\n' + childEnv.indent + 'language column ' + renderPathOrValue(idx.language.column, childEnv);
          }
          if (idx.language.detection) {
            result += '\n' + childEnv.indent + 'language detection (' + renderArray(idx.language.detection) + ')'
          }
        }
        if (idx.mimeTypeColumn) {
          result += '\n' + childEnv.indent + 'mime type column ' + renderPathOrValue(idx.mimeTypeColumn, childEnv);
        }
        if (idx.fuzzySearchIndex) {
          result += '\n' + childEnv.indent + 'fuzzy search index ' + renderPathOrValue(idx.fuzzySearchIndex, childEnv);
        }
        if (idx.phraseIndexRatio) {
          result += '\n' + childEnv.indent + 'phrase index ratio ' + renderPathOrValue(idx.phraseIndexRatio, childEnv);
        }
        if (idx.configuration) {
          result += '\n' + childEnv.indent + 'configuration ' + renderPathOrValue(idx.configuration, childEnv);
        }
        if (idx.textAnalysis) {
          result += '\n' + childEnv.indent + 'text analysis ' + renderPathOrValue(idx.textAnalysis, childEnv);
        }
        if (idx.searchOnly) {
          result += '\n' + childEnv.indent + 'search only ' + renderPathOrValue(idx.searchOnly, childEnv);
        }
        if (idx.fastPreprocess) {
          result += '\n' + childEnv.indent + 'fast preprocess ' + renderPathOrValue(idx.fastPreprocess, childEnv);
        }
        if (idx.mimeType) {
          result += '\n' + childEnv.indent + 'mime type ' + renderPathOrValue(idx.mimeType, childEnv);
        }
        if (idx.tokenSeparators) {
          result += '\n' + childEnv.indent + 'token separators ' + renderPathOrValue(idx.tokenSeparators, childEnv);
        }
        if (idx.textMining) {
          if (idx.textMining.state) {
            result += '\n' + childEnv.indent + 'text mining ' + renderPathOrValue(idx.textMining.state, childEnv);
          }
          if (idx.textMining.config) {
            result += '\n' + childEnv.indent + 'text mining configuration ' + renderPathOrValue(idx.textMining.config, childEnv);
          }
          if (idx.textMining.overlay) {
            result += '\n' + childEnv.indent + 'text mining configuration overlay ' + renderPathOrValue(idx.textMining.overlay, childEnv);
          }
        }
        if (idx.changeTracking) {
          let ct = idx.changeTracking;
          result += '\n' + childEnv.indent + renderPathOrValue(ct.mode);
          if (ct.asyncSpec) {
            let asp = ct.asyncSpec;
            result += ' flush ';
            if (asp.queue) {
              result += renderPathOrValue(asp.queue, childEnv) + ' ';
            }
            if (asp.minutes) {
              result += 'every ' + renderPathOrValue(asp.minutes, childEnv) + ' minutes';
              if (asp.documents) {
                result += ' or ';
              }
            }
            if (asp.documents) {
              result += 'after ' + renderPathOrValue(asp.documents, childEnv) + ' documents';
            }
          }
        }
      }
      return result + ';\n';
    }

    function renderArray(arr) {
      let r = '', i = 0;
      arr.filter(v => !v._ignore).forEach(v => {
        if (i > 0) {
          r += ', '
        }
        r += renderPathOrValue(v, childEnv);
        if (v.sort) {
          r += ' ' + renderPathOrValue(v.sort, childEnv);
        }
        i++;
      });
      return r;
    }
  }

  // Render a projection entity. Return the resulting source string.
  function renderProjection(art, env) {
    let result = renderAnnotationAssignments(art, env);
    let childEnv = increaseIndent(env);
    result += env.indent + (art.abstract ? 'abstract ' : '') + 'entity ' + renderArtifactName(env, art);
    result += (art.impl ? ' implemented in ' + quoteId(art.impl.id) : '');
    result += ' as projection on ' + renderSourcePathWithAlias(art.source, art, env) + ' {\n';
    result += Object.keys(art.elements).map(name => renderViewOrProjectionElement(art.elements[name], childEnv))
                                       .filter(s => s != '')
                                       .join(',\n') + '\n';
    result += env.indent + '}';
    result += renderActionsAndFunctions(art, childEnv) + ';\n';

    // Magic special case: If fully fledged elements were extended into this projection
    // (recognizable by not having a value), we need to render them as extensions
    let extendedElements = '';
    for (let name of Object.keys(art.elements).filter(name => !art.elements[name].value)) {
      extendedElements += renderElement(art.elements[name], childEnv);
    }
    if (extendedElements != '') {
      result += env.indent + 'extend ' + env.namePrefix + quoteId(art.name.id) + ' with {\n';
      result += extendedElements;
      result += env.indent + '};\n';
    }
    return result;
  }

  // Render the source of a query, which may either be a path with an alias or a join operation,
  // as seen from artifact 'art'.
  // Returns the source as a string.
  function renderViewSource(source, art, env) {
    if (source instanceof Array) {
      // Join operations in parentheses
      if (source.length != 1) {
        throw new Error('Expecting only one join operation: ' + source);
      }
      return `(${renderViewSource(source[0], art, env)})`;
    } else if (source.op && source.op.val == 'join') {
      // One join operation, possibly with ON-condition
      let result = `${renderViewSource(source.args[0], art, env)} ${renderJoinOp(source.join)} ${renderViewSource(source.args[1], art, env)}`;
      if (source.on) {
        result += ` on ${renderExpressionOrCondition(source.on)}`;
      }
      return result;
    } else if (source.op && source.op.val  == 'query') {
      // sub-select
      let result = `(${renderQuery(source, art, false, increaseIndent(env))})`;
      if (source.name && !source.name.calculated) {
        // Source had an alias - render it
        result += ' as ' + renderId(source.name.id);
      }
      return result;
    } else {
      // Ordinary path, possibly with an alias
      return renderSourcePathWithAlias(source, art, env);
    }
  }

  // Render the source path of a projection or query, possibly with an alias, as seen from artifact 'art'.
  // Expects an object 'source' that has a 'path' and (in case of an alias) a 'name'. If the source path
  // is a top-level entity (those get renamed by artificial USINGs), an artificial alias is created to the
  // original name.
  // Returns the name and alias as a string.
  function renderSourcePathWithAlias(source, art, env) {
    // Sanity checks
    if (!source.path || source.path.length < 1) {
      throw new Error('Expecting path in source of ' + art.name.absolute + ': ' + JSON.stringify(source, null, 2));
    }
    if (!source._artifact) {
      throw new Error('Expecting source of ' + art.name.absolute + ' to be resolved: ' + JSON.stringify(source, null, 2));
    }
    if (!source.path[0]._artifact) {
      throw new Error('Expecting first path step in source of ' + art.name.absolute + ' to be resolved: ' + JSON.stringify(source, null, 2));
    }
    let result = '';
    let artificialAlias = undefined;
    // Special case: If we are rendering for HANA, and if 'source' is an artifact that is
    // 'implemented in' something, we need to treat the whole name like a top-level id
    // Note: the impl might also have been generated by toHana based on @cds.persistence.exists;
    //       we use impl to transport the info as the annotations have already been removed when arriving here
    if (options.toHana && source._artifact.impl) {
      result += renderEntityName(source._artifact.name.absolute, art, env);
      artificialAlias = source._artifact.name.id;
    } else {
      // Start with the absolute name of the first path step
      let i = 1;
      let firstPathStep = source.path[0];
      let absName = firstPathStep._artifact.name.absolute;
      if (flatNames) {
        // find the first main artifact in the path
        // start with i=1 since first path step cannot be an element
        // after the loop, i is the number of path steps that build the absolute name of the artifact
        // example: select from com.sap.ctx.ent.ass1.ass2 => com.sap.ctx.ent, i=4
        while (i<source.path.length && source.path[i]._artifact.kind != 'element') {
          absName = source.path[i]._artifact.name.absolute;
          firstPathStep = source.path[i];
          i++;
        }
        // we need an artificial alias, if name of main artifact consists of several parts
        //   (independent of how the path to the artifact is written in FROM)
        //   and there are no further element steps
        if (absName.indexOf('.')>=0 && source.path.length == i) {
          artificialAlias = source.path[i-1].id;
        }
      }
      else {
        // we need an artificial alias, if we have introduced an artificial name for the first
        //   path step (__something) && there are no further path steps
        if (source.path.length == 1 && getTopLevelArtifactNameOf(absName) == absName) {
          artificialAlias = source.path[0].id;
        }
      }
      result += renderEntityName(absName, art, env);
      // Even the first step might have a filter
      if (firstPathStep.filter) {
        result += '[' + (firstPathStep.cardinality ? firstPathStep.cardinality.targetMax.val + ': ' : '')
                      + renderExpressionOrCondition(firstPathStep.filter, env, true) + ']';
      }
      // Add any paths that may follow after that
      if (source.path.length > i) {
        result += '.' + renderPath(source.path.slice(i), env, art);
      }
    }

    // Take care of aliases
    // (Note that it is not sufficient to lool at 'calculated' here - the alias might come from a USING
    if (source.name && source.name.id != source._artifact.name.id) {
      // Source had an alias - render it
      result += ' as ' + renderId(source.name.id);
    } else if (artificialAlias) {
      // Source is a top-level artifact that got a USING via renderAbsoluteNameWithQuotes - render an
      // artificial alias to the original name
      result += ' as ' + renderId(artificialAlias);
    }
    return result;
  }

  // Render a single view or projection element 'elm', as it occurs in a select list or projection list,
  // possibly with annotations. Return the resulting source string (no trailing LF).
  function renderViewOrProjectionElement(elm, env) {
    // Ignore if toHana says so
    if (elm._ignore) {
      return '';
    }
    // Ignore if not actually a projection element (added as a fully-fledged element via extension)
    if (!elm.value) {
      return '';
    }
    let result = renderAnnotationAssignments(elm, env) + env.indent + renderExpressionOrCondition(elm.value, env, true);
    if (!elm.viaAll && !elm.name.calculated) {
      result += ' as ' + renderId(elm.name.id);
    }
    if (elm.redirected) {
      result += ' : redirected to ' + renderAbsoluteNameWithQuotes(elm.target.absolute, elm._main, env);
    } else if (elm._typeIsExplicit) {
      // Explicit type provided for the view element
      result += ' : ' + renderTypeReference(elm, env);
    }
    return result;
  }

  // Render a view
  function renderView(art, env) {
    let result = renderAnnotationAssignments(art, env);
    result += env.indent + 'view ' + renderArtifactName(env, art)
           + ' as ' + renderQuery(art.query, art, true, env);
    return result + ';\n';
  }

  // Render a query 'query', i.e. a select statement with where-condition etc, possibly as part of artifact 'art'.
  // If 'isLeadingQuery' is true, mixins, actions and functions of 'art' are also rendered into the query.
  // FIXME: currently only selection from multiple sources is supported, no JOIN yet, no UNION yet
  function renderQuery(query, art, isLeadingQuery, env) {
    let result = '';
    if (Array.isArray(query)) {
      result = `(${renderQuery(query[0], art, isLeadingQuery, env)})`;
    } else if (query.op.val == 'query') {
      let childEnv = increaseIndent(env);
      result += 'select from ' + query.from.map(source => renderViewSource(source, art, env)).join(', ');
      if (isLeadingQuery && query.mixin) {
        result += ' mixin {\n'
        for (let name in query.mixin) {
          result += renderElement(query.mixin[name], childEnv, false);
        }
        result += env.indent + '} into'
      }
      result += (query.distinct && query.distinct.val) ? ' distinct' : '';
      result += ' {\n' + Object.keys(query.elements).map(name => renderViewOrProjectionElement(query.elements[name], childEnv))
                                                    .filter(s => s != '')
                                                    .join(',\n') + '\n';
      result += env.indent + '}';
      // FIXME: I assume that views can have actions and functions, too (like entities and projections?)
      if (isLeadingQuery) {
        result += renderActionsAndFunctions(art, env);
      }
    } else if (query.op.val == 'subquery') {
      // Magic special case: Subquery in parentheses can have ORDER BY, LIMIT and OFFSET outside the parentheses.
      result += `(${renderQuery(query.args[0][0], art, isLeadingQuery, env)})`;
    } else if (['union', 'unionAll', 'intersect', 'except'].includes(query.op.val)) {
      // Ordinary query operators (first may be leading query)
      result += `${renderQuery(query.args[0], art, isLeadingQuery, env)}`
      result += `\n${env.indent}${query.op.val.replace('All', ' all')} ${renderQuery(query.args[1], art, false, env)}`;
    } else {
      throw new Error('Unexpected query operation ' + query.op.val);
    }
    if (query.where) {
      result += `${continueIndent(result, env)}where ${renderExpressionOrCondition(query.where, env)}`;
    }
    if (query.groupBy) {
      result += `${continueIndent(result, env)}group by ${query.groupBy.map(exprOrCond => renderExpressionOrCondition(exprOrCond, env)).join(', ')}`;
    }
    if (query.having) {
      result += `${continueIndent(result, env)}having ${renderExpressionOrCondition(query.having, env)}`;
    }
    if (query.orderBy) {
      result += `${continueIndent(result, env)}order by ${query.orderBy.map(entry => renderOrderByEntry(entry, env)).join(', ')}`;
    }
    if (query.limit) {
      result += `${continueIndent(result, env)}limit ${renderPathOrValue(query.limit, env)}`;
    }
    if (query.offset) {
      result += `${continueIndent(result, env)}offset ${renderPathOrValue(query.offset, env)}`;
    }
    return result;

    // Utility function to make sure that we continue with the same indentation in WHERE, GROUP BY, ... after a closing curly brace and beyond
    function continueIndent(result, env) {
      if (result.endsWith('}') || result.endsWith('})')) {
        // The preceding clause ended with '}', just append after that
        return ' ';
      } else {
        // Otherwise, start new line and indent normally
        return '\n' + increaseIndent(env).indent;
      }
    }
  }

  // Render one entry of a query's ORDER BY clause (which always has a 'value' expression, and may
  // have a 'sort' property for ASC/DESC and a 'nulls' for FIRST/LAST
  function renderOrderByEntry(entry, env) {
    let result = renderExpressionOrCondition(entry.value, env);
    if (entry.sort) {
      result += ` ${entry.sort.val}`;
    }
    if (entry.nulls) {
      result += ` nulls ${entry.nulls.val}`;
    }
    return result;
  }

  // Render an entity's actions and functions (if any)
  // (expect an entity with trailing '}' to have just been rendered).
  // Return the resulting source string.
  function renderActionsAndFunctions(art, env) {
    let result = ''
    let childEnv = increaseIndent(env);
    for (let name in art.actions) {
      result += renderActionOrFunction(art.actions[name], childEnv);
    }
    // Even if we have seen actions/functions, they might all have been ignored
    if (result != '') {
      result = ' actions {\n' + result + env.indent + '}';
    }
    return result;
  }

  // Render an action or function. Return the resulting source string.
  function renderActionOrFunction(act, env) {
    // Ignore if toHana says so, or if inherited
    if (act._ignore || act.origin) {
      return '';
    }
    let result = renderAnnotationAssignments(act, env) + env.indent + act.kind + ' ' + env.namePrefix + quoteId(act.name.id);
    let childEnv = increaseIndent(env);
    let parameters = Object.keys(act.params || []).map(name => renderParameter(act.params[name], childEnv)).join(',\n');
    result += (parameters == '') ? '()' : '(\n' + parameters + '\n' + env.indent + ')';
    if (act.returns) {
      result += ' returns ' + renderTypeReference(act.returns, env);
    }
    result += ';\n';
    return result;
  }

  // Render an action or function parameter. Return the resulting source string (no trailing LF).
  function renderParameter(par, env) {
    let result = renderAnnotationAssignments(par, env) + env.indent + quoteId(par.name.id) + ' : ' + renderTypeReference(par, env);
    result += renderNullability(par);
    return result;
  }

  // Render a type (derived or structured) or an annotation decl.
  // Return the resulting source string.
  function renderTypeOrAnnotation(art, env) {
    let result = renderAnnotationAssignments(art, env) + env.indent + art.kind + " " + env.namePrefix + quoteId(art.name.id);
    if (art.includes) {
      result += ' : ' + art.includes.map(name => renderAbsoluteNameWithQuotes(name.absolute, art, env)).join(', ');
    }
    let childEnv = increaseIndent(env);
    if (art.elements) {
      // Structured type or annotation with anonymous struct type
      result += " {\n";
      for (let name in art.elements) {
        result += renderElement(art.elements[name], childEnv);
      }
      result += env.indent + '};\n';
    } else {
      // Derived type or annotation with non-anonymous type
      result += " : " + renderTypeReference(art, env) + ';\n';
    }
    return result;
  }

  // Render a reference to a type used by 'elm' (named or inline)
  function renderTypeReference(elm, env) {
    let result = '';

    // Array type: Render items instead
    if (elm.items) {
      return 'array of ' + renderTypeReference(elm.items, env);
    }

    // FIXME: Is this a type attribute?
    result += (elm.localized ? 'localized ' : '');

    // Anonymous structured type
    if (!elm.type) {
      if (!elm.elements) {
        throw new Error('Missing type of: ' + elm.name.id);
      }
      result += '{\n';
      let childEnv = increaseIndent(env);
      for (let name in elm.elements) {
        result += renderElement(elm.elements[name], childEnv);
      }
      result += env.indent + '}'
      return result;
    }

    // Association type
    if (elm.type.absolute == 'cds.Association' || elm.type.absolute == 'cds.Composition') {
      // Type, cardinality and target
      result += elm.type.absolute == 'cds.Association' ? 'association' : 'composition';
      result += renderCardinality(elm.cardinality) + (elm.type.absolute == 'cds.Association' ? ' to ' : ' of ');
      result += renderEntityName(elm.target.absolute, elm._main, env);

      // ON-condition (if any)
      if (elm.onCond) {
        result += ' on ' + renderExpressionOrCondition(elm.onCond, env);
      }

      // Foreign keys (if any)
      if (elm.foreignKeys && !elm.implicitForeignKeys) {
        result += ' { ' + Object.keys(elm.foreignKeys).map(name => renderForeignKey(elm.foreignKeys[name], env)).join(', ') + ' }';
      }
      return result;
    }

    // If we get here, it must be a named type
    if (elm.type._artifact.builtin) {
      // cds.Integer => render as Integer (no quotes)
      result += elm.type.absolute.replace(/^cds\./, '');
    } else if (elm.type._artifact.kind == 'element') {
      // Path descending into an element - render as is
      // FIXME: Should this be allowed at all?
      result += renderAbsoluteNameWithQuotes(elm.type.absolute + '.' + elm.type.element, elm._main, env);
    } else {
      // Simple absolute path
      result += renderAbsoluteNameWithQuotes(elm.type.absolute, elm._main, env);
    }
    result += renderTypeParameters(elm);
    if (elm.enum) {
      result += ' enum {\n';
      let childEnv = increaseIndent(env);
      for (let name in elm.enum) {
        let enumConst = elm.enum[name];
        result += renderAnnotationAssignments(enumConst, childEnv);
        let enumValue = enumConst.value || { literal: 'string', val: name};
        result += childEnv.indent + quoteId(name) + ' = ' + renderPathOrValue(enumValue, childEnv) + ';\n';
      }
      result += env.indent + '}';
    }

    return result;
  }

  // Render a cardinality (only those parts that were actually provided)
  function renderCardinality(card /* , env */) {
    if (!card) {
      return '';
    }
    let result = '[';
    if (card.sourceMax) {
      result += card.sourceMax.val + ', ';
    }
    if (card.targetMin) {
      result += card.targetMin.val + '..';
    }
    if (card.targetMax) {
      result += card.targetMax.val;
    }
    return result + ']';
  }

  // Render the nullability of an element or parameter (can be unset, true, or false) 
  function renderNullability(obj /* , env */) {
    if (!obj.notNull) {
      // Attribute not set at all
      return '';
    }
    return obj.notNull.val ? ' not null' : ' null';
  }

  // Render a foreign key (no trailing LF)
  function renderForeignKey(fkey, env) {
    if (fkey.name.calculated) {
      return renderPath(fkey.targetElement.path, env);
    } else {
      return renderPath(fkey.targetElement.path, env) + ' as ' + quoteId(fkey.name.id);
    }
  }

  // Render (primitive) type parameters of element 'elm', i.e. 
  // length, precision and scale (even if incomplete), plus any other unknown ones.
  function renderTypeParameters(elm /*, env */) {
    let params = [];
    // Length, precision and scale (even if incomplete)
    if (elm.length) {
      params.push(elm.length.val);
    }
    if (elm.precision) {
      params.push(elm.precision.val);
    }
    if (elm.scale) {
      params.push(elm.scale.val);
    }
    // Additional type parameters
    for (let arg of elm.typeArguments || []) {
      params.push(arg.val);
    }
    return params.length == 0 ? '' : '(' + params.join(', ') + ')';
  }

  // Render all annotation assignments of annotatable object 'obj'
  function renderAnnotationAssignments(obj, env) {
    let result = '';
    for (let name in obj) {
      if (name.startsWith('@')) {
        result += renderAnnotationAssignment(obj[name], name, env);
      }
    }
    return result;
  }

  // Render a single annotation assignment 'ann' with fully qualified name 'name' (no trailing LF).
  function renderAnnotationAssignment(ann, name, env) {
    // FIXME: Should not actually need the 'name' argument and use the absolute name instead,
    // but the compiler does not provide that yet
    let result = env.indent + '@' + renderAbsoluteNameWithQuotes(name.substring(1), null, env) + ' : ';
    if (ann.literal || ann.path) {
      result += renderPathOrValue(ann, env);
    } else {
      result += 'true';
    }
    return result  + '\n';
  }

  // Render a single value (i.e. something that has 'path' or 'literal' and 'val')
  // (no trailing LF, don't indent if inline)
  function renderPathOrValue(v, env, inline=true) {
    let result = inline ? '' : env.indent;
    if (v.path) {
      // E.i
      return result + renderPath(v.path, env, v);
    } else if (v.literal == 'string') {
      // 'foo', with proper escaping
      return result + "'" + v.val.replace(/'/g, "''") + "'";
    } else if (v.literal == 'enum') {
      // #foo
      return result + '#' + v.symbol.id;
    } else if (v.literal == 'hex') {
      // x'f000'
      return result + "x'" + v.val + "'";
    } else if (v.literal == 'date' || v.literal == 'time' || v.literal == 'timestamp') {
      // date'2017-11-02'
      return result + v.literal + "'" + v.val + "'";
    } else if (v.literal == 'struct') {
      // { foo: 1 }
      let childEnv = increaseIndent(env);
      return result + '{\n'
                    + Object.keys(v.struct).map(name => childEnv.indent + quoteId(name)
                    + ': ' + renderPathOrValue(v.struct[name], childEnv)).join(',\n')
                    +'\n' +  env.indent + '}';
    } else if (v.literal == 'array') {
      // [ 'foo', 'bar' ]
      let childEnv = increaseIndent(env);
      return result + '[\n'
                    + v.val.map(v => renderPathOrValue(v, childEnv, false)).join(',\n')
                    + '\n' + env.indent + ']';
    } else {
      // 17.42, null, true
      return result + String(v.val);
    }
  }

  // Render a path or query path (provided as an array of path steps, possibly with filters)
  function renderPath(path, env, art) {
    // Magic special case: SQL functions that have no parentheses (CURRENT_*) are not recognized as
    // function expressions by the parser - instead they appear here as paths of length 1 with a
    // 'builtin' artifact.
    if (path.length == 1 && path[0]._artifact && path[0]._artifact.kind == 'builtin') {
      if (options.toHana) {
        // HANA-specific translation of '$now' and '$user'
        // FIXME: This should rather happen in forHana, but it is non-trivial to catch all the different
        // flavors in which a path can be used there (e.g. for 'foo.origin.path', we would have to modify
        // 'foo' to have a 'foo.value'). So much easier to do it here...
        if (path[0].id == '$now') {
          return 'CURRENT_TIMESTAMP';
        } else if (path[0].id == '$user') {
          return "SESSION_CONTEXT('XS_APPLICATIONUSER')";
        }
      }
      return path[0].id;
    }

    // transform $self in the beginning of a path to the current artifact absolute name in case of toHana
    if (options.toHana && path[0].id === '$self' && path.length > 1) {
      return `${renderEntityName(art.absolute || '', undefined, env)}.${renderPath(path.slice(1), env)}`
    }
    return path.map(step => {
      let result = renderId(step.id);
      if (step.filter) {
        result += '[' + (step.cardinality ? step.cardinality.targetMax.val + ': ' : '') + renderExpressionOrCondition(step.filter, env, true) + ']';
      }
      return result;
    }).join('.');
  }

  function renderEntityName(absName, fromArt, env) {
    if (!flatNames) {
      return renderAbsoluteNameWithQuotes(absName, fromArt, env);
    }
    // add using declaration, unless the used object is equal to the using one
    //   fromArt is undefined if the own entity is referenced
    if (fromArt && fromArt.name.absolute != absName) {
      env.topLevelAliases[absName] = {
        quotedName: uppercaseAndUnderscore(absName),
        quotedAlias: uppercaseAndUnderscore(absName)
      };
    }
    return uppercaseAndUnderscore(absName);
  }

  // Render an absolute name 'absName' as seen by 'fromArt', with appropriate quotes. Also record the
  // fact that 'absName' is used in 'env', so that an appropriate USING can be constructed
  // if necessary. If 'fromArt' is null, the absolute name is seen from top-level perspective.
  // FIXME: Not currently using 'fromArt' for anything ...
  function renderAbsoluteNameWithQuotes(absName, fromArt, env) {
    // Special case: If the top-level artifact name is not a valid artifact name, it came from an unchecked annotation
    // and must be left as it is (just quoted)
    let topLevelName = getTopLevelArtifactNameOf(absName);
    if (!model.definitions[topLevelName]) {
      return quotePathString(absName);
    }

    // Another special case: If we are rendering for HANA, and if 'absName' is an artifact that is
    // 'implemented in' something, we need to treat the whole name like a top-level id
    // Note: the impl might also have been generated by toHana based on @cds.persistence.exists;
    //       we use impl to transport the info as the annotations have already been removed when arriving here
    if (options.toHana && model.definitions[absName] && model.definitions[absName].impl) {
      env.topLevelAliases[absName] = {
        quotedName: quoteId(absName),
        quotedAlias: quoteId(createTopLevelAliasName(absName))
      };
      return env.topLevelAliases[absName].quotedAlias;
    }

    // Retrieve or create a suitable alias name for the surrounding top-level artifact
    let topLevelAlias = env.topLevelAliases[topLevelName];
    if (!topLevelAlias) {
      env.topLevelAliases[topLevelName] = {
        quotedName: quotePathString(topLevelName),
        quotedAlias: quoteId(createTopLevelAliasName(topLevelName))
      };
      topLevelAlias = env.topLevelAliases[topLevelName];
    }

    // Replace the top-level name with its alias
    if (absName == topLevelName) {
      return topLevelAlias.quotedAlias;
    } else {
      return topLevelAlias.quotedAlias + '.' + quotePathString(absName.substring(topLevelName.length + 1));
    }
  }

  // Create a suitable alias name for a top-level artifact name. Ideally, it should not conflict with
  // any other identifier in the model and be somewhat recognizable and un-ugly...
  function createTopLevelAliasName(topLevelName) {
    // FIXME: We should rather check for conflicts than just using something obscure like this ...
    return '__' + topLevelName.replace(/::/g, '__').replace(/\./g, '_');
  }

  // Render appropriate USING directives for all artifacts used in 'env'
  function renderUsings(env) {
    return Object.keys(env.topLevelAliases).map(name => 'using ' + env.topLevelAliases[name].quotedName + ' as ' + env.topLevelAliases[name].quotedAlias + ';\n').join('');
  }
  
  // Render the '::'-ish namespace declaration for a top-level artifact name that has a colon-separated
  // namespace part. Return the namespace declaration or and empty string.
  function renderNamespaceDeclaration(name, env) {
    let colonIdx = name.indexOf('::');
    if (colonIdx < 0) {
      // No '::'-ish namespace
      return ''
    }
    // If rendering for HANA, omit the trailing '::'
    return env.indent + 'namespace ' + name.substring(0, colonIdx) + (options.toHana ? ';\n' : '::;\n');
  }

  // Return a dictionary of top-level artifacts contained in a dictionary (by their name)
  function getTopLevelArtifacts(dict) {
    let result = Object.create(null);
    for (let name in dict) {
      if (flatNames ? (dict[name].kind == 'entity' || dict[name].kind == 'view')
                    : getTopLevelArtifactNameOf(name) == name) {
        result[name] = dict[name];
      }
    }
    return result;
  }

  // Returns a copy of 'env' with (quoted) name prefix 'id' and a dot appended to the current name prefix
  function addNamePrefix(env, id) {
    return Object.assign({}, env, { namePrefix: env.namePrefix + quoteId(id) + '.' });
  }

  // Returns a copy of 'env' with increased indentation (and resetted name prefix)
  function increaseIndent(env) {
    return Object.assign({}, env, { namePrefix: '', indent: env.indent + '  ' });
  }

  // Returns a copy of 'env' with decreased indentation
  function decreaseIndent(env) {
    return Object.assign({}, env, { namePrefix: env.namePrefix, indent: env.indent.substring(2) });
  }

  // Return a path string 'path' with appropriate "-quotes.
  function quotePathString(path) {
    let doubleColonNamespace = path.substring(0, path.indexOf('::'));
    if (doubleColonNamespace != '') {
      // "foo.bar"::"wiz"."blub"
      return '"' + doubleColonNamespace + '"' + '::' 
           + path.substring(doubleColonNamespace.length + 2).split('.').map(quoteId).join('.');
    } else {
      // "foo"."bar"."wiz"."blub"
      return path.split('.').map(quoteId).join('.');
    }
  }

  // Return an id 'id' with appropriate "-quotes
  // FIXME: Should only quote where necessary (examining the id for magic characters and reserved
  // keywords) - for now, simply quote everything
  function quoteId(id) {
    // FIXME: Somewhat arbitrary magic: Do not quote $projection (because HANA CDS doesn't recognize it otherwise).  Similar for $self.
    // FIXME: The test should not be on the name, but by checking the _artifact.
    if (id == '$projection' || id == '$self' ||
        id == 'self' && (options.tntFlavor && !options.tntFlavor.skipOldStyleSelf || options.oldstyleSelf)) {
      return id;
    }
    return '"' + id.replace(/"/g, '""') + '"';
  }

  // render an identifier
  //   depending on naming strategy, either convert to uppercase or quote
  function renderId(id) {
    if (flatNames) {
      if (id == '$projection') {
        return id;
      }
      else {
        return id.toUpperCase();
      }
    } else {
      return quoteId(id);
    }
  }

  // render an identifier
  //   depends on naming strategy
  function renderArtifactName(env, art) {
    return (flatNames) ? art.name.absolute.replace(/\./g, '_').toUpperCase()
                       : env.namePrefix + quoteId(art.name.id);
  }

  // replace . by _
  // convert to uppercase
  function uppercaseAndUnderscore(name) {
    return name.replace(/\./g, '_').toUpperCase();
  }
}

module.exports = {
  toCdsSource,
};
