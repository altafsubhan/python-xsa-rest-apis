"use strict";

const { CompilationError, sortMessages } = require('../base/messages');
const { mergeOptions, getTopLevelArtifactNameOf, getLastPartOf, getLastPartOfRef, getParentNamesOf } = require('../model/modelUtils');
const alerts = require('../base/alerts');
const { compactModel } = require('../json/to-csn');

// Render the CSN model 'model' to CDS source text. One source is created per
// top-level artifact. Return a dictionary of top-level artifacts
// by their names, like this:
// { "foo" : "using XY; context foo {...};",
//   "bar::wiz" : "namespace bar::; entity wiz {...};"
// }
// If 'options.toHana' is set, render HANA-ish source dialect (currently
// only affects translation of '$self.foo' in paths and ::-ish namespace declarations)
function toCdsSourceNew(model, options) {
  const { getErrors } = alerts(model);
  // Merge options (arguments first, then model options)
  options = mergeOptions(model.options, options);
  let flatNames = options.toHana && options.toHana.names == 'flat';
  let result = Object.create(null);

  // FIXME: This should happen in the caller
  let csn = compactModel(model);

  // Create artificial namespace objects, so that each artifact has parents up to top-level.
  // FIXME: This should actually only be necessary for toHana (because that wants hierarchical
  // rendering). For CDL, we could just render each artifact top-level, with a dotted name.
  for (let artifactName in csn.definitions) {
    for (let parentName of getParentNamesOf(artifactName)) {
      if (!csn.definitions[parentName]) {
        csn.definitions[parentName] = {
          kind : 'namespace',
          $inferred : true,
        };
      }
    }
  }

  // Render each top-level artifact on its own
  for (let artifactName in getTopLevelArtifacts(csn.definitions)) {
    // This environment is passed down the call hierarchy, for dealing with
    // indentation and name resolution issues 
    let env = {
      // Current indentation string
      indent: '',
      // Dictionary of aliases for used artifact names, each entry like 'name' : { quotedName, quotedAlias }
      topLevelAliases: Object.create(null),
      // Current name prefix (including trailing dot if not empty)
      namePrefix: ''
    }
    let sourceStr = renderArtifact(artifactName, csn.definitions[artifactName], env); // Must come first because it populates 'env.topLevelAliases'
    if (sourceStr != '') {
      result[flatNames ? uppercaseAndUnderscore(artifactName) : artifactName]
        = renderNamespaceDeclaration(artifactName, env) + renderUsings(env) + sourceStr;
    }
  }
  // Throw up if we have errors
  let errors = getErrors();
  if (errors.length > 0) {
    throw new CompilationError(sortMessages(errors), model);
  }
  return result;

  // Render an artifact. Return the resulting source string.
  function renderArtifact(artifactName, art, env) {
    // Ignore whole artifacts if toHana says so
    if (art._ignore) {
      return '';
    }
    switch (art.kind) {
      case 'entity':
      case 'view':
        if (art.query) {
          // FIXME: Handle projections separately for now if they have actions or functions
          // (because views can't have those yet)
          if (art.actions) {
            return renderProjection(artifactName, art, env);
          }
          else {
            return renderView(artifactName, art, env);
          }
        } else {
          return renderEntity(artifactName, art, env);
        }
      case 'context':
      case 'service':
        return renderContext(artifactName, art, env);
      case 'namespace':
        return renderNamespace(artifactName, art, env);
      case 'type':
      case 'annotation':
        return renderTypeOrAnnotation(artifactName, art, env);
      case 'action':
      case 'function':
        return renderActionOrFunction(artifactName, art, env);
      default:
        throw new Error('Unknown artifact kind: ' + art.kind);
    }
  }

  // Return a dictionary with the direct sub-artifacts of the artifact with name 'artifactName' in 'model'
  function getSubArtifacts(artifactName) {
    let prefix = artifactName + '.';
    let result = Object.create(null);
    for (let name in csn.definitions) {
      // We have a direct child if its name starts with prefix and contains no more dots
      if (name.startsWith(prefix) && !name.substring(prefix.length).includes('.')) {
        result[getLastPartOf(name)] = csn.definitions[name];
      }
    }
    return result;
  }

  // Return the original element definition for 'name' in entity 'art' (by looking up
  // included entities recursively until finding a non-$inferred one)
  function getOriginalEntityElement(art, name) {
    // Defined here?
    if (art.elements && art.elements[name] && !art.elements[name].$inferred) {
      return art.elements[name];
    }
    // Inspect includes
    for (let includeName of art.includes || []) {
      let resultElem = getOriginalEntityElement(csn.definitions[includeName], name);
      if (resultElem && !resultElem.$inferred) {
        return resultElem;
      }
    }
    // Not found
    return undefined;
  }

/* FIXME: Not yet required
  // Returns the artifact or element that constitutes the final type of
  // construct 'node', i.e. the object in which we would find type properties for
  // 'node'. Note that this may well be 'node' itself.
  function getFinalTypeOf(node) {
    if (node && node.type) {
      if (isBuiltinType(node.type)) {
        return node;
      }
      return getFinalTypeOf(node.type);
    }
    return node;
  }

  // Resolve path array 'ref' against artifact 'base' (or against 'csn.definitions'
  // if no 'base' given).
  // Return the resulting artifact or element (or 'undefined' if not found).
  function resolveRef(ref, base) {
    let result = base;
    for (let i = 0; i < ref.length; i++) {
      let pathStep = ref[i].id || ref[i];
      // Only first path step may be looked up in 'definitions'
      if (i == 0 && !base) {
        result = csn.definitions[pathStep];
        continue;
      }
      // Structured type
      else if (result && result.elements) {
        result = getFinalTypeOf(result.elements[pathStep]);
      }
      // Association
      else if (result && result.target) {
        result = resolveRef([pathStep], csn.definitions[result.target]);
      }
      // Not resolvable
      else {
        return undefined;
      }
    }
    return result;
  }
*/

  // Return true if 'typeName' is the name of a builtin type
  function isBuiltinType(typeName) {
    // FIXME: Rather than checking a list of builtin types, we just rely on the fact
    // that in a valid model, the only types that do not occur in 'definitions' are
    // the builtin ones.
    return !csn.definitions[typeName];
  }

  // Return a string array with the names of the magic variables defined in the
  // compiler (e.g. CURRENT_DATE, $now, depending on options also CURRENT_CONNECTION etc for HANA)
  function getMagicVariables() {
    // FIXME: Retrieve directly from compiler instead
    return Object.keys(model.$magicVariables.artifacts);
  }

  // Render a context or service. Return the resulting source string.
  function renderContext(artifactName, art, env) {
    let result = renderAnnotationAssignments(art, env);
    let childEnv = increaseIndent(env);
    result += env.indent + art.kind + ' ' + env.namePrefix + quoteId(getLastPartOf(artifactName)) + ' {\n';
    let subArtifacts = getSubArtifacts(artifactName);
    for (let name in subArtifacts) {
      result += renderArtifact(artifactName + '.' + name, subArtifacts[name], childEnv);
    }
    return result + env.indent + '};\n';
  }

  // Render a namespace. Return the resulting source string.
  function renderNamespace(artifactName, art, env) {
    // We currently do not render anything for a namespace, we just append its id to
    // the environment's current name prefix and descend into its children
    let result = '';
    let childEnv = addNamePrefix(env, getLastPartOf(artifactName));
    let subArtifacts = getSubArtifacts(artifactName);
    for (let name in subArtifacts) {
      result += renderArtifact(artifactName + '.' + name, subArtifacts[name], childEnv);
    }
    return result;
  }

  // Render a (non-projection, non-view) entity. Return the resulting source string.
  function renderEntity(artifactName, art, env) {
    let result = renderAnnotationAssignments(art, env);
    let childEnv = increaseIndent(env);
    result += env.indent + (art.abstract ? 'abstract ' : '') + 'entity ' + renderArtifactName(artifactName, env);
    let parameters = Object.keys(art.params || []).map(name => renderParameter(name, art.params[name], childEnv)).join(',\n');
    result += (parameters == '') ? '' : ' (\n' + parameters + '\n' + env.indent + ')';
    if (art.includes) {
      result += ' : ' + art.includes.map(name => renderAbsoluteNameWithQuotes(name, art, env)).join(', ');
    }
    result += ' {\n';
    for (let name in art.elements) {
      result += renderElement(name, art.elements[name], childEnv);
    }
    result += env.indent + '}';
    result += renderActionsAndFunctions(art, env) + ';\n';

    // Render additional annotation assignments that were produced via 'annotate' on inherited elements
    // FIXME: Actually, this attempts to undo propagation ... not ideal
    let allElementAnnotationAssignments = '';
    for (let name in art.elements) {
      let elm = art.elements[name];
      // Ignore if toHana says so, or if not inherited
      if (elm._ignore || !elm.$inferred) {
        continue;
      }
      let originElm = getOriginalEntityElement(art, name);
      let elementAnnotationAssignments = '';
      for (let annoName in elm) {
        if (annoName.startsWith('@')) {
          let elementAnnotationAssignment = renderAnnotationAssignment(elm[annoName], annoName, childEnv);
          let originAnnotation = originElm[annoName];
          // If this annotation was not present or different in the origin (i.e. "superclass") element,
          // it must be the result of an 'annotate' on the inheriting entity
          // FIXME: Do this without propagation - inspect only direct predecessor
          if (!originAnnotation || elementAnnotationAssignment != renderAnnotationAssignment(originAnnotation, annoName, childEnv)) {
            elementAnnotationAssignments += elementAnnotationAssignment;
          }
        }
      }
      if (elementAnnotationAssignments != '') {
        allElementAnnotationAssignments += elementAnnotationAssignments + childEnv.indent + quoteId(name) + ';\n'
      }
    }
    if (allElementAnnotationAssignments != '') {
      result += env.indent + 'annotate ' + env.namePrefix + quoteId(getLastPartOf(artifactName)) + ' {\n'
             + allElementAnnotationAssignments + env.indent + '}\n';
    }

    return result;
  }

  // Render an element (of an entity, type or annotation, not a projection or view).
  // Return the resulting source string.
  function renderElement(elementName, elm, env, ignoreInherited=true) {
    // Ignore if toHana says so, or if inherited
    if (elm._ignore || (ignoreInherited && elm.$inferred)) {
      return '';
    }
    // Special handling for HANA CDS: Must omit the ':' before anonymous structured types (for historical reasons)
    let omitColon = (options.toHana && !elm.type && elm.elements);
    let result = renderAnnotationAssignments(elm, env);
    result += env.indent + (elm.virtual ? 'virtual ' : '') 
                         + (elm.key ? 'key ' : '')
                         + ((elm.masked && !elm._ignoreMasked)? 'masked ' : '')
                         + quoteOrUppercaseId(elementName) + (omitColon ? ' ' : ' : ')
                         + renderTypeReference(elm, env)
                         + renderNullability(elm);
    if (elm.default) {
      result += ' default ' + renderExpr(elm.default, env);
    }
    return result + ';\n';
  }

  // Return the SELECT of the leading query of query 'query'
  function leadingQuerySelect(query) {
    if (query.SELECT) {
      return query.SELECT;
    }
    // Sanity checks
    if (!query.SET || !query.SET.args || !query.SET.args[0]) {
      throw new Error(`Expecting set with args in query: ${JSON.stringify(query)}`);
    }
    return leadingQuerySelect(query.SET.args[0]);
  }

  // Render a projection entity. Return the resulting source string.
  function renderProjection(artifactName, art, env) {
    let result = renderAnnotationAssignments(art, env);
    let childEnv = increaseIndent(env);
    let select = leadingQuerySelect(art.query);
    result += env.indent + (art.abstract ? 'abstract ' : '') + 'entity ' + renderArtifactName(artifactName, env);
    result += ' as projection on ' + renderAbsolutePathWithAlias(select.from, art, env) + ' {\n';
    result += select.columns.map(col => renderViewColumn(col, art, childEnv))
                            .filter(s => s != '')
                            .join(',\n') + '\n';
    result += env.indent + '}';
    if (select.excluding) {
      result += ' excluding {\n' + select.excluding.map(id => `${childEnv.indent}${quoteOrUppercaseId(id)}`).join(',\n') + '\n';
      result += env.indent + '}';
    }
    result += renderActionsAndFunctions(art, env) + ';\n';
    result += renderQueryElementAnnotations(artifactName, art, env);
    return result;
  }

  // Render annotations that were extended to a query element of a view or projection (they only
  // appear in the view's 'elements', not in their 'columns', because the element itself may not
  // even be in 'columns', e.g. if it was expanded from a '*'). Return the resulting 'annotate'
  // statement or an ampty string if none required.
  function renderQueryElementAnnotations(artifactName, art, env) {
    // For preparation, create a map from element names to column objects
    let columnMap = Object.create(null);
    let select = leadingQuerySelect(art.query);
    for (let col of select.columns) {
      // Ignore '*'
      if (col == '*') {
        continue;
      }
      // Column must have an alias or be a path - take last part of that as element name
      columnMap[col.as || getLastPartOfRef(col.ref)] = col;
    }
    // Now iterate elements - render an annotation if it is different from the column's
    let childEnv = increaseIndent(env);
    let result = '';
    for (let elemName in art.elements) {
      let elemAnnotations = '';
      let elem = art.elements[elemName];
      for (let name in elem) {
        if (!name.startsWith('@')) {
          continue;
        }
        let annotationValue = renderAnnotationValue(elem[name], childEnv);
        // Skip annotation if column has the same
        if (columnMap[elemName] && columnMap[elemName][name]
            && renderAnnotationValue(columnMap[elemName][name], childEnv) == annotationValue) {
          continue;
        }
        elemAnnotations += `${childEnv.indent}${'@' + renderAbsoluteNameWithQuotes(name.substring(1), null, env)} : ${annotationValue}\n`;
      }
      if (elemAnnotations != '') {
        result += `${elemAnnotations}${childEnv.indent}${elemName};\n`;
      }
    }
    if (result != '') {
      result = `${env.indent}annotate ${renderArtifactName(artifactName, env)} with {\n${result}${env.indent}};\n`;
    }
    return result;
  }

  // Render the source of a query, which may be a path reference, possibly with an alias,
  // or a subselect, or a join operation, as seen from artifact 'art'.
  // Returns the source as a string.
  function renderViewSource(source, art, env) {
    // Sub-SELECT
    if (source.SELECT || source.SET) {
      let result = `(${renderQuery(source, art, false, increaseIndent(env))})`;
      if (source.as) {
        result += ` as ${quoteId(source.as)}`;
      }
      return result;
    }
    // JOIN
    else if (source.join) {
      // One join operation, possibly with ON-condition
      // FIXME: Clarify if join operators can be n-ary (assuming binary here)
      let result = `(${renderViewSource(source.args[0], art, env)} ${source.join} join ${renderViewSource(source.args[1], art, env)}`;
      if (source.on) {
        result += ` on ${renderExpr(source.on)}`;
      }
      result += `)`;
      return result;
    }
    // Ordinary path, possibly with an alias
    else {
      return renderAbsolutePathWithAlias(source, art, env);
    }
  }

  // Render a path that starts with an absolute name (as used for the source of a query).
  // Expects an object 'path' that has a 'ref'.
  // Returns the name as a string.
  // FIXME: Get rid of 'art'
  function renderAbsolutePath(path, art, env) {
    // Sanity checks
    if (!path.ref) {
      throw new Error('Expecting ref in path: ' + JSON.stringify(path));
    }
    // Determine the absolute name of the first artifact on the path (before any associations or element traversals)
    let firstArtifactName = path.ref[0].id || path.ref[0];
    let firstArtifact = csn.definitions[firstArtifactName];
    if (!firstArtifact) {
      throw new Error('Expecting first path step in path to be resolvable: ' + JSON.stringify(path));
    }
    let result = '';
    // Render the first path step (absolute name, with different quoting/flatness ..)
    if (flatNames) {
      result += renderAbsoluteNameFlat(firstArtifactName, art, env);
    } else {
      result += renderAbsoluteNameWithQuotes(firstArtifactName, art, env);
    }
    // Even the first step might have a filter
    if (path.ref[0].filter) {
      result += `[${path.ref[0].cardinality ? (path.ref[0].cardinality.max + ': ') : ''}${renderExpr(path.ref[0].filter.xpr, env)}]`;
    }
    // Add any path steps (possibly with filters) that may follow after that
    if (path.ref.length > 1) {
      result += `.${renderExpr({ref: path.ref.slice(1)}, env)}`;
    }
    return result;
  }

  // Render a path that starts with an absolute name (as used for the source of a query), possibly with an alias.
  // Expects an object 'path' that has a 'ref' and (in case of an alias) an 'as'. If necessary, an artificial alias
  // is created to the original implicit name.
  // Returns the name and alias as a string.
  // FIXME: Get rid of 'art'
  function renderAbsolutePathWithAlias(path, art, env) {
    let result = renderAbsolutePath(path, art, env);
    // Take care of aliases
    let implicitAlias = getLastPartOfRef(path.ref);
    if (path.as) {
      // Source had an alias - render it
      result += ' as ' + quoteId(path.as);
    }
    else {
      // We always render an artificial alias to the original name
      // FIXME: We may want to avoid that if it is unnecessary
      result += ' as ' + quoteId(implicitAlias);
    }
    return result;
  }

  // Render a single view or projection column 'col', as it occurs in a select list or
  // projection list within 'art', possibly with annotations.
  // Return the resulting source string (no trailing LF).
  function renderViewColumn(col, art, env) {
    // Ignore if toHana says so
    // FIXME: This probably needs to change ...
    if (col._ignore) {
      return '';
    }
    // Annotations and column
    let result = renderAnnotationAssignments(col, env);
    result += env.indent + renderExpr(col, env, true);
    // Explicit alias?
    if (col.as) {
      result += ' as ' + quoteId(col.as);
    }
    // Explicit type provided for the view element?
    if (col.cast) {
      // Special case: Explicit association type is actually a redirect
      if (col.cast.target) {
        result += ' : redirected to ' + renderAbsoluteNameWithQuotes(col.cast.target, art, env);
      } else {
        result += ' : ' + renderTypeReference(col.cast, env);
      }
    }
    return result;
  }

  // Render a view
  function renderView(artifactName, art, env) {
    let result = renderAnnotationAssignments(art, env);
    result += env.indent + 'view ' + renderArtifactName(artifactName, env)
           + ' as ' + renderQuery(art.query, art, true, env);
    result += ';\n';
    result += renderQueryElementAnnotations(artifactName, art, env);
    return result;
  }

  // Render a query 'query', i.e. a select statement with where-condition etc, possibly as part of artifact 'art'.
  // If 'isLeadingQuery' is true, mixins, actions and functions of 'art' are also rendered into the query.
  function renderQuery(query, art, isLeadingQuery, env) {
    let result = '';
    // Set operator, like UNION, INTERSECT, ...
    if (query.SET) {
      // First arg may be leading query
      result += `(${renderQuery(query.SET.args[0], art, isLeadingQuery, env)}`
      // FIXME: Clarify if set operators can be n-ary (assuming binary here)
      if (query.SET.op) {
        result += `\n${env.indent}${query.SET.op}${query.SET.all ? ' all' : ''} ${renderQuery(query.SET.args[1], art, false, env)}`;
      }
      result += ')';
      // Set operation may also have an ORDER BY and LIMIT/OFFSET (in contrast to the ones belonging to
      // each SELECT)
      if (query.SET.orderBy) {
        result += `${continueIndent(result, env)}order by ${query.SET.orderBy.map(entry => renderOrderByEntry(entry, env)).join(', ')}`;
      }
      if (query.SET.limit) {
        result += `${continueIndent(result, env)}${renderLimit(query.SET.limit, env)}`;
      }
      return result;
    }
    // Otherwise must have a SELECT
    else if (!query.SELECT) {
      throw new Error('Unexpected query operation ' + JSON.stringify(query));
    }
    let select = query.SELECT;
    let childEnv = increaseIndent(env);
    result += `select from ${renderViewSource(select.from, art, env)}`;
    if (isLeadingQuery && select.mixin) {
      result += ' mixin {\n'
      for (let name in select.mixin) {
        result += renderElement(name, select.mixin[name], childEnv, false);
      }
      result += env.indent + '} into'
    }
    result += select.distinct ? ' distinct' : '';
    result += ' {\n' + select.columns.map(col => renderViewColumn(col, art, childEnv))
                                     .filter(s => s != '')
                                     .join(',\n') + '\n';
    result += env.indent + '}';
    if (select.excluding) {
      result += ' excluding {\n' + select.excluding.map(id => `${childEnv.indent}${quoteOrUppercaseId(id)}`).join(',\n') + '\n';
      result += env.indent + '}';
    }
    // FIXME: Currently, only projections can have actions and functions, but we cannot distinguish
    // a projection from a view any more
    if (isLeadingQuery) {
      result += renderActionsAndFunctions(query, env);
    }
    if (select.where) {
      result += `${continueIndent(result, env)}where ${renderExpr(select.where, env)}`;
    }
    if (select.groupBy) {
      result += `${continueIndent(result, env)}group by ${select.groupBy.map(expr => renderExpr(expr, env)).join(', ')}`;
    }
    if (select.having) {
      result += `${continueIndent(result, env)}having ${renderExpr(select.having, env)}`;
    }
    if (select.orderBy) {
      result += `${continueIndent(result, env)}order by ${select.orderBy.map(entry => renderOrderByEntry(entry, env)).join(', ')}`;
    }
    if (select.limit) {
      result += `${continueIndent(result, env)}${renderLimit(select.limit, env)}`;
    }
    return result;

    // Utility function to make sure that we continue with the same indentation in WHERE, GROUP BY, ... after a closing curly brace and beyond
    function continueIndent(result, env) {
      if (result.endsWith('}') || result.endsWith('})')) {
        // The preceding clause ended with '}', just append after that
        return ' ';
      } else {
        // Otherwise, start new line and indent normally
        return '\n' + increaseIndent(env).indent;
      }
    }

    // Render a query's LIMIT clause, which may have also have OFFSET.
    function renderLimit(limit, env) {
      let result = '';
      if (limit.rows !== undefined) {
        // FIXME: The 'val' is probably accidental here
        result += `limit ${renderExpr(limit.rows.val || limit.rows, env)}`;
      }
      if (limit.offset !== undefined) {
        // FIXME: The 'val' is probably accidental here
        result += `${result != '' ? ' ' : ''}offset ${renderExpr(limit.offset.val || limit.offset, env)}`;
      }
      return result;
    }
  }

  // Render one entry of a query's ORDER BY clause (which always has a 'value' expression, and may
  // have a 'sort' property for ASC/DESC and a 'nulls' for FIRST/LAST
  function renderOrderByEntry(entry, env) {
    let result = renderExpr(entry, env);
    if (entry.sort) {
      result += ` ${entry.sort}`;
    }
    if (entry.nulls) {
      result += ` nulls ${entry.nulls}`;
    }
    return result;
  }

  // Render an entity's actions and functions (if any)
  // (expect an entity with trailing '}' to have just been rendered).
  // Return the resulting source string.
  function renderActionsAndFunctions(art, env) {
    let result = ''
    let childEnv = increaseIndent(env);
    for (let name in art.actions) {
      result += renderActionOrFunction(name, art.actions[name], childEnv);
    }
    // Even if we have seen actions/functions, they might all have been ignored
    if (result != '') {
      result = ' actions {\n' + result + env.indent + '}';
    }
    return result;
  }

  // Render an action or function 'act' with name 'actName'. Return the resulting source string.
  function renderActionOrFunction(actionName, act, env) {
    // Ignore if toHana says so, or if inherited
    if (act._ignore || act.$inferred) {
      return '';
    }
    let result = renderAnnotationAssignments(act, env) + env.indent + act.kind + ' ' + env.namePrefix + quoteId(getLastPartOf(actionName));
    let childEnv = increaseIndent(env);
    let parameters = Object.keys(act.params || []).map(name => renderParameter(name, act.params[name], childEnv)).join(',\n');
    result += (parameters == '') ? '()' : '(\n' + parameters + '\n' + env.indent + ')';
    if (act.returns) {
      result += ' returns ' + renderTypeReference(act.returns, env);
    }
    result += ';\n';
    return result;
  }

  // Render an action or function parameter 'par' with name 'parName'. Return the resulting source string (no trailing LF).
  function renderParameter(parName, par, env) {
    let result = renderAnnotationAssignments(par, env) + env.indent + quoteId(parName) + ' : ' + renderTypeReference(par, env);
    result += renderNullability(par);
    return result;
  }

  // Render a type (derived or structured) or an annotation decl with name 'artifactName'.
  // Return the resulting source string.
  function renderTypeOrAnnotation(artifactName, art, env) {
    let result = renderAnnotationAssignments(art, env) + env.indent + art.kind + " " + env.namePrefix + quoteId(getLastPartOf(artifactName));
    if (art.includes) {
      result += ' : ' + art.includes.map(name => renderAbsoluteNameWithQuotes(name, art, env)).join(', ');
    }
    let childEnv = increaseIndent(env);
    if (art.elements) {
      // Structured type or annotation with anonymous struct type
      result += " {\n";
      for (let name in art.elements) {
        result += renderElement(name, art.elements[name], childEnv);
      }
      result += env.indent + '};\n';
    } else {
      // Derived type or annotation with non-anonymous type
      result += " : " + renderTypeReference(art, env) + ';\n';
    }
    return result;
  }

  // Render a reference to a type used by 'elm' (named or inline)
  function renderTypeReference(elm, env) {
    let result = '';

    // Array type: Render items instead
    if (elm.items) {
      return 'array of ' + renderTypeReference(elm.items, env);
    }

    // FIXME: Is this a type attribute?
    result += (elm.localized ? 'localized ' : '');

    // Anonymous structured type
    if (!elm.type) {
      if (!elm.elements) {
        throw new Error('Missing type of: ' + elm.name.id);
      }
      result += '{\n';
      let childEnv = increaseIndent(env);
      for (let name in elm.elements) {
        result += renderElement(name, elm.elements[name], childEnv);
      }
      result += env.indent + '}'
      return result;
    }

    // Association type
    if (elm.type == 'cds.Association' || elm.type == 'cds.Composition') {
      // Type, cardinality and target
      result += elm.type == 'cds.Association' ? 'association' : 'composition';
      result += renderCardinality(elm.cardinality) + (elm.type == 'cds.Association' ? ' to ' : ' of ');
      result += renderEntityName(elm.target, elm._main, env);

      // ON-condition (if any)
      if (elm.on) {
        result += ' on ' + renderExpr(elm.on, env);
      }

      // Foreign keys (if any and not all of them inferred)
      if (elm.foreignKeys && !elm.foreignKeys.every(fkey => fkey.$inferred)) {
        result += ' { ' + Object.keys(elm.foreignKeys).map(name => renderForeignKey(elm.foreignKeys[name], env)).join(', ') + ' }';
      }
      return result;
    }

    // Reference to another element
    // FIXME: Shouldn't that be 'type of' ??
    if (elm.type.ref) {
      return renderAbsolutePath(elm.type, null, env);
    }

    // If we get here, it must be a named type
    if (isBuiltinType(elm.type)) {
      // cds.Integer => render as Integer (no quotes)
      result += elm.type.replace(/^cds\./, '');
    } else {
      // Simple absolute path
      result += renderAbsoluteNameWithQuotes(elm.type, elm._main, env);
    }
    result += renderTypeParameters(elm);
    if (elm.enum) {
      result += ' enum {\n';
      let childEnv = increaseIndent(env);
      for (let name in elm.enum) {
        let enumConst = elm.enum[name];
        result += renderAnnotationAssignments(enumConst, childEnv);
        let enumValue = { val: enumConst.val === undefined ? name : enumConst.val };
        result += childEnv.indent + quoteId(name) + ' = ' + renderExpr(enumValue, childEnv) + ';\n';
      }
      result += env.indent + '}';
    }
    return result;
  }

  // Render an annotation value (somewhat like a simplified expression, with slightly different
  // representation)
  function renderAnnotationValue(x, env) {
    if (x instanceof Array) {
      // Render array parts as values
      return `[${x.map(item => renderAnnotationValue(item, env)).join(', ')}]`;
    }
    else if (typeof x == 'object' && x !== null) {
      // Enum symbol
      if (x['#']) {
        return `#${x['#']}`;
      }
      // Shorthand for absolute path (as string)
      else if (x['=']) {
        return quotePathString(x['=']);
      }
      // Struct value (can actually only occur within an array)
      else {
        // Note that we have to quote the struct keys here manually and not use quoteId, because they may even contain dots (yuc!)
        // FIXME: Should that really be allowed?
        return `{${Object.keys(x).map(key => '"' + key + '": ' + renderAnnotationValue(x[key], env)).join(', ')}}`;
      }
    }
    // Null
    else if (x === null) {
      return 'null';
    }
    // Primitive: string, number, boolean
    else {
      // Quote strings, leave all others as they are
      return (typeof x == 'string') ? `'${x.replace(/'/g, "''")}'` : x;
    }
  }

  // Render an expression (including paths and values) or condition 'x'.
  // (no trailing LF, don't indent if inline)
  function renderExpr(x, env, inline=true) {
    // Compound expression
    if (x instanceof Array) {
      // Simply concatenate array parts with spaces
      return x.map(item => renderExpr(item, env, inline)).join(' ');
    }
    // Various special cases represented as objects
    else if (typeof x == 'object' && x !== null) {
      // Literal value, possibly with explicit 'literal' property
      if (x.val !== undefined) {
        switch (x.literal || typeof x.val) {
          case 'number':
          case 'boolean':
          case 'null':
            return x.val;
          case 'x':
          case 'date':
          case 'time':
          case 'timestamp':
            return `${x.literal}'${x.val}'`;
          case 'string':
            return `'${x.val.replace(/'/g, "''")}'`;
          case 'object':
            if (x.val === null) {
              return 'null';
            }
            // otherwise fall through to
          default:
            throw new Error('Unknown literal or type: ' + JSON.stringify(x));
        }
      }
      // Enum symbol
      else if (x['#']) {
        return `#${x['#']}`;
      }
      // Reference: Array of path steps, possibly preceded by ':'
      else if (x.ref) {
        return `${(x.param || x.global) ? ':' : ''}${x.ref.map(renderPathStep).join('.')}`;
      }
      // Function call, possibly with args (use '=>' for named args)
      else if (x.func) {
        return `${x.func}(${renderArgs(x.args, '=>')})`;
      }
      // Nested expression
      else if (x.xpr) {
        return renderExpr(x.xpr, env);
      }
      // Sub-select
      else if (x.SELECT || x.SET) {
        // FIXME: Actually, we should pass the surrounding artifact and not null, but we don't have that here
        // (and it is not yet used except being passed to renderAbsoluteNameWithQuotes, which currently ignores it)
        return `(${renderQuery(x, null, false, env)})`;
      }
      else {
        throw new Error('Unknown expression: ' + JSON.stringify(x));
      }
    }
    // Not a literal value but part of an operator, function etc - just leave as it is
    else {
      return x;
    }

    // Render a single path step 's' at path position 'idx', which can have filters or parameters or be a function
    function renderPathStep(s, idx) {
      // Simple id or absolute name
      if (typeof(s) == 'string') {
        // In first path position, do not quote $projection and magic $-variables like CURRENT_DATE, $now etc.
        // FIXME: We should rather explicitly recognize quoting somehow
        if (idx == 0
            && (['$projection', '$self'].includes(s)
                || getMagicVariables().map(id => id.toLowerCase()).includes(s.toLowerCase())
                || s == 'self' && (options.tntFlavor && !options.tntFlavor.skipOldStyleSelf || options.oldstyleSelf))) {
          return s;
        }
        return quoteOrUppercaseId(s);
      }
      // ID with filters or parameters
      else if (typeof s == 'object') {
        // Filter, possibly with cardinality
        if (s.filter) {
          return `${quoteOrUppercaseId(s.id)}[${s.cardinality ? (s.cardinality.max + ': ') : ''}${renderExpr(s.filter.xpr, env)}]`;
        }
        // Not really a path but an object-like function call
        else if (s.func) {
          return `${s.func}(${renderArgs(s.args, '=>')})`;
        }
        // View with arguments (use ':' for named args)
        else if (s.args) {
          return `${quoteOrUppercaseId(s.id)}(${renderArgs(s.args, ':')})`;
        }
        else {
          throw new Error('Unknown path step object: ' + JSON.stringify(s));
        }
      }
      else {
        throw new Error('Unknown path step: ' + JSON.stringify(s));
      }
    }

    // Render function arguments or view parameters (positional if array, named if object/dict),
    // using 'sep' as separator for positional parameters
    function renderArgs(args, sep) {
      // Positional arguments
      if (args instanceof Array) {
        return args.map(arg => renderExpr(arg, env)).join(', ');
      }
      // Named arguments (object/dict)
      else if (typeof args == 'object') {
        // FIXME: Think about quoting for the param names
        return Object.keys(args).map(key => `${quoteOrUppercaseId(key)} ${sep} ${renderExpr(args[key], env)}`).join(', ');
      }
      else {
        throw new Error('Unknown args: ' + JSON.stringify(args));
      }
    }
  }

  // Render a cardinality (only those parts that were actually provided)
  function renderCardinality(card) {
    if (!card) {
      return '';
    }
    let result = '[';
    if (card.src !== undefined) {
      result += card.src + ', ';
    }
    if (card.min !== undefined) {
      result += card.min + '..';
    }
    if (card.max !== undefined) {
      result += card.max;
    }
    return result + ']';
  }

  // Render the nullability of an element or parameter (can be unset, true, or false)
  function renderNullability(obj /* , env */) {
    if (obj.notNull === undefined) {
      // Attribute not set at all
      return '';
    }
    return obj.notNull ? ' not null' : ' null';
  }

  // Render a foreign key (no trailing LF)
  function renderForeignKey(fkey) {
    return `${renderExpr(fkey)}${fkey.as ? (' as ' + fkey.as) : ''}`;
  }

  // Render (primitive) type parameters of element 'elm', i.e. 
  // length, precision and scale (even if incomplete), plus any other unknown ones.
  function renderTypeParameters(elm /*, env */) {
    let params = [];
    // Length, precision and scale (even if incomplete)
    // FIXME: The bools here should actually not happen
    if (elm.length !== undefined && elm.length !== true) {
      params.push(elm.length);
    }
    if (elm.precision !== undefined && elm.precision !== true) {
      params.push(elm.precision);
    }
    if (elm.scale !== undefined && elm.scale !== true) {
      params.push(elm.scale);
    }
    // Additional type parameters
    // FIXME: Not yet clear how that looks in new CSN
    for (let arg of elm.typeArguments || []) {
      params.push(arg);
    }
    return params.length == 0 ? '' : '(' + params.join(', ') + ')';
  }

  // Render all annotation assignments of annotatable object 'obj'
  function renderAnnotationAssignments(obj, env) {
    let result = '';
    for (let name in obj) {
      if (name.startsWith('@')) {
        result += renderAnnotationAssignment(obj[name], name, env);
      }
    }
    return result;
  }

  // Render a single annotation assignment 'ann' with fully qualified name 'name' (no trailing LF).
  function renderAnnotationAssignment(ann, name, env) {
    let result = env.indent + '@' + renderAbsoluteNameWithQuotes(name.substring(1), null, env) + ' : ';
    result += renderAnnotationValue(ann, env);
    return result  + '\n';
  }

  // FIXME: Remove the handling of 'fromArt' because that is no longer reliable
  function renderAbsoluteNameFlat(absName, fromArt, env) {
    // add using declaration, unless the used object is equal to the using one
    //   fromArt is undefined if the own entity is referenced
    if (fromArt && fromArt.name.absolute != absName) {
      env.topLevelAliases[absName] = {
        quotedName: uppercaseAndUnderscore(absName),
        quotedAlias: uppercaseAndUnderscore(absName)
      };
    }
    return uppercaseAndUnderscore(absName);
  }

  // FIXME: Remove the handling of 'fromArt' because that is no longer reliable
  // FIXME: Explicitly use renderAbsoluteNameFlat instead
  function renderEntityName(absName, fromArt, env) {
    if (!flatNames) {
      return renderAbsoluteNameWithQuotes(absName, fromArt, env);
    }
    // add using declaration, unless the used object is equal to the using one
    //   fromArt is undefined if the own entity is referenced
    if (fromArt && fromArt.name.absolute != absName) {
      env.topLevelAliases[absName] = {
        quotedName: uppercaseAndUnderscore(absName),
        quotedAlias: uppercaseAndUnderscore(absName)
      };
    }
    return uppercaseAndUnderscore(absName);
  }

  // Render an absolute name 'absName' as seen by 'fromArt', with appropriate quotes. Also record the
  // fact that 'absName' is used in 'env', so that an appropriate USING can be constructed
  // if necessary. If 'fromArt' is null, the absolute name is seen from top-level perspective.
  // FIXME: Not currently using 'fromArt' for anything ...
  function renderAbsoluteNameWithQuotes(absName, fromArt, env) {
    // Special case: If the top-level artifact name is not a valid artifact name, it came from an unchecked annotation
    // and must be left as it is (just quoted)
    let topLevelName = getTopLevelArtifactNameOf(absName);
    if (!model.definitions[topLevelName]) {
      return quotePathString(absName);
    }

    // Another special case: If we are rendering for HANA, and if the first path step is an artifact that is
    // 'implemented in' something, we need to treat the whole name like a top-level id.
    // Note: The 'impl' might also have been generated by toHana based on '@cds.persistence.exists';
    // we use 'impl' to transport this info because the annotations have already been removed when
    // arriving here
    // FIXME: Make that '$impl' or similar
    if (options.toHana && model.definitions[absName] && model.definitions[absName].impl) {
      env.topLevelAliases[absName] = {
        quotedName: quoteId(absName),
        quotedAlias: quoteId(createTopLevelAliasName(absName))
      };
      return env.topLevelAliases[absName].quotedAlias;
    }

    // Retrieve or create a suitable alias name for the surrounding top-level artifact
    let topLevelAlias = env.topLevelAliases[topLevelName];
    if (!topLevelAlias) {
      env.topLevelAliases[topLevelName] = {
        quotedName: quotePathString(topLevelName),
        quotedAlias: quoteId(createTopLevelAliasName(topLevelName))
      };
      topLevelAlias = env.topLevelAliases[topLevelName];
    }

    // Replace the top-level name with its alias
    if (absName == topLevelName) {
      return topLevelAlias.quotedAlias;
    } else {
      return topLevelAlias.quotedAlias + '.' + quotePathString(absName.substring(topLevelName.length + 1));
    }
  }

  // Create a suitable alias name for a top-level artifact name. Ideally, it should not conflict with
  // any other identifier in the model and be somewhat recognizable and un-ugly...
  function createTopLevelAliasName(topLevelName) {
    // FIXME: We should rather check for conflicts than just using something obscure like this ...
    return '__' + topLevelName.replace(/::/g, '__').replace(/\./g, '_');
  }

  // Render appropriate USING directives for all artifacts used in 'env'
  function renderUsings(env) {
    return Object.keys(env.topLevelAliases).map(name => 'using ' + env.topLevelAliases[name].quotedName + ' as ' + env.topLevelAliases[name].quotedAlias + ';\n').join('');
  }
  
  // Render the '::'-ish namespace declaration for a top-level artifact name that has a colon-separated
  // namespace part. Return the namespace declaration or an empty string.
  function renderNamespaceDeclaration(name, env) {
    let colonIdx = name.indexOf('::');
    if (colonIdx < 0) {
      // No '::'-ish namespace
      return ''
    }
    // If rendering for HANA, omit the trailing '::'
    return env.indent + 'namespace ' + name.substring(0, colonIdx) + (options.toHana ? ';\n' : '::;\n');
  }

  // Return a dictionary of top-level artifacts contained in a dictionary (by their name)
  function getTopLevelArtifacts(dict) {
    let result = Object.create(null);
    for (let name in dict) {
      if (flatNames ? (dict[name].kind == 'entity' || dict[name].kind == 'view')
                    : getTopLevelArtifactNameOf(name) == name) {
        result[name] = dict[name];
      }
    }
    return result;
  }

  // Returns a copy of 'env' with (quoted) name prefix 'id' and a dot appended to the current name prefix
  function addNamePrefix(env, id) {
    return Object.assign({}, env, { namePrefix: env.namePrefix + quoteId(id) + '.' });
  }

  // Returns a copy of 'env' with increased indentation (and resetted name prefix)
  function increaseIndent(env) {
    return Object.assign({}, env, { namePrefix: '', indent: env.indent + '  ' });
  }

  // Return a path string 'path' with appropriate "-quotes.
  function quotePathString(path) {
    let doubleColonNamespace = path.substring(0, path.indexOf('::'));
    if (doubleColonNamespace != '') {
      // "foo.bar"::"wiz"."blub"
      return '"' + doubleColonNamespace + '"' + '::' 
           + path.substring(doubleColonNamespace.length + 2).split('.').map(quoteId).join('.');
    } else {
      // "foo"."bar"."wiz"."blub"
      return path.split('.').map(quoteId).join('.');
    }
  }

  // Return an id 'id' with appropriate "-quotes
  // FIXME: Should only quote where necessary (examining the id for magic characters and reserved
  // keywords) - for now, simply quote everything
  function quoteId(id) {
    // FIXME: In new-style CSN, absolute names may appear as IDs - quote accordingly
    if (id.indexOf('.') != -1) {
      return quotePathString(id);
    }
    return '"' + id.replace(/"/g, '""') + '"';
  }

  // Quote or uppercase an identifier 'id', depending on naming strategy
  function quoteOrUppercaseId(id) {
    if (flatNames) {
      return id.replace(/\./g, '_').toUpperCase();
    } else {
      return quoteId(id);
    }
  }

  // Render the name of an artifact, using the current name prefix from 'env'
  // and just the last part of the artifact's name. In case of flat names, this
  // is equivalent to simply flattening and uppercasing the whole name.
  function renderArtifactName(artifactName, env) {
    return (flatNames) ? quoteOrUppercaseId(artifactName)
                       : env.namePrefix + quoteId(getLastPartOf(artifactName));
  }

  // replace . by _
  // convert to uppercase
  function uppercaseAndUnderscore(name) {
    return name.replace(/\./g, '_').toUpperCase();
  }
}

module.exports = {
  toCdsSourceNew,
};
