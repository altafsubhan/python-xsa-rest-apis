"use strict";
var { CompilationError, sortMessages } = require('../base/messages');
const baseModel = require('../base/model');
const deepCopy = require('../base/deepCopy');
const { isAssociation, isStructuredElement, isManagedAssociationElement, isProjection, isView,
        foreachPath, printableName, mergeOptions, hasBoolAnnotation, getTopLevelArtifactNameOf } = require('../model/modelUtils');
const modelTransform = require('../model/transform.js');
const { cloneWithTransformations } = require('../base/model.js');
const { checkTypeParameters } = require('../checks/checkElements');
const alerts = require('../base/alerts');

// Return a copy of augmented CSN 'model' with a number of transformations made for rendering
// to HANA CDS:
// - (0z) Check: in "flat" mode, quoted ids are not allowed.
//        (a) check in namespace declarations
//        (b) check in artifact/element definitions.
// - (00) (flat only) For all elements, derived types are replaced by their final base type.
// - (01) Abstract entities and entities 'implemented in' something are ignored, as well
//        as entities annotated with '@cds.persistence.skip' or '@cds.persistence.exists'.
// - (02) Some primitive type names are mapped to HANA type names (e.g. DateTime => UTCDateTime,
//        Date => LocalDate, ...).
// - (03) The primitive type 'UUID' is replaced by 'String(36)'.
// - (04) Default length 5000 is supplied for strings if not specified.
// - (05) Annotation definitions (a) and annotation assignments (b) are ignored.
// - (06) Compositions become associations.
// - (07) 'virtual' elements are ignored (a), 'masked' is ignored (b), and attribute 'localized' is removed (c)
// - (08) Actions and functions (bound or unbound) are ignored.
// - (09) Services and namespaces become contexts.
// - (10) Elements having structured types are flattened into multiple elements (using '_' as name separator).
// - (11) Managed associations get explicit ON-conditions, with generated foreign key elements (also using '_').
// - (12) (a) Elements from inherited (included) entities are copied into the receiving entity
//        (b) The 'include' property is removed from entities.
// - (13) Projections become views, with MIXINs for association elements (adding $projection where
//        appropriate for ON-conditions).
// - (14) ON-conditions referring to '$self' are transformed to compare explicit keys instead.
// - (15) In projections and views, ...
//        (a) association elements that are mixins must not be explicitly redirected
//        (b) MIXINs are created for association elements in the select list that are not mixins by themselves.
// - (16) All enum types are stripped off (i.e. replaced by their final base type).
// - (17) The 'key' property is removed from all elements of types.
// - (18) Managed associations in GROUP BY and ORDER BY are replaced by by their foreign key fields.
// - (19) Contexts that contain no artifacts or only ignored artifacts are ignored.
function transformForHana(inputModel, options) {
  // Work on a copy of the input model
  const { error, signal, getErrors } = alerts(inputModel);
  let model = deepCopy(inputModel);
  model.messages = inputModel.messages;
  const { flattenStructuredElement, flattenForeignKeys, checkForeignKeys,
          flattenStructStepsInPath, createForeignKeyElement, toFinalBaseType,
          setServiceProperty, addImplicitRedirections } = modelTransform.getTransformers(model);

  // Tell consumers that this model is meant to be rendered for HANA
  model.options = mergeOptions({ toHana: true }, inputModel.options, options);

  // For backward compatibility, supply default options if missing
  if (!model.options.toHana) {
    model.options = mergeOptions({ toHana : { names : 'deep', associations: 'assocs' } }, model.options);
  }

  // Check for not-yet-implemented options
  if (model.options.toHana.associations == 'joins') {
    const assoc2joins = require('./translateAssocsToJoins');
    model = assoc2joins.translateAssocsToJoins(model);
  }

  // (0z a) In "flat" mode, quoted ids are not allowed.
  // Here, check namespace declarations (only stored in model.sources).
  if (model.options.toHana.names == 'flat' && model.sources) {
    for (let s in model.sources) {
      if (model.sources[s].namespace && model.sources[s].namespace.path) {
        model.sources[s].namespace.path.filter(x => x.quoted).forEach(errorQuotedIdentifier);
      }
    }
  }

  // (00) - only for 'flat' names
  // For all elements, replace derived types by final base type
  // Needs to happen before renamePrimitiveTypes() or replaceUuidByString()
  if (model.options.toHana.names == 'flat') {
    baseModel.forEachDefinition(model, artifact => {
      baseModel.forEachMemberRecursively(artifact, member => {
        toFinalBaseType(member);
      });
    });
  }

  // Set '_service' property for all artifacts and sub-artifacts, for each service in the model
  setServiceProperty(model);

  // Perform implicit redirection of non-exposed association targets
  addImplicitRedirections(model);

  // Process all artifacts (pass 1)
  baseModel.forEachDefinition(model, artifact => {
    // (01)
    // Ignore entities and views that are abstract or implemented
    // or carry the annotatios cds.persistence.skip/exists
    // These entities are not removed from the model, but flagged as "to be ignored"
    if (artifact.kind == 'entity' || artifact.kind == 'view') {
      if (artifact.abstract ||
          artifact.impl ||
          hasBoolAnnotation(artifact, '@cds.persistence.skip')) {
        artifact._ignore = true;
      }
      else if (hasBoolAnnotation(artifact, '@cds.persistence.exists')) {
        artifact._ignore = true;
        artifact.impl = 'existsOnDB'; // used in toCdl to generate correct "using"
      }
    }
    // Some transformation for all kinds of artifacts
    transformCommon(artifact);
    // (09) Services and namespaces become contexts
    if (artifact.kind == 'service' || artifact.kind == 'namespace') {
      artifact.kind = 'context';
    }
    // Do things specific for entities and views (pass 1)
    if (artifact.kind == 'entity' || artifact.kind == 'view') {
      transformEntityOrViewPass1(artifact);
    }
    // (12 b) Strip inheritance
    delete artifact.includes;
    // (05) Ignore annotation declarations
    if (artifact.kind == 'annotation') {
      artifact._ignore = true;
    }
    // Process the artifact's  members
    baseModel.forEachMemberRecursively(artifact, member => {
      transformCommon(member);
      // (07 a) Ignore virtual elements
      if (member.virtual) {
        member._ignore = true;
      }
      // (07 b) Ignore the property 'masked' itself (but not its effect on projections)
      if (member.masked) {
        member._ignoreMasked = true;
      }
      // Treat inherited (not projected!) members as if they originated here
      if (member.origin && !artifact.query && member.kind !== 'key') {
        delete member.origin;
      }
      // Barf if a key is explicitly (!) nullable
      if (member.key && member.notNull && !member.notNull.val) {
        signal(error`"${artifact.name.absolute}.${member.name.element}": Key elements cannot be nullable in HANA CDS`, member.notNull.location);
      }
    });
  });

  // Process all artifacts (pass 2)
  // Perform toHana-specific checks that require the whole model to be processed
  // FIXME: Ideally, we could do this on-the-fly while processing artifacts, but because we do struct
  // flattening etc non-recursively, we need to wait till all artifacts are processed
  baseModel.forEachDefinition(model, artifact => {
    if (!artifact._ignore) {
      // Do things specific for entities and views (pass 1)
      if (artifact.kind == 'entity' || artifact.kind == 'view') {
        transformEntityOrViewPass2(artifact);
      }
      baseModel.forEachMemberRecursively(artifact, member => {
        // Check foreign keys of redirected associations
        if (!member._ignore && isAssociation(member.type)) {
          checkForeignKeys(member);
        }
        // (17) Strip 'key' property from type elements
        if (artifact.kind == 'type' && member.key) {
          delete member.key;
        }
      });

      // (18) Fix GROUP BY, ORDER BY in views
      if (isView(artifact)) {
        replaceAssociationsInGroupByOrderBy(artifact)
      }

      // (19) Weed out empty contexts (i.e. those that only have ignored content)
      if (artifact.kind == 'context' && getTopLevelArtifactNameOf(artifact.name.absolute) == artifact.name.absolute) {
        ignoreContextsWithIgnoredContent(artifact);
      }
    }
  });

  // Throw up if we have errors
  let errors = getErrors();
  if (errors.length > 0) {
    throw new CompilationError( sortMessages(errors), model)
  }

  return model;

  // Traverse artifact 'art', set '_ignore' for all contexts that only contain ignored artifacts
  function ignoreContextsWithIgnoredContent(art) {
    // We only care for non-ignored contexts
    if (art._ignore || art.kind != 'context') {
      return;
    }
    // Descend into children, note if any is non-ignored
    let hasNonIgnoredChildren = false;
    for (let childName in art.artifacts || {}) {
      let child = art.artifacts[childName];
      ignoreContextsWithIgnoredContent(child);
      if (!child._ignore) {
        hasNonIgnoredChildren = true;
      }
    }
    if (!hasNonIgnoredChildren) {
      // If we get here, the context was either empty or everything in it was ignored.
      // We currently preserve empty contexts - might also ignore them if we later decide so
      if (art.artifacts && Object.keys(art.artifacts).length > 0) {
        art._ignore = true;
      }
    }
  }

  // Perform transformations common to artifacts and members (in place)
  function transformCommon(obj) {
    // (0z b) In "flat" mode, quoted ids are not allowed. Here, check for artifact and
    // element definitions (ignore elements that have been added by postprocessing steps.)
    if (model.options.toHana.names == 'flat' && !obj.viaTransform) {
      if (obj.name.path) {
        obj.name.path.filter(x => x.quoted).forEach(errorQuotedIdentifier);
      }
      else if (obj.name.quoted) {
        errorQuotedIdentifier(obj.name);
      }
    }
    // (02) Rename HANA-specific types
    renamePrimitiveTypes(obj);
    renamePrimitiveTypes(obj.items);
    // (03) Replace type UUID by String(36)
    replaceUuidByString(obj);
    replaceUuidByString(obj.items);
    // (04) Supply default length 5000 for strings if not specified
    // FIXME: Do we really want this?
    addDefaultStringLength(obj);
    addDefaultStringLength(obj.items);
    // (05 b) Strip annotation assignments
    for (let name in obj) {
      if (name.startsWith('@')) {
        delete obj[name];
      }
    }
    // (06) Compositions become associations
    if (obj.type && obj.type.absolute && obj.type.absolute == 'cds.Composition') {
      obj.type.absolute = 'cds.Association';
      baseModel.setProp(obj.type, '_artifact', model.definitions['cds.Association']);
    }
    // (07 c) Remove attribute 'localized'
    delete obj.localized;
    // (05 a) and (08) Ignore annotation declarations, actions and functions
    if (obj.kind == 'annotation' || obj.kind == 'action' || obj.kind == 'function') {
      obj._ignore = true;
    }
    // Check type parameters (length, precision, scale ...)
    if (!obj._ignore && obj.type) {
      checkTypeParameters(obj, model);
    }
    if (!obj._ignore && obj.items && obj.items.type) {
      checkTypeParameters(obj.items, model);
    }
  }

  // Issue an error for a quoted identifier in toHana, flat mode
  function errorQuotedIdentifier(obj) {
    signal(error`Quoted identifiers are not allowed in flat mode of toHana: "${obj.id}"`, obj.location);
  }

  // If 'obj' has one of the primitive types that have a different name in HANA,
  // rename the type accordingly
  function renamePrimitiveTypes(obj) {
    const hanaNames = {
      'cds.DateTime' : 'UTCDateTime',
      'cds.Timestamp' : 'UTCTimestamp',
      'cds.Date' : 'LocalDate',
      'cds.Time' : 'LocalTime'
    }
    if (obj && obj.type && obj.type.absolute in hanaNames) {
      obj.type.absolute = hanaNames[obj.type.absolute];
    }
  }

  // If 'obj' has primitive type 'cds.UUID', make it a cds.String(36)
  function replaceUuidByString(obj) {
    if (obj && obj.type && obj.type._artifact == model.definitions['cds.UUID']) {
      obj.type = { absolute: 'cds.String' };
      baseModel.setProp(obj.type, '_artifact', model.definitions['cds.String']);
      baseModel.setProp(obj, '_finalType', obj);
      obj.length = { literal: 'number', val: 36 };
    }
  }

  // If 'obj' has primitive type 'cds.String' and no length, add default length 5000
  function addDefaultStringLength(obj) {
    if (obj && obj.type && obj.type.absolute && obj.type.absolute == 'cds.String' && !obj.length) {
      obj.length = { literal: 'number', val: 5000 }
    }
  }

  // Perform first pass of all transformations required for an entity or a projection entity or a view (in place)
  function transformEntityOrViewPass1(art) {
    // (10) First walk through the entity elements: Flatten structs (might result in new elements)
    for (let elemName in art.elements) {
      let elem = art.elements[elemName];
      if (isStructuredElement(elem)) {
        // Ignore the structured element, replace it by its flattened form
        elem._ignore = true;
        let flatElems = flattenStructuredElement(elem);
        for (let flatElemName in flatElems) {
          if (art.elements[flatElemName]) {
            signal(error`"${art.name.absolute}.${elemName}": Flattened struct element name conflicts with existing element: "${flatElemName}"`, elem.location);
          }
          art.elements[flatElemName] = flatElems[flatElemName];
          // FIXME: Should also adapt indexNo of the newly added elements and all subsequent ones
        }
      }
    }

    // Flatten structs in indexes and partitions
    let tc = art.technicalConfig;
    if (tc) {
      // Secondary and fulltext indexes
      for (let name in tc.indexes) {
        let index = tc.indexes[name];
        // Array of indexes is an error: multiple index definitions with same name.
        // However, if it has survived until here, behave correctly
        if (Array.isArray(index)) {
          index.forEach(idx => {
            checkFTIColumns(idx);
            flattenStructuredColumnPaths(idx.columns);
          });
        }
        else {
          checkFTIColumns(index);
          flattenStructuredColumnPaths(index.columns);
        }
      }
      if (tc.fzindexes) {
        tc.fzindexes.forEach(idx =>  {
          flattenStructuredColumnPaths(idx.columns);
        });
      }
      // Partition columns
      if (tc.partition) {
        tc.partition.specs.forEach(spec => flattenStructuredColumnPaths(spec.columns));
      }
    }

    function checkFTIColumns(index) {
      if(index.kind === 'fulltextindex') {
        index.columns.filter(col => isStructuredElement(col._artifact)).forEach(col => {
          signal(error`"${art.name.absolute}": A fulltext index cannot be defined on a structured element "${col._artifact.name.absolute}`,
          col.location);
        });
      }
    }

    // Flatten structs used in paths
    foreachPath(art, (path, pathOwner) => {
      pathOwner.path = flattenStructStepsInPath(path);
    });

    // after all paths have been flattened "a_b_c", assign fuzzy index definitions
    // to the flattened element
    if (tc && tc.fzindexes) {
      tc.fzindexes.forEach(idx =>  {
        idx.columns.forEach(col => {
          if(!col._ignore) {
            art.elements[col.path[0].id]._fzindex = idx; // last one wins on multiple occurences
          }
        });
      });
    }

    // Second walk through the entity elements: Deal with associations (might also result in new elements)
    for (let elemName in art.elements) {
      let elem = art.elements[elemName];
      // Magic special case: If a fully fledged element was extended into a projection
      // (recognizable by not having a value), it must be an unmanaged association (because only
      // those can be "added" into the MIXIN of the resulting view
      if (isProjection(art) && !elem.value) {
        if (!isAssociation(elem.type) || isManagedAssociationElement(elem)) {
          // Not an unmanaged association
          signal(error`"${art.name.absolute}.${elem.name.element}": Only unmanaged associations can be extended into projections with --to-hana`,
          elem.location);
        } else {
          // Unmanaged association: OK, construct an artificial value (otherwise toCdl would omit this element
          // from the projection list)
          elem.value = {
            path: [{ id: elemName }],
            absolute: elem.absolute,
            element: elemName,
          };
          elem.name.calculated = true;
          // FIXME: Cannot construct a proper _artifact here
        }
      }

      // (11) Generate foreign key elements and ON-condition for managed associations
      if (isManagedAssociationElement(elem)) {
        // Aliased foreign keys in managed associations not yet allowed (only check for non-projections, to avoid duplicate errors)
        if (!elem._main.source) {
          for (let name in elem.foreignKeys) {
            let foreignKey = elem.foreignKeys[name]
            if (!foreignKey.calculated && !foreignKey.name.calculated) {
              signal(error`"${elem.name.absolute}.${elem.name.element}": Aliases for foreign keys are not supported yet with --to-hana`,
                     elem.foreignKeys[name].location);
            }
          }
        }
        // Flatten foreign keys (replacing foreign keys that are managed associations by their respective foreign keys)
        elem.foreignKeys = flattenForeignKeys(elem.foreignKeys);
        // Generate foreign key elements for managed associations, and assemble an ON-condition with them
        let onCondParts = [];
        for (let name in elem.foreignKeys) {
          let foreignKey = elem.foreignKeys[name]
          // Sanity check
          if (!foreignKey.targetElement.path) {
            throw Error('Expecting foreign key ' + printableName(foreignKey) + ' to have a path');
          }
          // Assemble left hand side of 'assoc.key = fkey'
          let assocKeyArg = {
            path: [ { id: elem.name.id } ].concat(foreignKey.targetElement.path),
            absolute: foreignKey.name.absolute,
            element: foreignKey.name.id,
          }
          baseModel.setProp(assocKeyArg, '_artifact', foreignKey._artifact);
          // Assemble right hand side of 'assoc.key = fkey'
          let foreignKeyElement = createForeignKeyElement(elem, foreignKey);
          let fKeyArg = {
            path: [ { id: foreignKeyElement.name.id } ],
            absolute: foreignKeyElement.name.absolute,
            element: foreignKeyElement.name.id
          }
          baseModel.setProp(fKeyArg, '_artifact', foreignKey._artifact);
          onCondParts.push({ op: {val:'=', location: elem.location}, args : [ assocKeyArg, fKeyArg ]});
        }
        if (onCondParts.length == 1) {
          // Only one key-fkey comparison
          elem.onCond = onCondParts[0];
        } else {
          // Multiple key-fkey comparisons - join with 'and'
          elem.onCond = { op: {val:'and', location: elem.location}, args: onCondParts };
        }

        // If the managed association has a 'key' property => remove it as unmanaged assocs cannot be keys
        // TODO: Are there other modifiers (like 'key') that are valid for managed, but not valid for unmanaged assocs?
        if (elem.key && elem.key.val) {
          delete elem.key;
        }

        // If the managed association has a 'not null' property => remove it
        if (elem.notNull && elem.notNull.val) {
          delete elem.notNull;
        }

        // The association is now unmanaged, i.e. actually it should no longer have foreign keys
        // at all. But the processing of backlink associations below expects to have them, so
        // we don't delete them (but mark them as implicit so that toCdl does not render them)
        elem.implicitForeignKeys = true;
      }

      // Workaround for bugzilla 176495
      // If a select item of a cdx view contains an expression, the result type cannot be computed
      // but must be explicitly specified. This is important for the OData channel, which doesn't
      // work if the type is missing (for HANA channel an explicit type is not required, as HANA CDS
      // can compute the result type).
      // Due to bug in HANA CDS, providing explicit type 'LargeString' or 'LargeBinary' causes a
      // diserver crash. Until a fix in HANA CDS is available, we allow to suppress the explicit
      // type in the HANA channel via an annotation.
      if ((isProjection(art) || isView(art)) && elem["@cds.workaround.noExplicitTypeForHANA"]) {
        delete elem._typeIsExplicit;
      }
    }

    /*
      For each path node of the columns array do:
        1) Store current path node in newColumns
        2) If the column path terminates in a structured type:
           (but not a managed association, this requires much more effort!)
          2a) Generate all leaf paths originating from this structured type.
              Every path step of the new leaf paths has an _artifact reference to
              it's corresponding definition element.
              Prepend the column path as prefix to all leaf paths and create a new path object
              with attributes { path, absolute, element, _artifact, calculated: true }
          2b) Propagate all properties from original path node to the resulting flattened path
              node, except for [ path, absolute, element, location, calculated ].
          2c) Set leaf _artifact as _artifact to flattened path node.
          2d) Add the new path node to newColumns.
          2e) Mark the original path node with _ignore=true.
        3) Replace the content of original columns with the content of newColumns if required
    */
    function flattenStructuredColumnPaths(columns) {
      if (columns === undefined) {
        return;
      }
      let newColumns = [];
      columns.forEach(col => {
        newColumns.push(col);
        if (col._artifact.elements) {
          let flattenedPaths = getLeafPathsForStructuredElement(col._artifact, col.path);
          flattenedPaths.forEach(fp => {
            let flatCol = { path: fp, absolute: col.absolute, 
              element: fp.map(f=>f.id).join('.'), calculated: true };
            Object.keys(col).forEach(k => {
              if (!['path', 'absolute', 'element', 'location', 'calculated'].includes(k))
                flatCol[k] = col[k];
            });
            baseModel.setProp(flatCol, '_artifact', fp[fp.length-1]._artifact);
            newColumns.push(flatCol);
          });
          col._ignore = true;
        }
      });
      if (columns.length < newColumns.length) {
        columns.splice(0, columns.length, ...newColumns);
      }

      function getLeafPathsForStructuredElement(elt, prefixPath=[]) {
        let paths = [];
        if (elt.elements) {
          for (let name in elt.elements) {
            let sub = elt.elements[name];
            paths = paths.concat(getLeafPathsForStructuredElement(sub, [ newPathStep(sub) ]) );
          }
          return paths.map(p => prefixPath.concat(p));
        }
        else {
          return prefixPath;
        }

        function newPathStep(elt) {
          let node = { id: elt.name.id };
          baseModel.setProp(node, '_artifact', elt);
          return node;
        }
      }
    }
  }

  // Perform all transformations required for an entity or a projection entity or a view (in place)
  function transformEntityOrViewPass2(art) {
    // Second walk through the entity elements: Deal with associations (might also result in new elements)
    for (let elemName in art.elements) {
      let elem = art.elements[elemName];

      // (14) Transform '$self' in backlink associations to appropriate key comparisons
      if (isAssociation(elem.type)) {
        processBacklinkAssoc(elem);
      }

      // (15 a) An association element in a projection or a view that is defined in a mixin must not
      // be explicitly redirected
      // TODO: consider moving this check to the compiler or a general check phase
      if ((isProjection(art) || isView(art))
          && isAssociation(elem.type)
          && (elem.value && elem.value.path && elem.value.path.length == 1 && art.query && art.query.mixin && art.query.mixin[elem.value.path[0].id])
          && elem.redirected) {
        signal(error`Association elements defined in a mixin must not be redirected: "${elem.value.path[0].id}"`, elem.location);
      }

      // (15 b) Create MIXINs for association elements in projections or views (those that are not mixins by themselves)
      if ((isProjection(art) || isView(art)) && isAssociation(elem.type)
          && !(elem.value && elem.value.path && elem.value.path.length == 1 && art.query && art.query.mixin && art.query.mixin[elem.value.path[0].id])) {
        // Suppress redirections (and the '_typeIsExplicit' that seems to come with it)
        delete elem.redirected;
        delete elem._typeIsExplicit;
        // Create an unused alias name for the MIXIN
        let mixinElemName = '__' + elemName;
        while (art.elements[mixinElemName]) {
          mixinElemName = '_' + mixinElemName;
        }
        // Copy the association element to the MIXIN clause under its alias name
        // (shallow copy is sufficient, just fix name and value)
        let mixinElem = Object.assign({}, elem);
        mixinElem.name = Object.assign({}, elem.name, { id: mixinElemName, element: mixinElemName });
        baseModel.setProp(mixinElem, '_finalType', elem._finalType);
        baseModel.setProp(mixinElem, '_main', elem._main);
        baseModel.setProp(mixinElem, '_parent', elem._parent);
        mixinElem.value = Object.assign({}, elem.value);
        // FIXME: Remove once the compactor no longer renders 'origin'
        mixinElem.origin = mixinElem.value;
        // Perform common transformations on the newly generated MIXIN element (won't be reached otherwise)
        transformCommon(mixinElem);
        if (!art.query.mixin) {
          art.query.mixin = Object.create(null);
        }
        art.query.mixin[mixinElemName] = mixinElem;
        // Let the original association element use the newly generated MIXIN name as value and alias
        delete elem.viaAll;
        delete elem.name.calculated;
        if (!elem.value) {
          elem.value = {
            absolute : art.name.absolute
          };
        }
        elem.value.path = [{ id : mixinElemName }];
        elem.value.element = mixinElemName;
        // FIXME: Remove once the compactor no longer renders 'origin'
        elem.origin = elem.value;
        // Clone 'onCond', prepending '$projection' to paths where appropriate,
        // and fixing the association alias just created
        if (mixinElem.onCond) {
          mixinElem.onCond = baseModel.cloneWithTransformations(mixinElem.onCond, {
            path: (path, pathOwner, clonedPathOwner) => {
              // Clone the path, without any transformations (unfortunately stripping off '_artifact')
              let clonedPath = baseModel.cloneWithTransformations(path, {});
              // Restore '_artifact' for the path steps
              for (let i = 0; i < path.length; i++) {
                baseModel.setProp(clonedPath[i], '_artifact', path[i]._artifact);
              }
              // Restore '_artifact' for the object within which 'path' was found
              if (pathOwner._artifact) {
                baseModel.setProp(clonedPathOwner, '_artifact', pathOwner._artifact);
              }
              // Prepend '$projection' to the path, unless the first path step is the (mixin) element itself or '$projection')
              if (clonedPath[0].id == elemName) {
                clonedPath[0].id = mixinElemName;
              } else if (clonedPath[0].id != '$projection') {
                let projectionId = { id: '$projection' };
                baseModel.setProp(projectionId, '_artifact', art);
                clonedPath.unshift(projectionId);
              }
              return clonedPath;
            },
            func: (func) => {
              // Unfortunately, function names are disguised as paths, so we would prepend a '$projection'
              // above (no way to distinguish that in the callback for 'path' above). We can only pluck it
              // off again here ... sigh
              if (func.path && func.path[0] && func.path[0].id == '$projection') {
                func.path = func.path.slice(1);
              }
              return func;
            }
          });
        }
      }
    }

    // Third walk through the entity/view elements: All artificial elements in place, do whatever processing is needed on them
    for (let elemName in art.elements) {
      let elem = art.elements[elemName];
      // (16) Replace enum types by their final base type
      if (elem._finalType && elem._finalType.enum) {
        elem.type = elem._finalType.type;
        if (elem._finalType.length) {
          elem.length = elem._finalType.length;
        }
        delete elem.enum;
      }
    }

    // (13) Projections now finally become views
    if (isProjection(art)) {
      art.kind = 'view';
    }

    // If the association 'assoc' is a backlink association, massage its ON-condition (in place) so that
    // it compares the appropriate keys with their corresponding foreign key fields. Otherwise, do nothing.
    function processBacklinkAssoc(assoc) {
      let currentArt = assoc._main; // current entity to which will compare for a backlink assoc
      if (isBacklinkAssociation(assoc, currentArt)) {
        let expressions = collectAllSimpleExpressions(assoc.onCond);
        expressions.forEach(expr => {
          if (isBacklinkComparison(expr, currentArt, assoc)) { // should be only one in an array of expressions
            let assocSide = expr.args.find(e => {
              return e._artifact !== currentArt;
            });
            if (assocSide._artifact.foreignKeys) // the case when the not '$self'-containing association is managed one
              transformAugmOnCondForManagedAssoc(expr, assocSide, assoc.name.element);
            else if (assocSide._artifact.onCond) // when the not '$self'-containing association is unmanaged one
              transformAugmOnCondForUnmanagedAssoc(expr, assocSide, assoc.name.element);
          }
        })
      }

      // Takes the simple condition which contains the $self part and transforms it into the desired form with the replaced $self identifier
      // e.g. a: association to B on a.<assoc_in_B> = $self; becomes a : association to B on a.<assoc_in_B>_<key_name1> = <key_name1> and a.<assoc_in_B>_<key_name2> = <key_name2> ...;
      function transformAugmOnCondForManagedAssoc(cond, assoc, selfAssocName) {
        let loc = cond.location;
        let keys = Object.keys(assoc._artifact.foreignKeys);
        // if the element was structured then it was flattened => change of the delimiter from '.' to '_'
        // this is done in the flattening, but as we do not alter the onCond itself there should be done here as well
        let nonSelfAssocName = assoc.element.replace(/\./g, '_');
        selfAssocName = selfAssocName.replace(/\./g, '_');
        if (keys.length > 1) {
          cond.op = {val:'and',location:loc};
          cond.args = [];
        } else
          cond.op = {val:'=',location:loc};
        keys.forEach(k => {
          // FIXME: _artifact to the args ???
          let a = [
            {
              path: [{ id: selfAssocName, location: loc }, { id: `${nonSelfAssocName}_${k}`, location: loc }], location: loc
            },
            {
              path: [{ id: k, location: loc }], location: loc
            }
          ];
          if (keys.length > 1)
            cond.args.push({
              op: {val:'=',location:loc},
              args: a,
              location: loc
            });
          else
            cond.args = a;
        });
      }

      // Takes the simple condition which contains the $self identifier =>
      // => replace it with the reversed onCond from the non $self-containing association as correctly seen from the $self-containing association
      // e.g. entity A {
      // 	a : Integer;
      // 	c : Integer;
      // 	// originally => toB : association to B on toB.toA = $self and 1 = 1;
      // 	toB : association to B on a = toB.b and c = toB.d and 1 = 1;
      // };
      // entity B {
      // 	b : Integer;
      // 	d : Integer;
      // 	toA : association to A on toA.a = b and toA.c = d;
      // };
      function transformAugmOnCondForUnmanagedAssoc(cond, assoc, selfAssocName) {
        let loc = cond.location;
        // if the element was structured then it was flattened => change of the delimiter from '.' to '_'
        // this is done in the flattening, but as we do not alter the onCond itself there should be done here as well
        selfAssocName = selfAssocName.replace(/\./g, '_');
        let forwardAssocName = assoc._artifact.name.element.replace(/\./g, '_');
        // clone the onCond for later use in the path transformation,
        // also assign the _artifact elements of the path elements to the copy
        let newOnCond = cloneWithTransformations(assoc._artifact.onCond, {
          path: (value, node, resultNode) => {
            resultNode = cloneWithTransformations(value, {});
            resultNode.forEach((element, index) => {
              baseModel.setProp(element, '_artifact', value[index]._artifact);
            });
            return resultNode;
          }
        });
        // goes through the the newOnCond and transform all the 'path' elements
        foreachPath(newOnCond, (path) => {
          if (path[0].id === forwardAssocName) // we are in the "path" from the forwarding assoc => need to remove the first part of the path
            path.shift();
          else { // we are in the backlink assoc "path" => need to push at the beginning the association's id
            path.unshift({ id: selfAssocName, location: loc });
            // if there was a $self identifier in the forwarding association onCond
            // we do not need it any more, as we prepended in the previous step the back association's id
            if (path[1].id === '$self')
              path.splice(1, 1);
          }
        });
        Object.assign(cond, newOnCond);
      }

      // For a condition 'onCond', collect all sub-conditions (recursively) into the array 'simpleConditions'
      // that have at least one path argument
      // FIXME: Shouldn't we simply look for '=' comparisons wher left and right is a path, recursively?
      function collectAllSimpleExpressions(cond) {
        let simpleExpressions = [];
        if (!cond.args) // on condition with function
          return simpleExpressions;
        if (cond.args.some(a => {
          return a.path ? true : false;
        }))
          simpleExpressions.push(cond); // if some of the arguments has path-> put it into the array for check afterwards if it is a backling assoc
        cond.args.filter(a => {
          return !a.path; // if some of the sides of 'cond' may contain a condition itself -> go into it recursively
        }).forEach(a => {
          simpleExpressions.push(...collectAllSimpleExpressions(a));
        })
        return simpleExpressions;
      }

      // Return true is the passed assocation is backlink, false if it is not
      function isBacklinkAssociation(assoc, currentArt) {
        if (!assoc.onCond) // managed assoc
          return false;
        let expressions = collectAllSimpleExpressions(assoc.onCond);
        if (expressions.some(expr => isBacklinkComparison(expr, currentArt, assoc)))
          return true;
        return false;
      }

      // For an expression 'expr' checks if it fulfills the conditions the association to be a backlink one
      // and returns true or false respectively
      // The result is false when one of the following is violated:
      // 1. The comparison must be '='
      // 2. Not self part of the expression must be a path
      // 3. Only one operand must be $self
      // 4. Self part must have only '$self', but not '$self.a.b...'
      // 5. Not self path must have at least two steps
      // 6. Not self path must end with an association
      // 7. Not self path must contain two associations
      // 8. The first one from point 7 must be the current association element
      // 9. The second association from point 7 must point back to the current entity
      // 10. The second association from point 7 must not be a backlink assocation
      function isBacklinkComparison(expr, currentArt, currentElem) {
        // 1. comparison must be '='
        if (expr.op.val !== '=')
          return false;
        // 2. operand must be a path
        // in augmented csn '$self' is also a path
        if (expr.args.some(a => !a.path))
          return false;
        if (expr.args.some(a => a.path && a.path[0].id === '$self')) {
          let selfSide = expr.args.find(a => a.path && a.path[0].id === '$self');
          let notSelf = expr.args.find(a => a.path && a.path[0].id !== '$self');
          // 3. only one operand can be '$self'
          if (expr.args.every(a => a.path && a.path[0].id === '$self'))
            return false;
          // 4. operand must be '$self', but not '$self.a.b...'
          if (selfSide.path.length > 1)
            return false;
          // 5. path must have at least two steps
          if (notSelf.path.length < 2)
            return false;
          // 6. <notself> path must end with an association
          if (notSelf.path.slice(-1)[0]._artifact.type.absolute !== 'cds.Association')
            return false;
          let notSelfAssocs = notSelf.path.filter(p => p._artifact.type.absolute === 'cds.Association')
          // 7. <notself> path must contain two associations
          if (notSelfAssocs.length !== 2)
            return false;
          // 8. the first one must be the current association element
          if (notSelfAssocs[0]._artifact.name.absolute !== currentElem.name.absolute
            && notSelfAssocs[0]._artifact.name.element !== currentElem.name.element
            && notSelfAssocs[0]._artifact.target !== currentElem.target)
            return false;
          // 9. the second association must point back
          if (currentArt.source ?
            (notSelfAssocs[1]._artifact.target._artifact.name.absolute !== currentArt.source._artifact.name.absolute
              && notSelfAssocs[1]._artifact.target._artifact.name.id !== currentArt.source._artifact.name.id)
            :
            (notSelfAssocs[1]._artifact.target._artifact.name.absolute !== currentArt.name.absolute
              && notSelfAssocs[1]._artifact.target._artifact.name.id !== currentArt.name.id)
          )
            return false;
          // 10. the second association must not be a backlink assocaition
          if (isBacklinkAssociation(notSelfAssocs[1], currentArt))
            return false;
          return true;
        }
        return false;
      }
    }
  }

  // Replace (formerly) managed associations in GROUP BY and ORDER BY of 'view' by their foreign key fields. Complain about unmanaged assocs.
  function replaceAssociationsInGroupByOrderBy(view) {
    for (let query of view.queries) {
      if (query.groupBy) {
        let result = [];
        // Walk the GROUP BY entries, replace assocs by their foreign keys
        for (let groupByEntry of query.groupBy) {
          if (groupByEntry._artifact && groupByEntry._artifact.foreignKeys) {
            // This used to be a managed assoc - walk its (original) fkeys (apparently, the _artifact of
            // the GROUP-BY entry points to something in the view which does have all properties of the original
            // fkeys, so we need to dig up '_finalType' ...)
            // Sanity check
            if (!groupByEntry._artifact._finalType || !groupByEntry._artifact._finalType.foreignKeys) {
              throw new Error("Expecting GROUP BY entry's artifact's _finalType to have foreign keys");
            }
            let foreignKeys = groupByEntry._artifact._finalType.foreignKeys;
            for (let foreignKeyName in foreignKeys) {
              let foreignKey = foreignKeys[foreignKeyName];
              // Sanity check
              if (!foreignKey.generatedFieldName) {
                throw new Error('Expecting generated field name for foreign key: ' + JSON.stringify(foreignKey));
              }
              // For each fkey, assemble a new GROUP BY entry that looks like one with the assoc, replacing the last path step
              let newPath = groupByEntry.path.slice(0, -1);
              newPath.push({
                id : foreignKey.generatedFieldName,
              });
              result.push(Object.assign({}, groupByEntry, { path : newPath, element : foreignKey.generatedFieldName }));
              // FIXME: We don't bother to reconstruct _artifact links here (hopefully they won't be needed)
            }
          } else {
            // Not a formerly unmanaged association - take as it is
            result.push(groupByEntry);
          }
        }
        query.groupBy = result;
      }
      // Unfortunately, ORDER BY entries look slightly different, so we can't easily reuse what we have above
      // FIXME: Maybe simplify this one day ... ugly!
      if (query.orderBy) {
        let result = [];
        // Walk the ORDER BY entries, replace assocs by their foreign keys
        for (let orderByEntry of query.orderBy) {
          if (orderByEntry.value && orderByEntry.value._artifact && orderByEntry.value._artifact.foreignKeys) {
            // This used to be a managed assoc - walk its (original) fkeys (apparently, the _artifact of
            // the ORDER-BY entry points to something in the view which does have all properties of the original
            // fkeys, so we need to dig up 'origin' ...)
            // Sanity check
            if (!orderByEntry.value._artifact._finalType || !orderByEntry.value._artifact._finalType.foreignKeys) {
              throw new Error("Expecting ORDER BY entry's artifact's _finalType to have foreign keys");
            }
            let foreignKeys = orderByEntry.value._artifact._finalType.foreignKeys;
            for (let foreignKeyName in foreignKeys) {
              let foreignKey = foreignKeys[foreignKeyName];
              // Sanity check
              if (!foreignKey.generatedFieldName) {
                throw new Error('Expecting generated field name for foreign key: ' + JSON.stringify(foreignKey));
              }
              // For each fkey, assemble a new ORDER BY entry that looks like one with the assoc, replacing the last path step
              let newPath = orderByEntry.value.path.slice(0, -1);
              newPath.push({
                id : foreignKey.generatedFieldName,
              });
              let newValue = Object.assign({}, orderByEntry.value, { path : newPath, element : foreignKey.generatedFieldName });
              result.push(Object.assign({}, orderByEntry, { value: newValue }));
              // FIXME: We don't bother to reconstruct _artifact links here (hopefully they won't be needed)
            }
          } else {
            // Not a formerly unmanaged association - take as it is
            result.push(orderByEntry);
          }
        }
        query.orderBy = result;
      }
    }
  }
}

module.exports = {
  transformForHana
};
