'use strict';

// A "tools" collection of various transformation functions that might be helpful for
// different backends.

const baseModel = require('../base/model');
const { addStringAnnotationTo, printableName,
        copyAnnotations, isStructuredElement, hasBoolAnnotation } = require('./modelUtils');
const alerts = require('../base/alerts');

// Return the public functions of this module, with 'model' captured in a closure (for options etc)
function getTransformers(model) {
  const { error, signal } = alerts(model);
  let options = model.options;

  return {
    flattenForeignKeys,
    createForeignKeyElement,
    checkForeignKeys,
    flattenStructuredElement,
    flattenStructStepsInPath,
    preprocessAction,
    setServiceProperty,
    checkExposedAssoc,
    toFinalBaseType,
    addImplicitRedirections,
  };

  // For a dictionary `foreignKeys` of foreign key infos, return a dictionary in flattened form, i.e.
  // replace all foreign keys that are managed associations themselves by their respective foreign keys,
  // recursively, with names flattened using '_' between path components.
  function flattenForeignKeys(foreignKeys) {
    // (TNT only): Use <assoc><key> instead of <assoc>_key>
    let fkSeparator = (options.tntFlavor && !options.tntFlavor.skipGeneratedFKsWithout_) ? '' : '_';

    let result = Object.create(null);
    for (let name in foreignKeys) {
      let foreignKey = foreignKeys[name];
      // Sanity checks
      if (!foreignKey.targetElement) {
        throw Error('Expecting foreign key ' + printableName(foreignKey) + ' to have targetElement');
      }
      if (!foreignKey.name.absolute || !foreignKey.name.element) {
        throw Error('Expecting foreign key ' + printableName(foreignKey) + ' to have absolute name and element name');
      }
      let fkArtifact = foreignKey.targetElement._artifact;
      if (!fkArtifact) {
        throw Error('Expecting foreign key ' + printableName(foreignKey) + ' to be resolved');
      }
      if (fkArtifact.target) {
        // Foreign key is itself a managed association: Replace by its target foreign keys
        // (In other words, use the target's generated foreign key fields as foreign keys)
        let targetForeignKeys = flattenForeignKeys(fkArtifact.foreignKeys);
        for (let targetForeignKeyName in targetForeignKeys) {
          let targetForeignKey = targetForeignKeys[targetForeignKeyName];
          let targetGeneratedForeignKeyFieldName = name + fkSeparator + targetForeignKeyName;
          let resultForeignKey = {
            name: {
              id: targetGeneratedForeignKeyFieldName,
              absolute: foreignKey.name.absolute,
              element: name + '.' + targetGeneratedForeignKeyFieldName,
              viaTransform: true
            },
            kind: 'key',
            targetElement: { path: [ { id: targetGeneratedForeignKeyFieldName } ] },
          };
          baseModel.setProp(resultForeignKey, '_parent', foreignKey._parent);
          baseModel.setProp(resultForeignKey, '_main', foreignKey._main);
          // FIXME: _artifact should actually point to the generated target foreign key element here (and not
          // (to the corresponding target foreign key itself), but because we generate foreign key elements
          // iteratively, not recursively, we cannot rely on generated foreign key elements in other entities
          // to exist yet. But doing it like this will be quite sufficient as a workaround, because target
          // foreign key and generated target foreign key element have all properties that we might inspect
          // on _artifact in common (type, annotations, ... we only ever inspect them in order to copy them,
          // after all)
          baseModel.setProp(resultForeignKey.targetElement, '_artifact', targetForeignKey.targetElement._artifact);
          result[name + fkSeparator + targetForeignKeyName] = resultForeignKey;
        }
      } else if (isStructuredElement(fkArtifact)) {
        // Foreign key is structured: Replace by its flattened elements (which unfortunately might not exist yet,
        // because we do the flattening iteratively and the artifact containing the structured key might not have been
        // processed yet. As above, we use the actual key elements as a standin for _artifact)
        let flatKeyElements = flattenStructuredElement(fkArtifact);
        for (let flatElemName in flatKeyElements) {
          let flatElem = flatKeyElements[flatElemName];
          let resultForeignKey = {
            name: {
              id: flatElemName,
              absolute: foreignKey.name.absolute,
              element: flatElemName,
              viaTransform: true
            },
            kind: 'key',
            targetElement: { path: [ { id: flatElemName } ] },
          };
          baseModel.setProp(resultForeignKey, '_parent', foreignKey._parent);
          baseModel.setProp(resultForeignKey, '_main', foreignKey._main);
          baseModel.setProp(resultForeignKey.targetElement, '_artifact', flatElem);
          result[flatElemName] = resultForeignKey;
        }
      } else {
        // Otherwise simply take as it is
        result[name] = foreignKey;
      }
    }
    return result;
  }

  // Create an artificial foreign key element for association 'assoc' (possibly part
  // of nested struct, i.e. containing dots), using foreign key info from 'foreignKey',
  // inserting it into 'elements' of the assoc's main artifact. Add a property
  // 'generatedFieldName' to the corresponding 'foreignKey' of the assoc.
  // Return the newly generated foreign key element.
  function createForeignKeyElement(assoc, foreignKey) {
    let fkArtifact = foreignKey.targetElement._artifact;
    // Sanity checks
    if (!fkArtifact) {
      throw Error('Expecting foreign key for ' + printableName(assoc) + ' to be resolved');
    }
    if (!assoc.name.absolute || !assoc.name.element) {
      throw Error('Expecting association ' + printableName(assoc) + ' to have absolute name and element name');
    }
    if (assoc._main == undefined) {
      throw Error('Expecting association ' + printableName(assoc) + ' to have a main artifact');
    }
    if (fkArtifact.target) {
      throw Error('Not expecting foreign key of association ' + printableName(assoc) + ' to be an association after flattening')
    }
    if (fkArtifact.type == undefined) {
      throw Error('Expecting artifact of foreign key for ' + printableName(assoc) + ' to have a type');
    }

    // (TNT only): Use <assoc><key> instead of <assoc>_key>
    let fkSeparator = (options.tntFlavor && !options.tntFlavor.skipGeneratedFKsWithout_) ? '' : '_';

    // Assemble foreign key element name from assoc name, '_' and foreign key name/alias
    let foreignKeyElementName = assoc.name.element.replace(/\./g, '_') + fkSeparator + foreignKey.name.id;
    // Assemble artificial foreign key element
    let foreignKeyElement = {
      name:  {
        id: foreignKeyElementName,
        absolute: assoc.name.absolute,
        element: foreignKeyElementName,
        calculated: true,
        viaTransform: true
      },
      kind: 'element',
      type: {
        absolute: fkArtifact.type.absolute, // TODO: enough?
      },
    };
    // Transfer selected type properties from target key element
    for (let prop of ['length', 'scale', 'precision']) {
      if (fkArtifact[prop]) {
        foreignKeyElement[prop] = fkArtifact[prop];
      }
    }
    baseModel.setProp(foreignKeyElement.type, '_artifact', fkArtifact.type._artifact);
    // If the association is non-fkArtifact resp. key, so should be the foreign key field
    for (let prop of ['notNull', 'key']) {
      if (assoc[prop]) {
        foreignKeyElement[prop] = Object.assign({}, assoc[prop]);
      }
    }

    // If the association was a projection or view element (i.e. it has a 'value'), construct a
    // corresponding 'value' for the generated foreign key element
    // FIXME: Can't resolve the corresponding _artifact links because they might not yet be created.
    // We currently live without them.
    if (assoc.value) {
      let valueForeignKeyElementName = assoc.value.element.replace(/\./g, '_') + fkSeparator + foreignKey.name.id;
      foreignKeyElement.value = {
        path: [{ id: valueForeignKeyElementName }],
        absolute: assoc.value.absolute,
        element: valueForeignKeyElementName,
        viaTransform: true, // FIXME: Do we still need this?
      }
      // FIXME: Remove once the compactor no longer renders 'origin'
      if (assoc.origin) {
        foreignKeyElement.origin = foreignKeyElement.value;
      }
    }

    // Insert artificial element into assoc's main artifact, with all cross-links (must not exist already)
    let artifact = assoc._main;
    if (artifact.elements[foreignKeyElementName]) {
      signal(error`Generated foreign key element "${foreignKeyElementName}" for association "${assoc.name.absolute}.${assoc.name.element}" conflicts with existing element`, assoc.location);
    }
    artifact.elements[foreignKeyElementName] = foreignKeyElement;
    baseModel.setProp(foreignKeyElement, '_parent', artifact);
    baseModel.setProp(foreignKeyElement, '_main', artifact);
    baseModel.setProp(foreignKeyElement, '_finalType', fkArtifact._finalType);

    // Establish the relationship between generated field and association:
    // - foreign key info has 'generatedFieldName'
    // - generated field has annotation '@odata.foreignKey4'.
    foreignKey.generatedFieldName = foreignKeyElementName;
    addStringAnnotationTo('@odata.foreignKey4', assoc.name.element, foreignKeyElement);
    return foreignKeyElement;
  }

  // For an association 'assoc', check that all foreign keys (if any) actually exist in the
  // target. Must only be applied after flattening structured foreign keys.
  // Note that this may also be called for unmanaged associations with artificially created
  // ON-conditions, because these still retain their foreign key info.
  // FIXME: For all cases except implicit redirection, this should actually be done by the compiler
  function checkForeignKeys(assoc) {
    for (let name in assoc.foreignKeys) {
      let foreignKey = assoc.foreignKeys[name]
      // Sanity checks
      if (foreignKey.targetElement.path.length > 1) {
        throw Error('Expecting foreign key ' + + printableName(foreignKey) + ' to be flattened');
      }
      if (!assoc.target._artifact) {
        throw Error('Expecting target of association ' + printableName(assoc) + ' to be resolved');
      }
      if (!assoc.target._artifact.elements) {
        throw Error('Expecting target of association ' + printableName(assoc) + ' to have elements');
      }
      // Try to "resolve" the corresponding element
      let targetElement = assoc.target._artifact.elements[foreignKey.targetElement.path[0].id];
      if (targetElement == undefined) {
        if (assoc.redirected) {
          signal(error`Foreign key "${foreignKey.targetElement.path[0].id}" not found in redirected target "${assoc.target._artifact.name.absolute}" of association "${assoc.name.absolute}.${assoc.name.element}"`, assoc.location);
        } else {
          signal(error`Foreign key "${foreignKey.targetElement.path[0].id}" not found in target "${assoc.target._artifact.name.absolute}" of association "${assoc.name.absolute}.${assoc.name.element}"`, assoc.location);
        }
      }
    }
  }

  // For a structured element 'elem', return a dictionary of flattened elements to
  // replace it, flattening names with '_' and propagating all annotations and the
  // type properties 'key', 'notNull', 'virtual', 'masked' to the flattened elements.
  function flattenStructuredElement(elem) {
    // Sanity check
    if (!isStructuredElement(elem)) {
      throw new Error('Expecting element ' + printableName(elem) + ' to be a structured element');
    }
    // Collect all child elements (recursively) into 'result'
    let result = Object.create(null);
    for (let childName in elem._finalType.elements) {
      let childElem = elem._finalType.elements[childName];
      if (isStructuredElement(childElem)) {
        // Descend recursively into structured children
        let grandChildElems = flattenStructuredElement(childElem);
        for (let grandChildName in grandChildElems) {
          let flatElemName = elem.name.id + '_' + grandChildName;
          let flatElem = grandChildElems[grandChildName];
          result[flatElemName] = flatElem;
          // If the original element had a value, construct one for the flattened element
          if (elem.value) {
            createFlattenedValue(flatElem, flatElemName, grandChildName);
          }
          result[flatElemName] = flatElem;
        }
      } else {
        // Primitive child - clone it and restore its cross references
        let flatElemName = elem.name.id + '_' + childName;
        let flatElem = baseModel.cloneWithTransformations(childElem, {});
        flatElem.viaTransform = true; // FIXME: This name is not ideal but used elsewhere, too)
        baseModel.setProp(flatElem, '_finalType', childElem._finalType);
        baseModel.setProp(flatElem, '_main', elem._main);
        baseModel.setProp(flatElem, '_parent', elem._parent);
        if (childElem.foreignKeys) {
          for (let foreignKeyName in childElem.foreignKeys) {
            if (childElem.foreignKeys[foreignKeyName].targetElement._artifact) {
              baseModel.setProp(flatElem.foreignKeys[foreignKeyName].targetElement, '_artifact', childElem.foreignKeys[foreignKeyName].targetElement._artifact);
            }
          }
        }
        if (childElem.type) {
          flatElem.type = childElem.type;
        }
        if (childElem.target) {
          flatElem.target = childElem.target;
        }
        // FIXME: We just lost all _artifact links in the ON-condition by the cloning above,
        // so we rather take the original ON-condition here
        if (childElem.onCond) {
          flatElem.onCond = childElem.onCond;
        }
        // If the original element had a value, construct one for the flattened element
        if (elem.value) {
          createFlattenedValue(flatElem, flatElemName, childName);
        }
        result[flatElemName] = flatElem;
      }
    }
    // Fix all collected flat elements (names, annotations, properties, origin ..)
    for (let name in result) {
      // Adapt names within the element
      let flatElem = result[name];
      flatElem.name.id = name;
      flatElem.name.element = name;
      if (elem.name.calculated) {
        flatElem.name.calculated = true;
      }
      // Copy annotations from struct (not overwriting, because deep annotations should have precedence)
      copyAnnotations(elem, flatElem, false);
      // Copy selected type properties
      for (let p of ['key', 'notNull', 'virtual', 'masked', 'viaAll']) {
        if (elem[p]) {
          flatElem[p] = elem[p];
        }
      }
    }
    return result;

    // Create a flattened 'value' for flattened element 'flatElem' with full name 'flatElemName',
    // appending 'lastPathStep' to the original elem's value path
    function createFlattenedValue(flatElem, flatElemName, lastPathStep) {
      flatElem.value = {
        absolute : elem.value.absolute,
        element : flatElemName,
        viaTransform: true,
      }
      // Just extend 'elem's path by one step, leaving all IDs as they are (will be fixed later by flattenStructStepsInPath)
      if (elem.value.path) {
        flatElem.value.path = baseModel.cloneWithTransformations(elem.value.path, {});
        // Take over _artifact links from original path, because flattenStructStepsInPath requires them
        for (let i = 0; i < elem.value.path.length; i++) {
          flatElem.value.path[i]._artifact = elem.value.path[i]._artifact;
        }
      }
      flatElem.value.path.push({ id : lastPathStep });
      // FIXME: Cannot restore value._artifact here because it might not exist yet (projection
      // might be processed before entity). We currently live without it.
      // FIXME: Remove once the compactor no longer renders 'origin'
      flatElem.origin = flatElem.value;
    }
  }

  // Return a copy of 'path' where all path steps resulting from struct traversal are
  // fused together into one step, using '_' (so that the path fits again for flattened
  // structs), e.g. 
  //   [ (Entity), (struct1), (struct2), (assoc), (elem) ] should result in
  //   [ (Entity), (struct1_struct2_assoc), (elem) ]
  // FIXME: The resulting path steps have slightly crooked _artifact (for each artificially
  // created flattened element, the path step's _artifact points to the original
  // (primitive) struct member it was generated for.
  function flattenStructStepsInPath(path) {
    let result = [];
    let stack = []; // IDs of path steps not yet processed or part of a struct traversal
    for (let pathStep of path) {
      stack.push(pathStep.id);
      // Current stack makes a new result step if next path step is not a struct traversal
      if (!pathStep._artifact || !isStructuredElement(pathStep._artifact)) {
        let resultStep = Object.assign({}, pathStep, { id : stack.join('_') });
        if (pathStep._artifact) {
          baseModel.setProp(resultStep, '_artifact', pathStep._artifact);
        }
        result.push(resultStep);
        stack = [];
      }
    }
    // Process remaining stack if not empty
    if (stack.length > 0) {
      let pathStep = path[path.length - 1];
      let resultStep = Object.assign({}, pathStep, { id : stack.join('_') });
      if (pathStep._artifact) {
        baseModel.setProp(resultStep, '_artifact', pathStep._artifact);
      }
      result.push(resultStep);
    }
    // The path might start with an element that is part of a struct (i.e. enclosing the path owner).
    // This hasn't been handled above simply because the struct is not part of the path.
    // FIXME: Find a simpler solution for this ... really ugly
    if (path[0]._artifact && path[0]._artifact.name.element && path[0]._artifact.name.element.indexOf('.') != -1) {
      result[0].id = path[0]._artifact.name.element.replace(/\./g, '_');
    }
    return result;
  }

  // Takes an augmented action/function object and checks if a defined type is used in the declaration, 
  // if yes, then checks if it is from the same service as the action/function
  // used for OData and Swagger transformation
  function preprocessAction(action) {
    // A bound action has a parent - the corresponding entity
    // An unbound action does not have a parent, but a '_service'
    let actionBlock = action._parent ? action._parent._service : action._service;
    // an action can return a builtin, a defined type, an entity, an array of one of the first three or an inline structured type
    // if the action has a return declaration
    // and the returned artifact is not a builtin - check if it is from the current service
    if (action.returns) {
      let returnedTypes = action.returns.elements ?
        Object.keys(action.returns.elements).map(e => action.returns.elements[e].type) :
        action.returns.items
          ? [action.returns.items.type]
          : [action.returns.type];
      returnedTypes.forEach(returnType => {
        if (!returnType.absolute.startsWith('cds.')) {
          let returnTypeBlock = obtainTypesService(returnType);
          if (returnTypeBlock !== actionBlock)
            signal(error`The defined return type ${returnType._artifact.name.absolute} of action ${action.name.absolute}${action.name.action ? '.' + action.name.action : ''} is not from the current service ${actionBlock.name.absolute}`, action.location);
        }
      });
    }

    // if the action has parameters and a paremeter is not a builtin - check if the used type is from the current service
    if (action.params) {
      for (let p in action.params) {
        let param = action.params[p];
        if (param.type.absolute.startsWith('cds.'))
          continue;
        let paramTypeBlock = obtainTypesService(param.type);
        // this can happens if the special magic for @extends is used
        // ugly tnt magic -> to be removed
        if (!actionBlock && paramTypeBlock === 'not in a service') {
          if (/* actionBlock */ action.name.absolute.split('.').slice(0, -1).join('.') !== /* paramTypeBlock */ param.type.absolute.split('.').slice(0, -1).join('.'))
            signal(error`The type ${param.type._artifact.name.absolute} of parameter ${param.name.absolute}.${param.name.id} in action ${action.name.absolute}${action.name.action ? '.' + action.name.action : ''} is not from the current service`, param.location);
        } else if (paramTypeBlock !== actionBlock)
          signal(error`The type ${param.type._artifact.name.absolute} of parameter ${param.name.absolute}.${param.name.id} in action ${action.name.absolute}${action.name.action ? '.' + action.name.action : ''} is not from the current service ${actionBlock && actionBlock.name.absolute}`, param.location);
      }
    }

    // Returns the service where the type is declared or 'not in a service' if the type is outside of such.
    // Covers also the case when an element of defined type is used, for specifying a type.
    function obtainTypesService(type) {
      if (type._artifact._service)
        return type._artifact._service;
      if (type._artifact.kind === 'element' && type._artifact._main._service)
        return type._artifact._main._service;
      else
        return 'not in a service';
    }
  }

  // Takes a model and looks for services inside it.
  // When a service is found - adds an attribute '_service' to all artifacts that are exposed
  // in a service (pointing to the service artifact).
  function setServiceProperty(model) {
    baseModel.forEachDefinition(model, artifact => {
      // If this is a service, let all its (recursive) artifacts know
      if (artifact.kind == 'service') {
        setService(artifact, artifact);
      }
      // Set '_service' for 'artifact' and its sub-artifacts to 'service'.
      function setService(artifact, service) {
        // Services must not be nested
        if (artifact.kind == 'service' && artifact._service != undefined) {
          signal(error`Services cannot be nested: Service "${artifact.name.absolute}" is nested within service "${artifact._service.name.absolute}"`, artifact.location);
        }
        // Contexts cannot be defined within services
        if (artifact.kind == 'context') {
          signal(error`Contexts cannot be defined within services: Context "${artifact.name.absolute}" is defined within service "${service.name.absolute}"`, artifact.location);
        }
        baseModel.setProp(artifact, '_service', service);
        baseModel.forEachGeneric(artifact, 'artifacts', subartifact => setService(subartifact, service));
      }
    });
  }

  // Check that exposed associations do not point to non-exposed targets
  function checkExposedAssoc(artifact, association) {
    if (association.target && association.target._artifact && association.target._artifact._service != artifact._service)
      signal(error`Association "${artifact.name.absolute}.${association.name.id}" must be redirected: Target "${association.target.absolute}" is not exposed by service "${artifact._service.name.absolute}"`, association.location);
  }

  // Replace the type of 'node' with its final base type, collecting all annotations on the way
  // (from least to most derived, i.e. giving precedence to those higher in the type chain).
  function toFinalBaseType(node) {
    // Nothing to do if no type (or if array/struct type)
    if (!node || !node.type || node.type._artifact && node.type._artifact.builtin) {
      return;
    }
    // Sanity check
    if (node.type._artifact === undefined) {
      throw Error('Expecting type of ' + printableName(node) + ' to be resolved');
    }
    // Start the chain with the node's type (add in front of type chain, so that most derived one is last)
    let typeChain = [node.type._artifact];
    // Unravel until finding primitive type or type constructor
    while (typeChain[0].type && !typeChain[0].builtin) {
      // Sanity check
      if (typeChain[0].type._artifact === undefined) {
        throw Error('Expecting type of ' + printableName(typeChain[0]) + ' to be resolved');
      }
      typeChain.unshift(typeChain[0].type._artifact);
    }
    // Take the front of the chain as final base type (but keep the location as it was)
    node.type = {
      absolute: typeChain[0].name.absolute,
      location: node.type.location,
      viaTransform: true,
    };
    baseModel.setProp(node.type, '_artifact', typeChain[0]);
    // Sanity checks
    if (node._finalType && node._finalType.type && node._finalType.type.absolute != node.type.absolute) {
      throw Error('Expecting _finalType ' + node._finalType.type.absolute + ' to equal result of toFinalBaseType: ' + node.type.absolute);
    }
    // Propagate type parameters and all annotations upwards the chain (from chain[1] onwards, i.e. from least to most derived)
    for (let typeDef of typeChain.slice(1)) {
      // Propagate type parameters
      for (let prop of ['length', 'precision', 'scale', 'enum', 'target', 'foreignKeys']) {
        if (typeDef[prop] != undefined) {
          node[prop] = typeDef[prop];
        }
      }
      // Propagate annotations (not overwriting because most derived comes last and should win)
      copyAnnotations(typeDef, node, false);
    }
  }

  // Examine augmented 'model' for exposed associations/compositions having a non-exposed
  // target, and supply appropriate implicit redirections in-place.
  // Expects model to already have '_service' entries as provided by the first step of 'transform4oData'.
  // Report errors in 'model.messages'.
  function addImplicitRedirections(model) {
    // Create a backward exposure mapping for implicit re-targeting of association targets
    let exposedByProjection = createExposedByMapping(model);

    // Walk all artifacts of the model
    baseModel.forEachDefinition(model, (artifact, artifactName) => {
      // Only affects exposed artifacts
      if (!artifact._service) {
        return;
      }
      // Perform implicit re-targeting of association elements based on exposure:
      baseModel.forEachMemberRecursively(artifact, (member, memberName) => {
        // If this is an association or composition element that is not explicitly redirected,
        // and its target is not exposed in the same service as this artifact
        if (member.kind == 'element' && member.target && !member.redirected
            && member.target._artifact && member.target._artifact._service != artifact._service) {
          // Auto-expose the target is requested
          if (hasBoolAnnotation(member.target._artifact, '@cds.autoexposure')) {
            let projection = createExposingProjection(member.target._artifact, artifact._service, member.location);
            if (projection) {
              // Take the just-created projection as the (only!) projection exposing the target in this service
              exposedByProjection[member.target.absolute] = (exposedByProjection[member.target.absolute] || []).filter(p => p._service != artifact._service);
              exposedByProjection[member.target.absolute].push(projection);
              // console.log(`Auto-exposing target ${member.target.absolute} of association ${artifactName}.${memberName} as ${projection.name.absolute}`);            }
            }
          }
          // Attempt implicit redirection
          redirectAssociationImplicitly(member, memberName, artifact, artifactName);
        }
        // FIXME: Should we also rewrite '@Common.ValueList.entity' annotations based on auto-exposure? If so, how?
        // (not clear whether they have a path or a string as value, and how to resolve the name - TNT seems to have service-local
      });
    });

    // Redirect element 'assoc' with name 'assocName' in 'artifact' with name 'artifactName' implicitly
    // by modifying its target and adding a 'redirected' property. Complain if not unique or not exposed
    // in this service.
    function redirectAssociationImplicitly(assoc, assocName, artifact, artifactName) {
      // Only consider exposures in the same service for implicit redirection
      let implicitlyRedirected = (exposedByProjection[assoc.target.absolute] || []).filter(p => p._service == artifact._service);
      // Complain if no implicit redirection or if not unique
      if (implicitlyRedirected.length == 0) {
        signal(error`Association "${artifactName}.${assocName}" cannot be implicitly redirected: Target "${assoc.target.absolute}" is not exposed in service "${artifact._service.name.absolute}" by any projection`, assoc.location);
        return;
      } else if (implicitlyRedirected.length > 1) {
        signal(error`Association "${artifactName}.${assocName}" cannot be implicitly redirected: Target "${assoc.target.absolute}" is exposed in service "${artifact._service.name.absolute}" by multiple projections: ${implicitlyRedirected.map(p => '"' + p.name.absolute + '"').join(', ')}`, assoc.location);
        return;
      }
      // Perform implicit redirection
      assoc.redirected = { val: true };
      assoc.target = {
        absolute: implicitlyRedirected[0].name.absolute,
      };
      baseModel.setProp(assoc.target, '_artifact', implicitlyRedirected[0]);
    }
  }

  // Create an "exposed by" artifact name -> [artifact, ...] mapping in augmented 'model'
  // with the following semantics:
  // For each exposed projection P or view V that exposes an otherwise not-exposed "source"
  // S (where "source" means the single artifact in the projection's or view's simple
  // FROM-clause), we add a mapping from the non-exposed source artifact to the exposed
  // projection artifact, i.e. exposedByMapping(S) == [P] resp. [V].
  // Even more magically, we also add mappings for each 'include' of S or P resp. V, i.e.
  // an entity or projection/view also exposes everything it resp. its source inherits from.
  // For convenience, the mapping keeps all values of P/V in an array (even if there is only
  // one P/V).
  // Returns a dictionary with mappings from names to artifact arrays.
  function createExposedByMapping(model) {
    let result = Object.create(null);
    baseModel.forEachDefinition(model, artifact => {
      // Artifact exposed?
      if (artifact._service) {
        // Projection or view with single query?
        if (artifact.queries && artifact.queries.length == 1) {
          let from = artifact.queries[0].from;
          // Single, simple source?
          if (from.length == 1 && from[0].path) {
            // Sanity check
            if (!from[0].absolute) {
              throw new Error(`Unresolved query source in ${artifact.name.absolute}`);
            }
            let sourceArtifact = model.definitions[from[0].absolute];
            // Create reverse mapping (sourceName => artifact) if source is not exposed
            if (!sourceArtifact) {
              throw new Error(`Non-existing query source ${from[0].absolute} in ${artifact.name.absolute}`);
            }
            if (!sourceArtifact._service) {
              addToResult(sourceArtifact.name.absolute, artifact);
              // If P/V exposes S, it also exposes everything that S includes
              if (sourceArtifact.includes != undefined) {
                for (let includedName of sourceArtifact.includes.map(include => include.absolute)) {
                  addToResult(includedName, artifact);
                }
              }
            }
          }
        }
        // Otherwise, if artifact has includes
        else if (artifact.includes != undefined) {
          // An artifact also exposes everything it includes
          for (let includedName of artifact.includes.map(include => include.absolute)) {
            addToResult(includedName, artifact);
          }
        }
      }
    });

    function addToResult(name, artifact) {
      // Always keep right hand side as an array (more convenient if multiple services are involved)
      if (result[name]) {
        result[name].push(artifact);
      } else {
        result[name] = [artifact];
      }
      // console.error('Use ' + artifact.name.absolute + ' as replacement for ' + name);
    }
    return result;
  }

  // Return a full projection of artifact 'art' for exposure in 'service', where the name of the projection
  // is the fully qualified name of 'art', replacing '.' and '::' by '_' resp. '__'.
  // Complain on location 'loc' if such an artifact (other than the autoigenerated one) already exists
  function createExposingProjection(art, service, loc) {
    let projectionId = art.name.absolute.replace(/\./g, '_').replace(/::/g, '__');
    let projectionAbsoluteName = service.name.absolute + '.' + projectionId
    // If there already is an artifact with this name, this is either the second attempt or a conflict
    let existingProjection = service.artifacts[projectionId];
    if (existingProjection) {
      if (existingProjection.$generatedByAutoExposure) {
        // Already auto-exposed
        return existingProjection;
      }
      signal(error`Cannot generate projection "${projectionId}" for auto-exposure because of name conflict with existing artifact "${service.name.absolute}.$projectionId}"`, loc);
      return null;
    }
    // Create elements matching the artifact's elements
    let elements = Object.create(null);
    for (let elemName in art.elements) {
      let artElem = art.elements[elemName];
      let elem = Object.assign({}, artElem);
      elem.name = Object.assign({}, artElem.name, { calculated: true });
      elem.name.absolute = projectionAbsoluteName;
      elem.value = {
        id : elemName,
        absolute: projectionAbsoluteName,
        element: elemName,
        path: [ { id : art.name.id }, { id : elemName } ]
      }
      baseModel.setProp(elem.value, '_artifact', artElem);
      // Transfer the original element's final type, unless it was the original element itself (then it becomes the new element itself)
      if (artElem._finalType) {
        baseModel.setProp(elem, '_finalType', (artElem._finalType == artElem) ? elem : artElem._finalType);
      }
      // FIXME: Remove once the compactor no longer renders 'origin'
      elem.origin = elem.value;
      elem.viaAll = true;
      elements[elemName] = elem;
    }
    // Source is the original artifact
    let source = {
      path: art.name.path,
      name: {
        calculated: true,
        id : art.name.id,
      },
      absolute: art.name.absolute,
    };
    baseModel.setProp(source, '_artifact', art);
    // Add an artifact link for the last path step (for some reason, the original path does not seem to have it)
    if (!source.path[source.path.length - 1]._artifact) {
      baseModel.setProp(source.path[source.path.length - 1], '_artifact', art);
    }
    let query = {
      op: { val: 'query', location: loc },
      from: [ source ],
      all: { val: true },
      elements,
      kind: 'query',
    };
    // Assemble the projection itself and add it into the model
    let projection = {
      name: {
        id: projectionId,
        absolute: projectionAbsoluteName
      },
      kind: 'entity',
      query: query,
      projection: {},
      $from: [ source ],
      queries: [ query ],
      source: source,
      elements: query.elements,
      $generatedByAutoExposure: true,
    };
    baseModel.setProp(projection, '_service', service);
    // Sanity check: Can't already be there (checked above)
    if (model.definitions[projectionAbsoluteName]) {
      throw new Error('Duplicate projection: ' + projectionAbsoluteName);
    }
    model.definitions[projectionAbsoluteName] = projection;
    service.artifacts[projectionId] = projection;
    return projection;
  }
}

module.exports = {
  // This function retrieves the actual exports
  getTransformers,
};
