// Transform augmented CSN into compact "official" CSN

'use strict';

const { queryOps } = require('../base/model');

// in main:
// const { compactModel: compactSortedJson } = require('./json/to-csn')

//var strict = false;

// dictionary:
// exclude
// namedArgs/arrowedArgs: insertOrderDict
// struct: insertOrderDict

const transformers = {
  '@': value,
  '$': ignore,
  $inferred: a => a && true,
  annotationAssignments: ignore, // TODO: make it $annotations
  artifacts: ignore,             // almost just $artifacts
  blocks: ignore,                // TODO: make it $blocks
  indexNo: ignore,               // TODO XSN: remove
  queries: ignore,               // TODO: make it $queries
  location: ignore,
  // future ------------------------------------------------------------------
  extensions: standard,  // is array - TODO: sort
  quoted: ignore,               // really?  What about CURRENT_DATE vs "CURRENT_DATE"?
  // members -----------------------------------------------------------------
  actions: nonEmptyDict,
  elements: insertOrderDict,
  enum: insertOrderDict,
  foreignKeys: dictAsArray,
  mixin: insertOrderDict,       // only in queries with special handling
  params: insertOrderDict,
  // different XSN later -----------------------------------------------------
  _typeIsExplicit: ignore,
  calculated: ignore,            // later in name: $inferred: 'as'
  implicitForeignKeys: ignore,   // later in assoc: $inferred: { foreignKeys: 'fk' } or $inferred on each fk
  origin: ignore,                // remove (introduce non-enum _origin link)
  projection: ignore,            // later in entity: $syntax: 'projection'
  source: ignore,                // remove
  viaAll: ignore,                // later in elem: $inferred: '*'
  // general properties of constructs ----------------------------------------
  abstract: value,
  dbType: value,                // TODO: currently with --hana-flavor only
  default: expression,
  impl: ignore,               // obsolete - remove
  key: value,
  kind: filterKind,
  name: annotationName,
  virtual: value,
  notNull: value,
  masked: value,
  returns: standard,            // storing the return type of actions
  // type properties ---------------------------------------------------------
  cardinality,
  includes: a => a.map(artifactRef), // also entities
  length: value,
  on: (cond) => (typeof cond === 'string' ? undefined : condition( cond )),
  onCond : (cond, csn) => { csn.on = condition( cond ); }, // XSN TODO: onCond -> on
  precision: value,
  redirected: ignore,           // TODO: no need for this
  scale: value,
  target: artifactRef,
  type: artifactRef,
  items: standard,
  // inner properties which should not occur anymore -------------------------
  path: ignore,
  sourceMax: value,
  targetMin: value,
  targetMax: value,
  targetElement: ignore,        // special display of foreign key
  // queries -----------------------------------------------------------------
  from: fromOld,
  all: ignore,                  // should not occur
  exclude: (excl, csn) => { csn.excluding = Object.keys(excl); }, // XSN TODO: exclude->excluding
  groupBy: a => a.map(expression),
  having: condition,
  limit,                // TODO XSN: include offset
  offset: ignore,             // TODO XSN: move into `limit`
  orderBy: a => a.map(orderBy), // TODO XSN: make `sort` and `nulls` sibling properties
  query,
  value: enumValue,             // do not list for select items as elements
  where: condition,
  // special HANA CDS featues ------------------------------------------------
  sequenceOptions: ignore,    // TODO: currently not in the JSON by HANA
}

const typeProperties = [        // currently just for select items
  'type', 'length', 'precision', 'scale', 'items', 'target', 'source', // TODO: source?
  'elements', 'enum'
];

const operators = {
  // standard is: binary infix (and corresponding n-ary), unary prefix
  isNot: [ 'is', 'not' ],       // TODO XSN: 'is not'
  isNull: postfix( ['is', 'null'] ),
  isNotNull: postfix( [ 'is', 'not', 'null' ] ),
  notIn: [ 'not', 'in' ],
  between: ternary( ['between'], ['and'] ),
  notBetween: ternary( ['not', 'between'], ['and'] ),
  like: ternary( ['like'], ['escape'] ),
  notLike: ternary( ['not', 'like'], ['escape'] ),
  when: (args) => ['when', ...args[0], 'then', ...args[1]],
  case: (args) => ['case'].concat( ...args, ['end'] ),
}

function compactModel( model ) { //, options = model.options || {} ) {
  //strict = options.testMode;
  let csn = { definitions: sortedDict( model.definitions ) };
  set( 'extensions', csn, model );
  if (model.version)
    csn.version = model.version;
  return csn;
}

function standard( node ) {
  if (node instanceof Array)
    return node.map( standard );
  let csn = {};
  // To avoid another object copy, we sort according to the prop names in the
  // XSN input node, not the CSN result node.  Not really an issue...
  let keys = Object.keys( node ).sort( compareProperties );
  for (let prop of keys) {
    let transformer = transformers[prop] || transformers[prop.charAt(0)];
    // TODO: complain if falsy with strict
    // Apply transformer, or use standard() if there is none
    let sub = (transformer || standard)( node[prop], csn, node, prop );
    if (sub !== undefined)
      csn[prop] = sub;
  }
  return csn;
}

function set( prop, csn, node ) {
  let val = node[prop];
  if (val === undefined)
    return;
  let sub = transformers[prop]( node[prop], csn, node, prop );
  if (sub !== undefined)
    csn[prop] = sub;
}

function annotations( node, exclude ) {
  let csn = {};
  let transformer = transformers['@'];
  let keys = Object.keys( node ).filter( a => a.charAt(0) === '@' ).sort();
  for (let prop of keys) {
    let val = node[prop];
    if (!exclude || !exclude(val) ) {
      let sub = transformer( val, csn, node, prop );
      if (sub !== undefined)
        csn[prop] = sub;
    }
  }
  return csn;
}

function ignore() {}

function insertOrderDict( dict ) {
  let keys = Object.keys( dict );
  return dictionary( dict, keys );
}

function sortedDict( dict ) {
  let keys = Object.keys( dict );
  keys.sort();
  return dictionary( dict, keys );
}

function nonEmptyDict( dict ) {
  let keys = Object.keys( dict );
  return (keys.length)
    ? dictionary( dict, keys )
    : undefined;
}

function dictionary( dict, keys ) {
  let csn = Object.create(null);
  for (let name of keys) {
    let def = definition( dict[name] );
    if (def !== undefined)
      csn[name] = def;
  }
  return csn;
}

function dictAsArray( dict ) {
  let csn = [];
  for (let n in dict) {
    let d = definition( dict[n] );
    if (d !== undefined)
      csn.push( d );
  }
  return (csn.length) ? csn : undefined;
}

function definition( art ) {
  if (!art || typeof art !== 'object')
    return undefined;           // TODO: complain with strict
  if (art.kind === 'namespace') // do not include namespace definitions
    return undefined;
  if (art.kind === 'key')       // foreignkey
    return (art.$inferred)
      ? Object.assign( expression( art.targetElement ), { $inferred: true } )
      : addExplicitAs( expression( art.targetElement ), art.name );

  if (!art.$inferred || art._main && art._main.query) // fully show inferred query elems
    return standard( art );

  let csn = annotations( art, v => !v.priority || v.priority === 'define' );
  let kind = filterKind( art.kind );
  if (kind)
    csn = Object.assign( {kind}, csn );
  if (art.$inferred)          // TODO: always set $inferred for actions ?
    csn.$inferred = true;
  return csn;
}

function filterKind( kind, csn, node ) {
  if (kind === 'view')          // XSN TODO: kind: 'entity', $syntax: 'view'
    return 'entity';
  if (kind === 'element' || kind === 'key' || kind === 'enum' ||
     kind === 'annotate' && node._main)
    return undefined;
  return kind;
}

function annotationName( name, csn, node ) {
  if (node.kind === 'annotate' && !node._main)
    csn.target = name.absolute; // really use 'target' ?
}

function artifactRef( node, terseIfNotNull ) {
  // Works also on XSN directly coming from parser
  let path = node.path;
  if (!path)                // does not work with current augmentor
    return undefined;           // TODO: complain with strict
  let length = path.length;
  let index  = 0;
  for (; index < length; ++index) {
    let art = path[index]._artifact;
    if (!art || art._main)      // stop if at element or not found/compiled
      break;
  }
  let id;
  if (index) {
    id = path[ index-1 ]._artifact.name.absolute;
  }
  else if (typeof node.scope === 'number') {
    // TODO: just use the first with CSN input - CDL should provide scope:0
    index = node.scope || length;
    id = (node.scope ? path.slice(0,index) : path).map( id => id.id ).join('.');
  }
  else {                        // JSON or i18n input (without compiler links)
    index = 1;
    id = path[0];
  }
  let main = Object.assign( {}, path[ index-1 ], { id } );
  let ref = [main, ...path.slice(index)].map( pathItem );
  return (terseIfNotNull == null || ref.length != 1 || typeof ref[0] !== 'string')
         ? { ref }
         : ref[0];
}

function pathItem( item ) {
  if (!item.args && !item.namedArgs && !item.filter && !item.cardinality)
    return item.id;
  let r = { id: item.id };
  if (item.args || item.namedArgs) // XSN TODO: namedArgs -> args
    r.args = args( item.args || item.namedArgs );
  if (item.cardinality)
    r.cardinality = cardinality( item.cardinality );
  if (item.filter)
    r.filter = expression( item.filter );
  return r;
}

function args( node ) {
  if (node instanceof Array)
    return node.map( expression );
  let dict = Object.create(null);
  for (let param in node)
    dict[param] = expression( node[param] );
  return dict;
}

function cardinality( node ) {
  let card = {};
  if (node.sourceMax)
    card.src = node.sourceMax.val; // = value( node.sourceMin )
  if (node.targetMin)
    card.min = node.targetMin.val;
  if (node.targetMax)
    card.max = node.targetMax.val;
  return card;
}

function value( node ) {
  if (!node)
    return true;                // `@aBool` short for `@aBool: true`
  if (node.$inferred)           // value '' for propagated from sub query (TODO propagator)
    return undefined;
  if (node.path)
    return { '=': node.path.map( id => id.id ).join('.') };
  if (node.literal == 'enum')
    return { "#" : node.symbol.id };
  if (node.literal == 'array')
    return node.val.map( value );
  if (node.literal != 'struct')
    return !('val' in node) || node.val;
  let r = Object.create( null );
  for (let prop in node.struct)
    r[prop] = value( node.struct[prop] );
  return r;
}

function enumValue( v, csn, node )  {
  if (node.kind === 'enum')
    Object.assign( csn, expression(v) );
}

function condition( node ) {
  let expr = expression( node );
  return expr.xpr || [expr];
}

function expression( node ) {
  if (node instanceof Array) {
    let args = node.map( condition );
    let rest = args.slice(1).map( a => [',', ...a] );
    return { xpr: ['('].concat( args[0], ...rest, [')'] ) };
  }
  if (node.path) {
    // TODO: param/global
    return { ref: node.path.map( pathItem ) };
  }
  if (node.literal) {
    if (typeof node.val === node.literal || node.val === null)
      return { val: node.val };
    else if (node.literal === 'enum')
      return { "#" : node.symbol.id };
    else                        // TODO XSN: literal 'hex'->'x'
      return { val: node.val, literal: (node.literal==='hex') ? 'x' : node.literal };
  }
  if (node.func) {              // TODO XSN: remove op: 'call', func is no path
    return { func: node.func.path[0].id, args: args( node.args || node.namedArgs ) };
  }
  if (queryOps[ node.op.val ])
    return query( node );
  else
    return { xpr: xpr( node ) };
}

function xpr( node ) {
  // if (!node.op) console.log(node)
  let op = operators[ node.op.val ] || node.op.val.split(' ');
  let args = node.args.map( condition );
  if (op instanceof Function)
    return op( args );
  if (node.quantifier)
    op.push( node.quantifier.val );
  if (args.length < 2)
    return [ ...op, ...args[0] || [] ];
  return args[0].concat( ...args.slice(1).map( a => [...op, ...a] ) );
}

function ternary( op1, op2 ) {
  return function( args ) {
    return (args[2])
      ? [ ...args[0], ...op1, ...args[1], ...op2, ...args[2] ]
      : [ ...args[0], ...op1, ...args[1] ];
  };
}

function postfix( op ) {
  return function( args ) {
    return [ ...args[0], ...op ];
  }
}

function query( node ) {
  // TODO: add "inferred" elements for leading query
  while (node instanceof Array) // in parentheses -> remove
    node = node[0];
  let csn = {};
  // for UNION, ... ----------------------------------------------------------
  if (!['query', 'subquery'].includes( node.op.val )) {
    if (node.op.val !== 'unionAll') // CSN TODO: quantifier: 'all'|'distinct'
      csn.op = node.op.val;
    else
      csn.op = 'union', csn.all = true;
  }
  if (node.args) {
    let args = node.args;
    // binary -> n-ary - the while loop should be done in parser (toCdl is
    // currently not prepared)
    while (args[0] && args[0].op && args[0].op.val === node.op.val &&
           !args[0].all === !node.all && args[0].args)
      args = [ ...args[0], ...args.slice(1) ]
    if (node.op.val === 'unionAll') // TODO grammar: set DISTINCT - quantifier: 'all'|'distinct'
      csn.all = true;
    csn.args = args.map( query );
  }
  // for SELECT --------------------------------------------------------------
  set( 'from', csn, node );
  set( 'mixin', csn, node );
  if (node.elements) {
    csn.columns = (node.all) ? ['*'] : [];
    for (let name in node.elements)
      addElementAsColumn( node.elements[name], csn.columns );
  }
  set( 'exclude', csn, node );  // XSN TODO: exclude->excluding
  set( 'where', csn, node );
  set( 'groupBy', csn, node );
  set( 'having', csn, node );
  // for both ----------------------------------------------------------------
  set( 'orderBy', csn, node );
  set( 'limit', csn, node );
  return (node.op.val === 'query') ? { SELECT: csn } : { SET: csn };
}

function fromOld( node ) {
  // TODO: currently an array in XSN:
  if (node.length > 1)
    return from( { join: 'cross', args: node } );
  else
    return from( node[0] );
}

// XSN TODO: remove '…Outer'
const joinTrans = { leftOuter: 'left', rightOuter: 'right', fullOuter: 'full' };

function from( node ) {
  while (node instanceof Array) // in parentheses
    node = node[0];
  // TODO: CSN: FROM ((SELECT...)) as -> also add 'subquery' op? - Together
  // with []-elimination in FROM...
  if (node.path)
    return addExplicitAs( artifactRef( node, null ), node.name );
  else if (node.join) {         // XSN TODO: remove '…Outer'
    // binary (without additions) -> n-ary - the while loop should be done in
    // parser (toCdl is currently not prepared)
    let args = node.args;
    while (node.join === 'cross' && args[0] && args[0].join === node.join && args[0].args)
      args = [ ...args[0], ...args.slice(1) ]
    let join = { join: joinTrans[node.join] || node.join, args: node.args.map( from ) };
    set( 'on', join, node );
    return join;
  }
  else
    return addExplicitAs( query( node ), node.name );
}

function addElementAsColumn( elem, columns ) {
  if (elem.viaAll)
    return;
  // TODO: 'priority' -> '$priority'
  // only list annotations here which a provided directly with definition
  let col = annotations( elem, v => v.priority && v.priority !== 'define' );
  Object.assign( col, addExplicitAs( expression( elem.value ), elem.name ) );
  if (elem.key && !elem.$inferred)
    col.key = true;
  if (elem._typeIsExplicit || elem.redirected) { // TODO XSN: introduce $inferred
    col.cast = {};
    for (let prop of typeProperties)
      set( prop, col.cast, elem );
  }
  columns.push( col );
}

function orderBy( node ) {      // TODO XSN: flatten (no extra 'value')
  let expr = expression( node.value );
  if (node.sort)
    expr.sort = node.sort.val;
  if (node.nulls)
    expr.nulls = node.nulls.val;
  return expr;
}

function limit( limit, csn, node ) { // XSN TODO: use same structure
  let rows = expression( limit );
  return (node.offset)
    ? { rows, offset: expression( node.offset ) }
    : { rows };
}

function addExplicitAs( node, name ) {
  if (name && !name.calculated)
    node.as = name.id;
  return node;
}

// normalize CSN: sort properties alphabetically if no prototype (also sort model.definitions)
// for "niceness", put the following properties first: op, kind, name
const earlyProperties = { op: '\x01', kind: '\x02', name: '\x03' };

function compareProperties( a, b ) {
  if (a === b)
    return 0;
  else if ((earlyProperties[a] || a) < (earlyProperties[b] || b))
    return -1;
  else
    return 1;
}

function compactQuery( q ) {    // TODO: options
  return q && query( q );
}

function compactExpr( e ) {     // TODO: options
  return e && expression( e );
}

module.exports = { compactModel, compactQuery, compactExpr };
