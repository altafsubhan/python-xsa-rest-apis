// Error strategy with special handling for (non-reserved) keywords

// If a language has non-reserved keywords, any such keyword can be used at
// places where just a identifier is expected.  For doing so, we define a rule
//   ident : Identifier | NONRESERVED_1 | ... NONRESERVED_n ;
//
// Now consider another rule:
//   expected : RESERVED_j | NONRESERVED_k | ident ;
// If parsing fails at this place, you expect to see an message like
//   Mismatched input '?', expecting RESERVED_j, NONRESERVED_k, or Identifier
// With ANTLR's default error strategy, you unfortunately also see all other
// n-1 non-reserved keyword after "expecting"...
//
// The error strategy provided by this file gives you the expected message.
// The example above shows that it is not enough to just remove all
// non-reserved keywords from the expected-set.  The error strategy also allows
// you to match reserved keywords as identifiers at certain places (when there
// are no alternatives).

// For using this error strategy, the grammar for the parser/lexer must have a
// lexer rule `Number`, then rules for unreserved keywords, and finally a rule
// `Identifier`.  No tokens (which are used in parser rules) must be defined
// after that, no other rules must be defined in between those rules.

// This file is actually very ANTLR4 specific and should be checked against
// future versions of the ANTLR4-js runtime.  There is no need to look at this
// file if you just want to understand the rest of this compiler project.

var antlr4 = require('antlr4');
var IntervalSet = require('antlr4/IntervalSet');
var antlr4_error = require('antlr4/error/ErrorStrategy');
var antlr4_LL1Analyzer = require('antlr4/LL1Analyzer.js').LL1Analyzer;
var predictionContext = require('antlr4/PredictionContext').predictionContextFromRuleContext;
var ATNState = require('antlr4/atn/ATNState').ATNState;
var InputMismatchException = antlr4.error.InputMismatchException;

const keywordRegexp = /^[a-zA-Z]+$/;

// Remember context for potential error message
function epsilon() {
  let lt1 = this._input.LT(1);
  if (this.state >= 0 && lt1 !== this.$exitToken) {
    this.$exitToken = lt1;
    this.$exitState = this.state;
    this.$exitCtx   = this._ctx;
  }
}

function exitRule() {
  epsilon.call( this );
  antlr4.Parser.prototype.exitRule.call( this );
}

function consume() {
  // Unfortunately, ANTLR does not generate "this.state = <endState>" after
  // this.consume / this.match if nothing can follow the token.  But exitRule
  // needs to know whether the token has been consumed or not.
  let t = antlr4.Parser.prototype.consume.call( this );
  this.state = -1;              // illegal state stands for <endState>
  return t;
}

// Match current token against token type `ttype` and consume it if successful.
// Also allow to match keywords as identifiers.  This function should be set as
// property `match` to the parser (prototype).  See also `recoverInline()`.
function match( ttype ) {
  var identType = this.constructor.Identifier;
  if (ttype !== identType)
    return antlr4.Parser.prototype.match.call( this, ttype );

  var reserved = this.getCurrentToken();
  if (reserved.type !== identType && !keywordRegexp.test( reserved.text ))
    return antlr4.Parser.prototype.match.call( this, ttype );

  // eventually issue a warning (if reserved.type !== identType)
  //   'use "RESERVED" for a name, as RESERVED is a reserved keyword'
  this._errHandler.reportMatch(this);
  this.consume();
  return reserved;
}

// Class which adapts ANTLR4s standard error strategy: do something special
// with (non-reserved) keywords.
//
// An instance of this class should be set as property `_errHandler` to the
// parser (prototype).
function KeywordErrorStrategy( ...args ) {
  antlr4_error.DefaultErrorStrategy.call( this, ...args );
  return this;
}
const super1 = antlr4_error.DefaultErrorStrategy.prototype;

KeywordErrorStrategy.prototype = Object.assign(
  Object.create( super1 ), {
    sync,
    reportNoViableAlternative,
    reportInputMismatch,
    reportUnwantedToken,
    reportMissingToken,
    // getErrorRecoverySet,
    consumeUntil,
    recoverInline,
    getMissingSymbol,
    getExpectedTokensForMessage,
    constructor: KeywordErrorStrategy
  });

// Attemp to recover from problems in subrules, except if rule has defined a
// local variable `LeaveLoop` with truthy value
function sync( recognizer ) {
  // If already recovering, don't try to sync
  if (this.inErrorRecoveryMode(recognizer)) {
    return;
  }
  var token = recognizer.getCurrentToken();
  if (!token)
    return;

  var s = recognizer._interp.atn.states[recognizer.state];
  // try cheaper subset first; might get lucky. seems to shave a wee bit off
  var nextTokens = recognizer.atn.nextTokens(s);

  // console.log(antlr4.Token.EPSILON, nextTokens.contains(antlr4.Token.EPSILON),nextTokens)
  if (nextTokens.contains(token.type)) { // we are sure the token matches
    recognizer.$nextTokensToken = null;
    recognizer.$nextTokensState = ATNState.INVALID_STATE_NUMBER;
    recognizer.$nextTokensContext = null;
    // console.log('REMOVE:',token.type,recognizer.state)
    return;
  }
  if (nextTokens.contains(antlr4.Token.EPSILON)) {
    if (recognizer.$nextTokensToken !== token) {
      // console.log('SET:',token.type,recognizer.state,recognizer.$nextTokensToken && recognizer.$nextTokensToken.type)
      recognizer.$nextTokensToken = token;
      recognizer.$nextTokensState = recognizer.state;
      recognizer.$nextTokensContext = recognizer._ctx;
    }
    return;
  }

  if (recognizer._ctx.LeaveLoop)
    return;

  switch (s.stateType) {
    case ATNState.BLOCK_START:
    case ATNState.STAR_BLOCK_START:
    case ATNState.PLUS_BLOCK_START:
    case ATNState.STAR_LOOP_ENTRY:
      // report error and recover if possible
      if( this.singleTokenDeletion(recognizer) !== null) {
        return;
      } else {
        throw new InputMismatchException(recognizer);
      }
    case ATNState.PLUS_LOOP_BACK:
    case ATNState.STAR_LOOP_BACK:
      this.reportUnwantedToken(recognizer);
      var expecting = new IntervalSet.IntervalSet();
      expecting.addSet(recognizer.getExpectedTokens());
      var whatFollowsLoopIterationOrRule = expecting.addSet(this.getErrorRecoverySet(recognizer));
      this.consumeUntil(recognizer, whatFollowsLoopIterationOrRule);
      break;
    default:
    // do nothing if we can't identify the exact kind of ATN state
  }
}
// Report `NoViableAltException e` signalled by parser `recognizer`
function reportNoViableAlternative( recognizer, e ) {
  // console.log('NOV:',this.getTokenErrorDisplay(e.startToken), this.getTokenErrorDisplay(e.offendingToken))
  if (e.startToken === e.offendingToken) { // mismatch at LA(1)
    this.reportInputMismatch( recognizer, e );
  }
  else {
    this.reportInputMismatch( recognizer, e, !e.deadEndConfigs || e.deadEndConfigs.configs );
    do {
      // console.log('CONSUME-NOVIA:',this.getTokenErrorDisplay(recognizer.getCurrentToken()));
      recognizer.consume();
    } while (recognizer.getCurrentToken() !== e.offendingToken);
    // this.lastErrorIndex = e.startToken.tokenIndex; // avoid another consume()
  }
}

// Report `InputMismatchException e` signalled by parser `recognizer``
function reportInputMismatch( recognizer, e, deadEnds ) {
  var expecting = deadEnds !== true && // true: cannot compute expecting
                  this.getExpectedTokensForMessage( recognizer, e.offendingToken, deadEnds );
  var msg = "Mismatched input " + this.getTokenErrorDisplay(e.offendingToken);
  if (expecting) {
    msg += " expecting " + expecting.toString(recognizer.literalNames, recognizer.symbolicNames);
    e.expectedTokens = intervalSetToArray( recognizer, expecting );
  }
  recognizer.notifyErrorListeners(msg, e.offendingToken, e);
}

// Report unwanted token when the parser `recognizer` tries to recover/sync
function reportUnwantedToken( recognizer ) {
  if (this.inErrorRecoveryMode(recognizer)) {
    return;
  }
  this.beginErrorCondition(recognizer);
  var t = recognizer.getCurrentToken();
  var tokenName = this.getTokenErrorDisplay(t);
  var expecting = this.getExpectedTokensForMessage( recognizer, t );
  var e = new antlr4.error.InputMismatchException( recognizer );
  e.expectedTokens = intervalSetToArray( recognizer, expecting );
  var msg = "Extraneous input " + tokenName + " expecting " +
      expecting.toString(recognizer.literalNames, recognizer.symbolicNames);
  recognizer.notifyErrorListeners(msg, t, e);
}

// Report missing token when the parser `recognizer` tries to recover/sync
function reportMissingToken( recognizer ) {
  if ( this.inErrorRecoveryMode(recognizer)) {
    return;
  }
  this.beginErrorCondition(recognizer);
  var t = recognizer.getCurrentToken();
  var expecting = this.getExpectedTokensForMessage( recognizer, t );
  var e = new antlr4.error.InputMismatchException( recognizer );
  e.expectedTokens = intervalSetToArray( recognizer, expecting );
  var msg = "Missing " + expecting.toString(recognizer.literalNames, recognizer.symbolicNames) +
      " at " + this.getTokenErrorDisplay(t);
  recognizer.notifyErrorListeners(msg, t, e);
}

var SEMI = null;

function consumeUntil( recognizer, set ) {
  if (SEMI == null)
    SEMI = recognizer.literalNames.indexOf( "';'" );
  if (SEMI < 1 || set.contains(SEMI)) {
    super1.consumeUntil.call( this, recognizer, set );
  }
  else {
    set.addOne( SEMI );
    super1.consumeUntil.call( this, recognizer, set );
    // if (recognizer.getTokenStream().LA(1) === SEMI) console.log( 'CONSUME: Semi' )
    if (recognizer.getTokenStream().LA(1) === SEMI) {
      recognizer.consume();
      this.reportMatch(recognizer); // we know current token is correct
    }
  }
}


// As the `match` function of the parser `recognizer` does not allow to check
// against a set of token types, the generated parser code checks against that
// set itself and calls this function if not successful.
// We now also allow keywords if the Identifier is expected.
function recoverInline( recognizer ) {
  var identType = recognizer.constructor.Identifier;
  if (!identType || !recognizer.isExpectedToken( identType ))
    return super1.recoverInline.call( this, recognizer );

  var reserved = recognizer.getCurrentToken();
  if (!keywordRegexp.test( reserved.text ))
    return super1.recoverInline.call( this, recognizer );

  // eventually issue a warning
  //  'use "RESERVED" for a name, as RESERVED is a reserved keyword'
  this.reportMatch(recognizer); // we know current token is correct
  recognizer.consume();
  return reserved;
}

// Conjure up a missing token during error recovery in parser `recognizer`.  If
// an identifier is expected, create one.
// Think about: we might want to prefer one of '}]);,'.
function getMissingSymbol( recognizer ) {
  var identType = recognizer.constructor.Identifier;
  if (!recognizer.isExpectedToken( identType ))
    return super1.getMissingSymbol.call( this, recognizer );

  var current = recognizer.getCurrentToken();
  return recognizer.getTokenFactory().create(
    current.source,
    identType, '_some_ident_', antlr4.Token.DEFAULT_CHANNEL,
    -1, -1, current.line, current.column);
}

function intervalSetToArray( recognizer, expected ) {
  // similar to `IntervalSet#toTokenString`
  var names = [];
  for (let v of expected.intervals) {
    for (var j = v.start; j < v.stop; j++) {
      names.push( expected.elementName (recognizer.literalNames, recognizer.symbolicNames, j ) );
    }
  }
  return names;
}


// Return an IntervalSet of token types which the parser had expected.  Do not
// include non-reserved keywords if not mentioned explicitly (i.e. other than
// from rule `ident`).
//
// We actually define something like a corrected version of function
// `LL1Analyzer.prototype.getDecisionLookahead`.  We cannot just redefine
// `getExpectedTokens`, because that function is also used to decide whether
// to consume in `DefaultErrorStrategy#singleTokenDeletion`.
function getExpectedTokensForMessage( recognizer, offendingToken, deadEnds ) {
  var atn = recognizer._interp.atn;
  if (recognizer.state < 0)
    return null;
  if (recognizer.state >= atn.states.length)
    throw( 'Invalid state number ' + recognizer.state + ' for ' +
           this.getTokenErrorDisplay( offendingToken ));

  var identType = recognizer.constructor.Identifier;
  var beforeUnreserved = recognizer.constructor.Number;
  if (!identType || !beforeUnreserved || beforeUnreserved + 2 > identType)
    return super1.getExpectedTokens.call( this, recognizer );

  var ll1 = new antlr4_LL1Analyzer(atn);
  var expected = new IntervalSet.IntervalSet();
  var orig_addInterval = expected.addInterval;
  expected.addInterval = addInterval;
  let lookBusy = new antlr4.Utils.Set();
  let calledRules = new antlr4.Utils.BitSet();

  if (deadEnds) {
    // "No viable alternative" by adaptivePredict() not on first token
    for (let trans of deadEnds)
      ll1._LOOK( trans.state, null, predictionContext( atn, recognizer._ctx ),
                 expected, lookBusy, calledRules, true, true );
  }
  else if (offendingToken && recognizer.$nextTokensContext &&
           offendingToken === recognizer.$nextTokensToken) {
    // We have a state (via sync())  with more "expecting" for the same token
    ll1._LOOK( atn.states[ recognizer.$nextTokensState ], null,
               predictionContext( atn, recognizer.$nextTokensContext ),
               expected, lookBusy, calledRules, true, true );
  }
  else {
    // Use current state to compute "expecting"
    ll1._LOOK( atn.states[ recognizer.state ], null,
               predictionContext( atn, recognizer._ctx ),
               expected, lookBusy, calledRules, true, true );
  }
  // console.log(state, recognizer.$nextTokensState, expected.toString(recognizer.literalNames, recognizer.symbolicNames));
  return expected;

  // Add an interval `v` to the IntervalSet `this`.  If `v` contains the token
  // type `Identifier`, do not add non-reserved keywords in `v`.
  function addInterval(v) {
    if (v.stop <= identType) {
      orig_addInterval.call(this,v);
    }
    else if (v.start >= identType) {
      if (v.stop === identType+1 || !recognizer.tokenRewrite)
        orig_addInterval.call(this,v);
      else {
        for (let j = v.start; j < v.stop; j++)
          addRange( this, recognizer.tokenRewrite[ j - identType ] || j );
      }
    }
    else {
      if (v.start <= beforeUnreserved)
        addRange( this, v.start, beforeUnreserved + 1 );
      addRange( this, identType );
    }
  }

  function addRange( interval, start, stop ) {
    orig_addInterval.call( interval, new IntervalSet.Interval( start, stop || start+1 ) );
  }
}

// probably overwrite getTokenErrorDisplay() - use token text

module.exports = {
  epsilon,
  exitRule,
  consume,
  match,
  KeywordErrorStrategy
};
