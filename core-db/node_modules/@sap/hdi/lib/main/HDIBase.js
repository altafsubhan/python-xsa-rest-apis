'use strict';
const CONSTANTS = require('../util/Constants');
const hdb = require('hdb');
const ResultTuple = require('../ResultTuple');
const APIPrivilege = require('../parameter/APIPrivilege');
const LibraryConfiguration = require('../parameter/LibraryConfiguration');

/**
 * Callback that takes errors as the first parameter and a String as the second parameter.
 * @callback StringCB
 * @param {Error} e Errors that ocurred. Is null if no errors occured.
 * @param {String} result The result. Is null if errors occured.
 */

/**
 * Base class for {@link HDI}, {@link ContainerGroup} and {@link Container} class. {@link HDI} and {@link ContainerGroup} directly inherit from {@link ContainerGroupBase}, which extends HDIBase.
 */
class HDIBase {
  /**
   * @param {Object} credentials an object containing the necessary information to connect to a HANA database
   * @param {string} credentials.host hostname for the connection
   * @param {number} credentials.port port for the connection
   * @param {string} credentials.user username for the connection
   * @param {string} credentials.password password of the user
   * @param {string[]} credentials.ca Certificates to use for the connection. Optional.
   * @param {string} paramSchema a schema that will be used to create temp tables to supply arguments to procedure calls
   * @param {string} apiSchema a schema that will be used for the api calls
   */
  constructor(credentials, paramSchema, apiSchema) {
    /**
     * API schema used by this object to make calls to the API.
     *
     * @name HDIBase#apiSchema
     */
    this.apiSchema = apiSchema;
    /**
     * Connection to the HANA database.
     * @name HDIBase#connection
     */
    this.connection = hdb.createClient(credentials);
    this.connection.on('error', (err) => {
      throw new Error(`Network connection error: ${  err}`);
    });
    /**
     * Set to keep track of the created helper tables.
     *  @name HDIBase#createdHelperTables
     */
    this.createdHelperTables = new Set();
    /**
     * Schema used to create the temp tables.
     * @name HDIBase#paramSchema
     */
    this.paramSchema = paramSchema;
  }

  /**
   * Connect to the HANA DB with the credentials passed to the constructor.
   * Requires SELECT privilege on _SYS_DI.TT_*
   * @param {StringCB} cb - The callback handling the result.
   * @returns {undefined} Returns nothing/undefined.
   * @async
   */
  connect(cb) {
    this.connection.connect((err) => {
      if (err) {
        return cb(err);
      }
      cb(null, 'OK: connected to DB.');
    });
  }

  /**
   * Disconnect from the HANA DB
   * @returns {String} Success message.
   */
  disconnect() {
    this.createdHelperTables.clear();
    this.connection.end();
    return 'Disconnected.';
  }

  /**
   * This functions fills the table tableName with the values specified in rows.
   * @param {string} tableName Table to insert the rows into.
   * @param {TableRow[]} rows array of objects of type TableRow or a class extending TableRow.
   * @param {Connection} connection Optional, db connection to use instead of the object local one.
   * @param {Set} createdHelperTables Optional, created helper tables to use instead of the local object one.
   * @returns {Promise<String>} Returns a promise that resolves to the success message.
   * @async
   */
  fillHelperTable(tableName, rows, connection = this.connection, createdHelperTables = this.createdHelperTables) {
    if (rows === null) {
      rows = [];
    }
    return new Promise((resolve) => {
      if (createdHelperTables.has(tableName)) {
        resolve(this.executeDirect(`truncate table ${this.paramSchema}.${tableName}`, connection).then(() => { }));
      } else {
        const helperTableType = CONSTANTS.HELPER_TABLE_TYPES.get(tableName);
        resolve(this.executeDirect(`create local temporary column table ${this.paramSchema}.${tableName} like ${CONSTANTS.SYS_DI_SCHEMA}.${helperTableType}`, connection).then(() => {
          createdHelperTables.add(tableName);
        }));
      }
    }).then((result) => {
      if (rows.length > 0) {
        // eslint-disable-next-line prefer-destructuring
        const firstRow = rows[0];
        const sql = `insert into ${this.paramSchema}.${tableName} (${firstRow.getFieldList()}) values (${firstRow.getPlaceholderList()})`;
        return this.executeUpdate(sql, rows, connection);
      }
      return Promise.resolve(result);
    });
  }

  /**
   * Executes a sql command.
   * @param {string} sql SQL command to execute.
   * @param {Connection} connection Optional db connection. Default is local object connection.
   * @returns {Promise<String>} Promise resolving to the success message.
   * @async
   */
  executeDirect(sql, connection = this.connection) {
    return new Promise((resolve, reject) => {
      connection.execute(sql, (err) => {
        if (err) {
          err.sql = sql;
          reject(err);
        }
        resolve(`OK: _execute_direct: ${  sql}`);
      });
    });
  }

  /**
   * Runs the specified SQL command with the supplied parameters.
   * @param {string} sql SQL command to run.
   * @param {TableRow[]} params Array of objects of type TableRow or a class extending TableRow.
   * @param {Connection} connection Optional db connection. Default is local object connection.
   * @returns {Promise<String>} Returns a promise that resolves to the success message.
   * @async
   */
  executeUpdate(sql, params, connection = this.connection) {
    return new Promise((resolve, reject) => {
      connection.prepare(sql, (err, stmt) => {
        if (err) {
          err.sql = sql;
          reject(err);
        }
        resolve(stmt);
      });
    }).then((stmt) => new Promise((resolve, reject) => {
      // Map Parameter-Objects to simple pairs of Strings.
      const parameters = [];
      params.forEach((param) => {
        param.flatten().forEach((array) => {
          parameters.push(array);
        });
      });
      stmt.exec(parameters, (err, affectedRows) => {
        if (err) {
          err.sql = stmt;
          reject(err);
        }
        resolve(`OK: _execute_update: ${  sql  }, Affected rows: ${  affectedRows}`);
      });
    }));
  }

  /* eslint-disable no-shadow */
  /**
   * Calls a procedure (sql_stmt) with parameters (sql_params) and returns the result (result).
   * @param {string} sqlStmt SQL statement to run.
   * @param {ResultTuple} result An instance of type ResultTuple or a class extending ResultTuple. Contains the result of the procedure call.
   * @param {TableRow[]} sqlParams Parameters for the procedure call. Array of objects of type TableRow or a class extending TableRow.
   * @param {Connection} connection Optional db connection. Default is local object connection.
   * @returns {Promise<ResultTuple>} Promise resolving to result, with return code etc. filled.
   * @async
   */
  executeCall(sqlStmt, result = null, sqlParams = {}, connection = this.connection) {
    /**
     * Prepares an sql statement.
     * @param {Connection} connection Open connection to a HANA database.
     * @param {string} statement SQL statement to prepare.
     * @returns {Promise} Promise resolving to the prepared statement.
     * @private
     */
    function prepare(connection, statement) {
      return new Promise((resolve, reject) => {
        connection.prepare(statement, (err, stmt) => {
          if (err) {
            reject(err);
          }
          resolve(stmt);
        });
      });
    }

    /**
     * Fill a ResultSet object with the data from a statement call.
     * @param {*} parameters Parameters of the call.
     * @param {*} messages Messages of the call.
     * @param {*} results Results of the call.
     * @param {ResultTuple} result The result to fill.
     * @returns {ResultTuple} The result, filled with  return code, requestID, messages and results.
     * @private
     */
    function fillResult(parameters, messages, results, result){
      result.rc = parameters.RETURN_CODE;
      result.requestId = parameters.REQUEST_ID;
      result.messages = messages;
      result.fillResultFromResultSet((typeof results !== 'undefined') ? results : []);
      return result;
    }

    /**
     * Executes a prepared statement.
     * @param {*} preparedStatement The prepared statement to execute.
     * @param {*} parameters Parameters for the sql statement.
     * @param {ResultTuple} result Instance of a ResultTuple or a subclass.
     * @returns {Promise<ResultTuple>} The result, filled with  return code, requestID, messages and results.
     * @private
     */
    function execute(preparedStatement, parameters, result) {
      return new Promise((resolve, reject) => {
        preparedStatement.exec(parameters, (err, parameters, messages, results) => {
          if (err) {
            err.sqlParams = sqlParams;
            reject(err);
          } else {
            resolve(fillResult(parameters, messages, results, result));
          }
        });
      });
    }

    if (result === null) {
      result = new ResultTuple();
    }

    return prepare(connection, sqlStmt)
      .then((preparedStatement) => execute(preparedStatement, sqlParams, result));
  }

  /* eslint-enable no-shadow */
  /**
   * Returns the default privileges required for working with a container
   * Requires SELECT privilege on _SYS_DI.T_DEFAULT_CONTAINER_USER_PRIVILEGES
   * Minimum required HANA server version: 2.00.010
   * @param {string} principalSchema schema of the target user/role (empty for global principals)
   * @param {string} principalName name of the target user/role
   * @param {APIPrivilegesCB} cb - The callback handling the result.
   * @returns {undefined} Returns nothing/undefined.
   * @async
   */
  getDefaultContainerUserPrivileges(principalSchema, principalName, cb) {
    const sql = `select PRIVILEGE_NAME, OBJECT_NAME from ${CONSTANTS.CONTAINER_USER_PRIVILEGES_TABLE}`;
    this.getAPIPrivileges(sql, principalSchema, principalName)
      .then((privileges) => cb(null, privileges))
      .catch(cb);
  }

  /**
   * Returns the default privileges required for administration of a container
   * Requires SELECT privilege on _SYS_DI.T_DEFAULT_CONTAINER_ADMIN_PRIVILEGES
   * Minimum required HANA server version: 2.00.010
   * @param {string} principalSchema schema of the target user/role (empty for global principals)
   * @param {string} principalName name of the target user/role
   * @param {APIPrivilegesCB} cb - The callback handling the result.
   * @returns {undefined} Returns nothing/undefined.
   * @async
   */
  getDefaultContainerAdminPrivileges(principalSchema, principalName, cb) {
    const sql = `select PRIVILEGE_NAME, OBJECT_NAME from ${CONSTANTS.CONTAINER_ADMIN_PRIVILEGES_TABLE}`;
    this.getAPIPrivileges(sql, principalSchema, principalName)
      .then((privileges) => cb(null, privileges))
      .catch(cb);
  }

  /**
   * Callback that takes errors as the first parameter and a MakeGroupResultTuple as the second parameter.
   * @callback LibraryConfigurationsCB
   * @param {Error} e Errors that ocurred. Is null if no errors occured.
   * @param {LibraryConfiguration[]} result The result. Is null if errors occured.
   */
  /**
   * Requires SELECT privilege on _SYS_DI.T_DEFAULT_LIBRARIES
   * @param {LibraryConfigurationsCB} cb List of LibraryConfigurations, which can be passed to configureLibrary calls
   * @returns {undefined} Returns nothing/undefined.
   * @async
   */
  getDefaultLibraries(cb) {
    const sql = `select ACTION, LIBRARY_NAME from ${CONSTANTS.DEFAULT_LIBRARIES_TABLE}`;
    this._execute(sql)
      .then((rows) => rows.map((row) => new LibraryConfiguration(row.ACTION, row.LIBRARY_NAME)))
      .then((libraries) => cb(null, libraries))
      .catch(cb);
  }

  /**
   * Fetches API privileges for a given user/role.
   * @param {string} sql SQL statement to execute
   * @param {string} principalSchema Schema of the target user/role (empty for global principals)
   * @param {string} principalName name of the target user/role
   * @returns {APIPrivilege[]} A list of api privileges for the user/role.
   * @memberof HDIBase
   * @private
   */
  getAPIPrivileges(sql, principalSchema, principalName) {
    return this._execute(sql)
      .then((rows) => rows.map((row) => new APIPrivilege(row.PRIVILEGE_NAME, row.OBJECT_NAME, principalSchema, principalName)));
  }

  /**
   * Executes an sql statement.
   * @param {string} sql Statement to execute.
   * @returns {Promise<*>} Promise returning the rows returned by the statement.
   * @memberof HDIBase
   * @private
   */
  _execute(sql) {
    return new Promise((resolve, reject) => {
      this.connection.exec(sql, (err, rows) => {
        if (err) {
          err.sql = sql;
          reject(err);
        }
        resolve(rows);
      });
    });
  }
}
module.exports = HDIBase;